
; ******** Source: src\snake.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/cx16-snake
     8                          ;
     9                          ;
    10                          
    11                          !cpu 65c02
    12                          

; ******** Source: src\common\bootstrap.asm
     1                          ; Commander X16
     2                          ;
     3                          ; ACME assembler bootstrap for 6502
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          ; standard bootstrap
    14                          ; generate SYS 2064 ($810)
    15                          
    16                          *=$0801			; Assembled code should start at $0801
    17                          
    18                          			; (where BASIC programs start)
    19                          			; The real program starts at $0810 = 2064
    20                                
    21  0801 0c08               !byte $0C,$08		; $080C - pointer to next line of BASIC code
    22  0803 0a00               !byte $0A,$00		; 2-byte line number ($000A = 10)
    23  0805 9e                 !byte $9E		; SYS BASIC token
    24  0806 20                 !byte $20		; [space]
    25  0807 32303634           !text "2064"	; $32="2",$30="0",$36="6",$34="4"
    26                          			; (ASCII encoded nums for dec starting addr)
    27  080b 000000             !byte $00,$00,$00	
    28                          

; ******** Source: src\snake.asm
    13                          

; ******** Source: src\common\kernal\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; CX16 Kernal Constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_KERNAL_CONSTANTS_ASM_ = 1
    13                          
    14                          !cpu 65c02
    15                          
    16                          ; temporary address used where self-modifying code will update an instruction
    17                          SELF_MODIFY_MSB_ADDR = $ee00
    18                          SELF_MODIFY_ADDR     = $eeee
    19                          
    20                          
    21                          CHROUT      = $FFD2	; CHROUT outputs a character (C64 Kernal API)
    22                          CHRIN       = $FFCF		; CHRIN read from default input
    23                          
    24                          SETLFS			= $FFBA
    25                          SETNAM			= $FFBD
    26                          LOAD			  = $FFD5
    27                          OPEN        = $FFC0
    28                          CLOSE       = $FFC3
    29                          
    30                          BANKED_RAM_START    = $A000
    31                          BANKED_RAM_END      = $BFFF
    32                          ROM_BANK            = $9F60
    33                          RAM_BANK            = $9F61
    34                          
    35                          ; have a separate one for sanity checks
    36                          ; so I can find the others I use temporarily
    37                          ; easier
    38                          !macro dbgSanityCheckBreak {
    39                            !ifdef SANITY { !byte $ff }
    40                          }
    41                          
    42                          !macro dbgBreak {
    43                            !ifdef DEBUG { !byte $ff }
    44                          }
    45                          
    46                          !macro setRamBank bank {
    47                            lda #bank
    48                            sta RAM_BANK
    49                          }
    50                          
    51                          !macro setRomBank bank {
    52                            lda #bank
    53                            sta ROM_BANK
    54                          }
    55                          
    56                          !macro ramBankSanityCheck bank {
    57                            !ifdef SANITY {
    58                              phy
    59                              ldy RAM_BANK
    60                              cpy #bank
    61                              beq +
    62                              !byte $ff
    63                          +
    64                              ply
    65                            }
    66                          }
    67                          
    68                          
    69                          ; Joystick constants
    70                          ; ----------------------------------------------------------------------------
    71                          ; subroutines
    72                          
    73                          JOYSTICK_SCAN = $ff53
    74                          
    75                          ; Get joystick state
    76                          ; A = buttons
    77                          ; X = xtended buttons (SNES)
    78                          ; Y = device present ($00) or not ($FF)
    79                          JOYSTICK_GET  = $ff56
    80                          
    81                          ; constants
    82                          JOY_RIGHT  = %00000001
    83                          JOY_LEFT   = %00000010
    84                          JOY_DOWN   = %00000100
    85                          JOY_UP     = %00001000
    86                          JOY_START  = %00010000
    87                          JOY_SELECT = %00100000
    88                          JOY_B      = %01000000
    89                          JOY_A      = %10000000
    90                          
    91                          JOYSTICK_PRESENT     = $00
    92                          JOYSTICK_NOT_PRESENT = $ff
    93                          
    94                          CLOCK_GET_DATE_TIME = $ff50
    95                          
    96                          ; Virtual registers
    97                          ; ----------------------------------------------------------------------------
    98                          R0  = $02
    99                          R0L = R0
   100                          R0H = R0 + 1
   101                          R1  = $04
   102                          R1L = R1
   103                          R1H = R1 + 1
   104                          R2  = $06
   105                          R2L = R2
   106                          R2H = R2 + 1
   107                          R3  = $08
   108                          R3L = R3
   109                          R3H = R3 + 1
   110                          R4  = $0a
   111                          R4L = R4
   112                          R4H = R4 + 1
   113                          R5  = $0c
   114                          R5L = R5
   115                          R5H = R5 + 1
   116                          R6  = $0e
   117                          R6L = R6
   118                          R6H = R6 + 1
   119                          R7  = $10
   120                          R7L = R7
   121                          R7H = R7 + 1
   122                          R8  = $12
   123                          R8L = R8
   124                          R8H = R8 + 1
   125                          R9  = $14
   126                          R9L = R9
   127                          R9H = R9 + 1
   128                          R10  = $16
   129                          R10L = R10
   130                          R10H = R10 + 1
   131                          R11  = $18
   132                          R11L = R11
   133                          R11H = R11 + 1

; ******** Source: src\snake.asm
    14                          
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; constants
    18                          ; -----------------------------------------------------------------------------
    19                          ADDR_QUEUE_HEADERS = $6000 ; 4KB
    20                          
    21                          
    22                          ; -----------------------------------------------------------------------------
    23                          ; program entry
    24                          ; -----------------------------------------------------------------------------
    25                          
    26  0810 78                   sei
    27                          
    28                            ; turn off the display while we're setting things up
    29  0811 20e90b               jsr disableDisplay
    30                          
    31                            ; initialise queues
    32  0814 20af08               jsr qInit
    33                          
    34  0817 202c0c               jsr loadTiles
    35                          
    36                            ; set up and enable the display
    37  081a 20ef0b               jsr configDisplay
    38                          
    39                            ; register the vsync interrupt handler
    40  081d 20c60b               jsr registerVsyncIrq
    41                          
    42  0820 58                   cli
    43                          
    44                            ; enter the game loop
    45  0821 4cb00f               jmp waitForVsync
    46                          
    47  0824 60                   rts
    48                          
    49                          

; ******** Source: src\common\util.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Utility subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_UTIL_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; +dec16: decement a 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  addr: address containing LSB of value to decrement
    22                          ; -----------------------------------------------------------------------------
    23                          !macro dec16 addr {
    24                            lda addr
    25                            bne +
    26                            dec addr + 1
    27                          +
    28                            dec addr
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; +inc16: increment a 16-bit value
    33                          ; -----------------------------------------------------------------------------
    34                          ; Inputs:
    35                          ;  addr: address containing LSB of value to increment
    36                          ; -----------------------------------------------------------------------------
    37                          !macro inc16 addr {
    38                            inc addr
    39                            bne +
    40                            inc addr + 1
    41                          +
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; +cmp16: compare two 16-bit values in memory
    46                          ; -----------------------------------------------------------------------------
    47                          ; Inputs:
    48                          ;  left:  address containing LSB of left value to comapre
    49                          ;  right: address containing LSB of right value to comapre
    50                          ; -----------------------------------------------------------------------------
    51                          !macro cmp16 left, right {
    52                            lda left + 1
    53                            cmp right + 1
    54                          	bne +
    55                          	lda left
    56                          	cmp right
    57                          +
    58                          }
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; +cmp16: compare two 16-bit values in memory
    62                          ; -----------------------------------------------------------------------------
    63                          ; Inputs:
    64                          ;  value: immediate value to compare
    65                          ;  x:     msb
    66                          ;  a:     lsb
    67                          ; -----------------------------------------------------------------------------
    68                          !macro cmp16xa value {
    69                            cpx #>value
    70                          	bne +
    71                          	cmp #<value
    72                          +
    73                          }
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; +sub16: subtract 16 bit numbers
    77                          ; -----------------------------------------------------------------------------
    78                          ; Inputs:
    79                          ;  left:  address containing LSB of left value
    80                          ;  right: address containing LSB of right value
    81                          ; Outputs:
    82                          ;  res:   address containing LSB of result
    83                          ; -----------------------------------------------------------------------------
    84                          !macro sub16 left, right, res {
    85                            sec
    86                            lda left
    87                            sbc right
    88                            sta res
    89                            lda left + 1
    90                            sbc right + 1
    91                            sta res + 1
    92                          }
    93                          
    94                          ; -----------------------------------------------------------------------------
    95                          ; +sub16: subtract 16 bit numbers - result in ax registers
    96                          ; -----------------------------------------------------------------------------
    97                          ; Inputs:
    98                          ;  left:  address containing LSB of left value
    99                          ;  right: address containing LSB of right value
   100                          ; Outputs:
   101                          ;  a:     result msb
   102                          ;  x:     result lsb
   103                          ; -----------------------------------------------------------------------------
   104                          !macro sub16 left, right {
   105                            sec
   106                            lda left
   107                            sbc right
   108                            tax
   109                            lda left + 1
   110                            sbc right + 1
   111                          }
   112                          
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   116                          ; -----------------------------------------------------------------------------
   117                          ; Inputs:
   118                          ;  left:  address containing LSB of left value
   119                          ;  right: immediate 8-bit value
   120                          ; Outputs:
   121                          ;  res:   address containing LSB of result
   122                          ; -----------------------------------------------------------------------------
   123                          !macro subImm8From16 left, right, res {
   124                            sec
   125                            lda left
   126                            sbc #right
   127                            sta res
   128                            lda left + 1
   129                            sbc #0
   130                            sta res + 1
   131                          }
   132                          
   133                          ; -----------------------------------------------------------------------------
   134                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   135                          ; -----------------------------------------------------------------------------
   136                          ; Inputs:
   137                          ;  addr:  address containing BCD value
   138                          ; -----------------------------------------------------------------------------
   139                          !macro incBcd addr {
   140                            lda addr
   141                            sed
   142                            clc
   143                            adc #1
   144                            cld
   145                            sta addr
   146                          }
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;  addr:  address containing BCD value
   153                          ; -----------------------------------------------------------------------------
   154                          !macro decBcd addr {
   155                            lda addr
   156                            sed
   157                            sec
   158                            sbc #1
   159                            cld
   160                            sta addr
   161                          }
   162                          
   163                          ; -----------------------------------------------------------------------------
   164                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
   165                          ; -----------------------------------------------------------------------------
   166                          ; Inputs:
   167                          ;   A: value
   168                          ; Outputs:
   169                          ;   BCD value in R8
   170                          ; -----------------------------------------------------------------------------
   171                          bin2bcd8:
   172  0825 8510                 sta R7L
   173  0827 6412                 stz R8L
   174  0829 6413                 stz R8H
   175  082b a208                 ldx #8 
   176  082d f8                   sed    
   177                          .loop:
   178  082e 0610                 asl R7L
   179  0830 a512                 lda R8L
   180  0832 6512                 adc R8L
   181  0834 8512                 sta R8L
   182  0836 a513                 lda R8H
   183  0838 6513                 adc R8H
   184  083a 8513                 sta R8H
   185  083c ca                   dex
   186  083d d0ef                 bne .loop
   187  083f d8                   cld   
   188  0840 60                   rts
   189                          

; ******** Source: src\snake.asm
    50                          

; ******** Source: src\common\file.asm
     1                          ; Commander X16
     2                          ;
     3                          ; File utilities
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_FILE_ASM_ = 1
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; setFile:   set the current file to work with
    18                          ; -----------------------------------------------------------------------------
    19                          ; filename:  address of zero-terminated string
    20                          ; -----------------------------------------------------------------------------
    21                          !macro setFile filename {
    22                            ldx #<filename
    23                            ldy #>filename
    24                            jsr strLen
    25                            jsr SETNAM
    26                          }
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; loadFile:   helper to load a file into ram
    30                          ; -----------------------------------------------------------------------------
    31                          ; filename:  zero-terminated string
    32                          ; ramArress: address to load the raw data
    33                          ; -----------------------------------------------------------------------------
    34                          !macro loadFile filename, address {
    35                          
    36                            !if <address != $00 {
    37                              !error "output address must be aligned to a page boundry"
    38                            }
    39                          
    40                            +setFile filename
    41                          
    42                            lda #>address
    43                          
    44                            jsr loadFile
    45                          }
    46                          
    47                          ; -----------------------------------------------------------------------------
    48                          ; loadFile: load raw data file into ram
    49                          ; -----------------------------------------------------------------------------
    50                          ; Prerequisites:
    51                          ;   SETNAME called 
    52                          ; Inputs:
    53                          ;   A: MSB of output address
    54                          ; -----------------------------------------------------------------------------
    55                          loadFile:
    56  0841 48                   pha
    57  0842 a901                 lda #$01
    58  0844 a208                 ldx #$08      ; default to device 8
    59  0846 a000                 ldy #$00      ; $00 means: load to new address
    60  0848 20baff               jsr SETLFS
    61                          
    62  084b a202                 ldx #$02        ; account for address header 
    63  084d 7a                   ply
    64  084e a900                 lda #$00      ; $00 means: load to memory (not verify)
    65  0850 20d5ff               jsr LOAD
    66  0853 b005                 bcs .errorLoad    ; if carry set, a load error has happened
    67                          
    68  0855 8606                 stx R2L
    69  0857 8407                 sty R2H
    70                          
    71  0859 60                   rts
    72                          .errorLoad
    73  085a 00                   brk
    74  085b 60                   rts

; ******** Source: src\snake.asm
    51                          

; ******** Source: src\common\memory.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Memory subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_MEMORY_ASM_ = 1
    14                          
    15                          !zone memcpy {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; memcpy: Copy a fixed number of bytes from src to dest
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  src: source address
    22                          ;  dst: destination address
    23                          ;  cnt: number of bytes
    24                          ; -----------------------------------------------------------------------------
    25                          !macro memcpy src, dst, cnt {
    26                            lda #<src
    27                            sta R0L
    28                            lda #>src
    29                            sta R0H
    30                          
    31                            lda #<dst
    32                            sta R1L
    33                            lda #>dst
    34                            sta R1H
    35                          
    36                            ldy #<cnt
    37                          
    38                            !if cnt <= 255 {
    39                              jsr memcpySinglePage 
    40                            } else {
    41                              ldx #>cnt
    42                              jsr memcpyMultiPage
    43                            }
    44                          }
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; memcpySinglePage: Copy up to 255 bytes 
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  R0: src address
    51                          ;  R1: dst address
    52                          ;  Y:  bytes
    53                          ; -----------------------------------------------------------------------------
    54                          memcpySinglePage:
    55  085c b102                 lda (R0), Y
    56  085e 9104                 sta (R1), Y
    57  0860 88                   dey
    58  0861 d0f9                 bne memcpySinglePage
    59  0863 60                   rts
    60                          ; -----------------------------------------------------------------------------
    61                          
    62                          
    63                          ; -----------------------------------------------------------------------------
    64                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    65                          ; -----------------------------------------------------------------------------
    66                          ; Inputs:
    67                          ;  R0: src address
    68                          ;  R1: dst address
    69                          ;  X:  bytes MSB
    70                          ;  Y:  bytes LSB
    71                          ; -----------------------------------------------------------------------------
    72                          memcpyMultiPage:
    73  0864 a502                 lda R0L
    74  0866 8d7908               sta .loadIns + 1
    75  0869 a503                 lda R0H
    76  086b 8d7a08               sta .loadIns + 2
    77                          
    78  086e a504                 lda R1L
    79  0870 8d7c08               sta .storeIns + 1
    80  0873 a505                 lda R1H
    81  0875 8d7d08               sta .storeIns + 2
    82                          
    83                          .loadIns:
    84  0878 b9eeee               lda SELF_MODIFY_ADDR, Y
    85                            
    86                          .storeIns:
    87  087b 99eeee               sta SELF_MODIFY_ADDR, Y
    88  087e 88                   dey
    89  087f d0f7                 bne .loadIns
    90  0881 ee7a08               inc .loadIns + 2
    91  0884 ee7d08               inc .storeIns + 2
    92  0887 ca                   dex
    93  0888 d0ee                 bne .loadIns
    94                          
    95  088a 60                   rts
    96                          ; -----------------------------------------------------------------------------
    97                          
    98                          }
    99                          
   100                          
   101                          
   102                          
   103                          !zone mem2reg {
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; mem2regSinglePage: Copy up to 255 bytes from ram to a register stream
   107                          ; -----------------------------------------------------------------------------
   108                          ; Inputs:
   109                          ;  R0: src address
   110                          ;  R1: output register address
   111                          ;  X:  bytes
   112                          ; -----------------------------------------------------------------------------
   113                          !macro mem2regSinglePage outReg {
   114                            ldy #0
   115                          -
   116                            lda (R0), y
   117                            sta outReg
   118                            iny
   119                            dex
   120                            bne -
   121                          }
   122                          ; -----------------------------------------------------------------------------
   123                          
   124                          
   125                          ; -----------------------------------------------------------------------------
   126                          ; mem2reg: Copy a fixed number of bytes from src to dest
   127                          ; -----------------------------------------------------------------------------
   128                          ; Inputs:
   129                          ;  src: source address
   130                          ;  dst: destination register stream address
   131                          ;  cnt: number of bytes
   132                          ; -----------------------------------------------------------------------------
   133                          !macro mem2reg src, dst, cnt {
   134                            lda #<src
   135                            sta R0L
   136                            lda #>src
   137                            sta R0H
   138                          
   139                            ldx #<cnt
   140                          
   141                            !if cnt <= 255 {
   142                              +mem2regSinglePage dst
   143                            } else {
   144                              lda #<dst
   145                              sta mem2regMultiPageStoreIns + 1
   146                              lda #>dst
   147                              sta mem2regMultiPageStoreIns + 2
   148                              ldy #>cnt
   149                              jsr mem2regMultiPage
   150                            }
   151                          }
   152                          
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; mem2regMultiPage: Copy memory to a register stream 
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  R0: src address
   159                          ;  R1: output register address
   160                          ;  X:  bytes LSB
   161                          ;  Y:  bytes MSB
   162                          ; -----------------------------------------------------------------------------
   163                          mem2regMultiPage:
   164  088b a502                 lda R0L
   165  088d 8d9b08               sta .loadIns + 1
   166  0890 a503                 lda R0H
   167  0892 8d9c08               sta .loadIns + 2
   168                          
   169  0895 c8                   iny
   170                            
   171  0896 8a                   txa
   172  0897 d001                 bne +
   173  0899 88                   dey
   174                          +
   175                          
   176                           
   177                          .loadIns:
   178  089a adffff               lda $ffff
   179                            
   180                          mem2regMultiPageStoreIns:
   181  089d 8dffff               sta $ffff
   182  08a0 ee9b08d003ee9c08     +inc16 .loadIns + 1
   183  08a8 ca                   dex
   184  08a9 d0ef                 bne .loadIns
   185  08ab 88                   dey
   186  08ac d0ec                 bne .loadIns
   187                          
   188  08ae 60                   rts
   189                          ; -----------------------------------------------------------------------------
   190                          

; ******** Source: src\snake.asm
    52                          

; ******** Source: src\common\queue.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Queue management
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_QUEUE_ASM_ = 1
    13                          
    14                          !ifndef ADDR_QUEUE_HEADERS  { !error "Must set address for queue system to use: ADDR_QUEUE_HEADERS" }
    15                          
    16                          QUEUE_HEADER_SIZE = 4
    17                          
    18                          ; queue data structure (ADDR_QUEUE_HEADERS)
    19                          ; 0:  count of queues created
    20                          ; 1: unused
    21                          ;   (below repeated for each queue created). page is >ADDR_QUEUE_HEADERS + queue index
    22                          ; 2: head (page offset)
    23                          ; 3: tail (page offset)
    24                          
    25                          QUEUE_OFFSET_HEAD = 0
    26                          QUEUE_OFFSET_TAIL = 1
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; qInit: Initialise queue manager
    30                          ; -----------------------------------------------------------------------------
    31                          qInit:
    32  08af 9c0060               stz ADDR_QUEUE_HEADERS
    33  08b2 60                   rts
    34                          
    35                          ; -----------------------------------------------------------------------------
    36                          ; qInit: create a queue, store its id in address
    37                          ; -----------------------------------------------------------------------------
    38                          !macro qCreate index, addressMsb {
    39                            jsr qCreate
    40                            stx index
    41                            sta addressMsb
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; qPush: push a value to a queue
    46                          ; -----------------------------------------------------------------------------
    47                          !macro qPush index {
    48                            ldx index
    49                            jsr qPush
    50                          }
    51                          
    52                          ; -----------------------------------------------------------------------------
    53                          ; qPop: pop a value from the queue
    54                          ; -----------------------------------------------------------------------------
    55                          !macro qPop index {
    56                            ldx index
    57                            jsr qPop
    58                          }
    59                          
    60                          
    61                          ; -----------------------------------------------------------------------------
    62                          ; qFront: get offset to front of queue
    63                          ; -----------------------------------------------------------------------------
    64                          !macro qFront index {
    65                            ldx index
    66                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
    67                          }
    68                          
    69                          
    70                          ; -----------------------------------------------------------------------------
    71                          ; qBack: get offset to back of queue
    72                          ; -----------------------------------------------------------------------------
    73                          !macro qBack index {
    74                            pha
    75                            lda index
    76                            asl
    77                            tax
    78                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
    79                            dey
    80                            pla
    81                          }
    82                          
    83                          ; -----------------------------------------------------------------------------
    84                          ; qIterate: iterate a queue
    85                          ; -----------------------------------------------------------------------------
    86                          !macro qIterate index {
    87                            ldx index
    88                            jsr qIterate
    89                          }
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; qSize: return size of queue
    93                          ; -----------------------------------------------------------------------------
    94                          !macro qSize index {
    95                            ldx index
    96                            jsr qSize
    97                          }
    98                          
    99                          ; -----------------------------------------------------------------------------
   100                          ; qInit: create a queue
   101                          ; -----------------------------------------------------------------------------
   102                          ; Inputs: none
   103                          ; Returns:
   104                          ;   x: Queue index
   105                          ;   a: Queue MSB
   106                          ; -----------------------------------------------------------------------------
   107                          qCreate:
   108                            ; get the current number of queues
   109                            ; increment it and store it
   110  08b3 ad0060               lda ADDR_QUEUE_HEADERS
   111  08b6 1a                   inc
   112  08b7 aa                   tax
   113  08b8 8e0060               stx ADDR_QUEUE_HEADERS
   114                          
   115                            ; now write the queue header (head and tail will be zero)
   116  08bb 0a                   asl ; double it since there are 2 bytes per queue header
   117  08bc a8                   tay
   118  08bd a900                 lda #0
   119  08bf 990060               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD,y
   120  08c2 990160               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL,y
   121  08c5 98                   tya
   122  08c6 18                   clc
   123  08c7 6960                 adc #>ADDR_QUEUE_HEADERS
   124  08c9 60                   rts
   125                          
   126                          ; -----------------------------------------------------------------------------
   127                          ; qPushBack: push a value onto the back of a queue
   128                          ; -----------------------------------------------------------------------------
   129                          ; inputs:
   130                          ;   A: value to push
   131                          ;   X: queue index
   132                          ; -----------------------------------------------------------------------------
   133                          qPush:
   134                          qPushBack:
   135  08ca 48                   pha
   136  08cb da                   phx
   137                            ; get queue tail
   138                            
   139  08cc 8a                   txa
   140  08cd 0a                   asl
   141  08ce 18                   clc
   142  08cf 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   143  08d1 8de108               sta .ldaOffsetPush + 2
   144  08d4 8a                   txa   ; find the tail, place in y
   145  08d5 0a                   asl
   146  08d6 aa                   tax
   147  08d7 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   148  08da fe0160               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   149  08dd fa                   plx
   150  08de 68                   pla
   151                          .ldaOffsetPush
   152  08df 9900ee               sta SELF_MODIFY_MSB_ADDR, y
   153  08e2 60                   rts
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; qPopFront: pop a value from the from of the front of the queue
   157                          ; -----------------------------------------------------------------------------
   158                          ; inputs:
   159                          ;   X: queue index
   160                          ; returns
   161                          ;   A: value
   162                          ; -----------------------------------------------------------------------------
   163                          qPop:
   164                          qPopFront:
   165  08e3 da                   phx
   166  08e4 8a                   txa
   167  08e5 18                   clc
   168  08e6 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   169  08e8 8df708               sta .ldaOffsetPop + 2
   170  08eb 8a                   txa   ; find the head, place in y
   171  08ec 0a                   asl
   172  08ed aa                   tax
   173  08ee bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   174  08f1 fe0060               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   175  08f4 fa                   plx
   176                          .ldaOffsetPop
   177  08f5 b900ee               lda SELF_MODIFY_MSB_ADDR, y
   178  08f8 60                   rts
   179                          
   180                          ; -----------------------------------------------------------------------------
   181                          ; qBack: get offset to front of queue
   182                          ; -----------------------------------------------------------------------------
   183                          ; inputs:
   184                          ;   X: queue index
   185                          ; returns
   186                          ;   Y: front offset
   187                          ; -----------------------------------------------------------------------------
   188                          qBack:
   189  08f9 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   190  08fc 88                   dey
   191  08fd 60                   rts
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; qFront: get offset to front of queue
   195                          ; -----------------------------------------------------------------------------
   196                          ; inputs:
   197                          ;   X: queue index
   198                          ; returns
   199                          ;   Y: front offset
   200                          ; -----------------------------------------------------------------------------
   201                          qFront:
   202  08fe bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   203  0901 60                   rts
   204                          ; -----------------------------------------------------------------------------
   205                          ; qSize: return the queue size
   206                          ; -----------------------------------------------------------------------------
   207                          ; inputs:
   208                          ;   X: queue index
   209                          ; returns
   210                          ;   A: size
   211                          ; -----------------------------------------------------------------------------
   212                          qSize:
   213  0902 8a                   txa
   214  0903 0a                   asl ; get offset
   215  0904 a8                   tay
   216  0905 b90160               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, y
   217  0908 38                   sec
   218  0909 f90060               sbc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   219  090c 60                   rts
   220                          
   221                          ; -----------------------------------------------------------------------------
   222                          ; qIterate: set up to iterate a queue
   223                          ; -----------------------------------------------------------------------------
   224                          ; inputs:
   225                          ;   X: queue index
   226                          ; returns
   227                          ;   A: MSB byte of queue
   228                          ;   Y: starting offset (head index)
   229                          ; -----------------------------------------------------------------------------
   230                          qIterate:
   231  090d 8a                   txa
   232  090e 0a                   asl ; get offset
   233  090f a8                   tay
   234  0910 b90060               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   235  0913 a8                   tay
   236  0914 8a                   txa
   237  0915 0a                   asl
   238  0916 18                   clc
   239  0917 6960                 adc #>ADDR_QUEUE_HEADERS
   240  0919 60                   rts

; ******** Source: src\snake.asm
    53                          

; ******** Source: src\common\string.asm
     1                          ; Commander X16
     2                          ;
     3                          ; String subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_STRING_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; strLen: Length of a null-terminated string
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  X: address LSB
    22                          ;  Y: address MSB
    23                          ; Outputs:
    24                          ;  A: length
    25                          ; -----------------------------------------------------------------------------
    26                          strLen:
    27                          !zone
    28  091a 5a                   phy
    29  091b 8e2409               stx .loop + 1        ; save string pointer LSB
    30  091e 8c2509               sty .loop + 2        ; save string pointer MSB
    31  0921 a000                 ldy #0               ; starting string index
    32                          
    33                          .loop:
    34  0923 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    35  0926 f003                 beq .end             ; end of string
    36  0928 c8                   iny                  ; next
    37  0929 80f8                 bra .loop
    38                          
    39                          .end:
    40  092b 98                   tya
    41  092c 7a                   ply
    42  092d 60                   rts
    43                          ; -----------------------------------------------------------------------------
    44                          
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; printStr: Print a null-terminated string
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  X: address LSB
    51                          ;  Y: address MSB
    52                          ; -----------------------------------------------------------------------------
    53                          printStr:
    54                          !zone 
    55  092e 8e3709               stx .loop + 1        ; save string pointer LSB
    56  0931 8c3809               sty .loop + 2        ; save string pointer MSB
    57  0934 a000                 ldy #0               ; starting string index
    58                          
    59                          .loop:
    60  0936 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    61  0939 f006                 beq .end             ; end of string
    62                          
    63  093b 20d2ff               jsr CHROUT           ; print character
    64  093e c8                   iny                  ; next
    65  093f 80f5                 bra .loop
    66                          
    67                          .end:
    68  0941 60                   rts
    69                          ; -----------------------------------------------------------------------------
    70                          
    71                          
    72                          !macro printStr stringAddr {
    73                            ldx #<stringAddr
    74                            ldy #>stringAddr
    75                            jsr printStr

; ******** Source: src\snake.asm
    54                          
    55                          

; ******** Source: src\common\vera\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_VERA_CONSTANTS_ = 1
    13                          
    14                          VERA_ADDRx_L      = $9F20
    15                          VERA_ADDRx_M      = $9F21
    16                          VERA_ADDRx_H      = $9F22
    17                          VERA_DATA0        = $9F23
    18                          VERA_DATA1        = $9F24
    19                          VERA_CTRL         = $9F25
    20                          VERA_IEN          = $9F26
    21                          VERA_ISR          = $9F27
    22                          VERA_IRQLINE_L    = $9F28
    23                          VERA_DC_VIDEO     = $9F29
    24                          VERA_DC_HSCALE    = $9F2A
    25                          VERA_DC_VSCALE    = $9F2B
    26                          VERA_DC_BORDER    = $9F2C
    27                          VERA_DC_HSTART    = $9F29
    28                          VERA_DC_HSTOP     = $9F2A
    29                          VERA_DC_VSTART    = $9F2B
    30                          VERA_DC_VSTOP     = $9F2C
    31                          VERA_L0_CONFIG    = $9F2D
    32                          VERA_L0_MAPBASE   = $9F2E
    33                          VERA_L0_TILEBASE  = $9F2F
    34                          VERA_L0_HSCROLL_L = $9F30
    35                          VERA_L0_HSCROLL_H = $9F31
    36                          VERA_L0_VSCROLL_L = $9F32
    37                          VERA_L0_VSCROLL_H = $9F33
    38                          VERA_L1_CONFIG    = $9F34
    39                          VERA_L1_MAPBASE   = $9F35
    40                          VERA_L1_TILEBASE  = $9F36
    41                          VERA_L1_HSCROLL_L = $9F37
    42                          VERA_L1_HSCROLL_H = $9F38
    43                          VERA_L1_VSCROLL_L = $9F39
    44                          VERA_L1_VSCROLL_H = $9F3A
    45                          VERA_AUDIO_CTRL   = $9F3B
    46                          VERA_AUDIO_RATE   = $9F3C
    47                          VERA_AUDIO_DATA   = $9F3D
    48                          VERA_SPI_DATA     = $9F3E
    49                          VERA_SPI_CTRL     = $9F3F
    50                          
    51                          ; ADDRx_H increments
    52                          ; -----------------------------------------------------------------------------
    53                          VERA_INCR_0   = $00
    54                          VERA_INCR_1   = $10
    55                          VERA_INCR_2   = $20
    56                          VERA_INCR_4   = $30
    57                          VERA_INCR_8   = $40
    58                          VERA_INCR_16  = $50
    59                          VERA_INCR_32  = $60
    60                          VERA_INCR_64  = $70
    61                          VERA_INCR_128 = $80
    62                          VERA_INCR_256 = $90
    63                          VERA_INCR_512 = $A0
    64                          VERA_INCR_40  = $B0
    65                          VERA_INCR_80  = $C0
    66                          VERA_INCR_160 = $D0
    67                          VERA_INCR_320 = $E0
    68                          VERA_INCR_640 = $F0
    69                          
    70                          VERA_DECR     = $08
    71                          
    72                          
    73                          ; Interrupts
    74                          ; -----------------------------------------------------------------------------
    75                          VERA_IEN_VSYNC  = $01
    76                          VERA_IEN_LINE   = $02
    77                          VERA_IEN_SPRCOL = $04
    78                          VERA_IEN_AFLOW  = $08
    79                          
    80                          
    81                          ; DC_VIDEO
    82                          ; -----------------------------------------------------------------------------
    83                          VERA_VIDEO_SPRITES_ENABLED  = $40
    84                          VERA_VIDEO_LAYER1_ENABLED   = $20
    85                          VERA_VIDEO_LAYER0_ENABLED   = $10
    86                          VERA_VIDEO_OUTPUT_DISABLED  = $00
    87                          VERA_VIDEO_OUTPUT_VGA       = $01
    88                          VERA_VIDEO_OUTPUT_NTSC      = $02
    89                          VERA_VIDEO_OUTPUT_RGB       = $03
    90                          
    91                          ; DC_SCALE
    92                          ; -----------------------------------------------------------------------------
    93                          VERA_SCALE_1x               = $80
    94                          VERA_SCALE_2x               = $40
    95                          VERA_SCALE_4x               = $20
    96                          
    97                          ; Lx_CONFIG
    98                          ; -----------------------------------------------------------------------------
    99                          VERA_CONFIG_1BPP          = $0
   100                          VERA_CONFIG_2BPP          = $1
   101                          VERA_CONFIG_4BPP          = $2
   102                          VERA_CONFIG_8BPP          = $3
   103                          
   104                          VERA_CONFIG_BITMAP_MODE   = $4
   105                          
   106                          VERA_CONFIG_MAP_WIDTH_32  = ($0 << 4)
   107                          VERA_CONFIG_MAP_WIDTH_64  = ($1 << 4)
   108                          VERA_CONFIG_MAP_WIDTH_128 = ($2 << 4)
   109                          VERA_CONFIG_MAP_WIDTH_256 = ($3 << 4)
   110                          
   111                          VERA_CONFIG_MAP_HEIGHT_32  = ($0 << 6)
   112                          VERA_CONFIG_MAP_HEIGHT_64  = ($1 << 6)
   113                          VERA_CONFIG_MAP_HEIGHT_128 = ($2 << 6)
   114                          VERA_CONFIG_MAP_HEIGHT_256 = ($3 << 6)
   115                          
   116                          ; Lx_TILEBASE
   117                          ; -----------------------------------------------------------------------------
   118                          VERA_TILE_WIDTH_8   = $00
   119                          VERA_TILE_WIDTH_16  = $01
   120                          VERA_TILE_HEIGHT_8  = $00
   121                          VERA_TILE_HEIGHT_16 = $02
   122                          
   123                          ; Other Vera addresses
   124                          ; -----------------------------------------------------------------------------
   125                          VERA_PALETTE = $1FA00
   126                          VERA_SPRITES = $1FC00
   127                          
   128                          ; Sprites
   129                          ; -----------------------------------------------------------------------------
   130                          VERA_SPRITE_DISABLED  = $00 << 2
   131                          VERA_SPRITE_BELOW_L0  = $01 << 2
   132                          VERA_SPRITE_BELOW_L1  = $02 << 2
   133                          VERA_SPRITE_ABOVE_L1  = $03 << 2
   134                          VERA_SPRITE_HFLIP     = $01
   135                          VERA_SPRITE_VFLIP     = $02
   136                          VERA_SPRITE_WIDTH_8   = $00 << 4
   137                          VERA_SPRITE_WIDTH_16  = $01 << 4
   138                          VERA_SPRITE_WIDTH_32  = $02 << 4
   139                          VERA_SPRITE_WIDTH_64  = $03 << 4
   140                          VERA_SPRITE_HEIGHT_8  = $00 << 6
   141                          VERA_SPRITE_HEIGHT_16 = $01 << 6
   142                          VERA_SPRITE_HEIGHT_32 = $02 << 6
   143                          VERA_SPRITE_HEIGHT_64 = $03 << 6

; ******** Source: src\snake.asm
    56                          

; ******** Source: src\common\vera\macros.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_MACROS_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; vset: set the address and incrment
    17                          ; -----------------------------------------------------------------------------
    18                          !macro vset .addr, increment {
    19                          	lda #<(.addr >> 16) | increment
    20                          	sta VERA_ADDRx_H
    21                          	lda #<(.addr >> 8)
    22                          	sta VERA_ADDRx_M
    23                          	lda #<(.addr)
    24                          	sta VERA_ADDRx_L
    25                          }
    26                          
    27                          !macro vset .addr {
    28                            +vset .addr, VERA_INCR_1
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; vpush: push vera address from stack
    33                          ; -----------------------------------------------------------------------------
    34                          !macro vpush {
    35                            lda VERA_ADDRx_H
    36                            pha
    37                            lda VERA_ADDRx_M
    38                            pha
    39                            lda VERA_ADDRx_L
    40                            pha
    41                            lda VERA_CTRL
    42                            pha
    43                          }
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; vpop: pop vera address from stack
    47                          ; -----------------------------------------------------------------------------
    48                          !macro vpop {
    49                            pla
    50                            sta VERA_CTRL
    51                            pla
    52                            sta VERA_ADDRx_L
    53                            pla
    54                            sta VERA_ADDRx_M
    55                            pla
    56                            sta VERA_ADDRx_H
    57                          }
    58                          
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; vchannel: set the current vera channel
    62                          ; -----------------------------------------------------------------------------
    63                          !macro vchannel .channel {
    64                            +vreg VERA_CTRL, .channel 
    65                          }
    66                          
    67                          !macro vchannel0 {
    68                            +vchannel $00 
    69                          }
    70                          
    71                          !macro vchannel1 {
    72                            +vchannel $01 
    73                          }
    74                          
    75                          
    76                          ; -----------------------------------------------------------------------------
    77                          ; vReadByte: read a byte from vram
    78                          ; -----------------------------------------------------------------------------
    79                          !macro vReadByte0 .addr {
    80                          	+vset .addr
    81                          	lda VERA_DATA0
    82                          }
    83                          
    84                          !macro vReadByte1 .addr {
    85                          	+vset .addr
    86                          	lda VERA_DATA1
    87                          }
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; vreg16: write an 8-bit value to vram
    91                          ; -----------------------------------------------------------------------------
    92                          !macro vreg register, value {
    93                            lda #value
    94                            sta register
    95                          }
    96                          
    97                          !macro vWriteByte0 value {
    98                            +vreg VERA_DATA0, value
    99                          }
   100                          
   101                          !macro vWriteByte1 value {
   102                            +vreg VERA_DATA1, value
   103                          }
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; vreg16: write a 16-bit value to vram
   107                          ; -----------------------------------------------------------------------------
   108                          !macro vreg16 register, value {
   109                            lda #<value
   110                            sta register
   111                            lda #>value
   112                            sta register
   113                          }
   114                          
   115                          !macro vWriteWord0 value {
   116                            +vreg16 VERA_DATA0, value
   117                          }
   118                          
   119                          !macro vWriteWord1 value {
   120                            +vreg16 VERA_DATA1, value
   121                          }
   122                          
   123                          ; -----------------------------------------------------------------------------
   124                          ; vClear: clear a range of vram (set to zeros)
   125                          ; -----------------------------------------------------------------------------
   126                          ; start:  start address
   127                          ; length: length in bytes to clear
   128                          ; -----------------------------------------------------------------------------
   129                          !macro vClear start, length {
   130                            +vset start
   131                          
   132                            ldx #<length
   133                            ldy #>length
   134                            lda #0
   135                          
   136                          -
   137                            sta VERA_DATA0
   138                            dex
   139                            bne -
   140                            dey
   141                            bne -
   142                          }
   143                          
   144                          ; -----------------------------------------------------------------------------
   145                          ; vLoadRaw:   helper to load a file into vram
   146                          ; -----------------------------------------------------------------------------
   147                          ; filename:   zero-terminated string
   148                          ; vramArress: address to load the raw data
   149                          ; -----------------------------------------------------------------------------
   150                          !macro vLoadRaw filename, vramAddress {
   151                            +vset vramAddress
   152                          
   153                            ldx #<filename
   154                            ldy #>filename
   155                            jsr strLen
   156                          
   157                            jsr loadRaw
   158                          }
   159                          
   160                          ; -----------------------------------------------------------------------------
   161                          ; vLoadRaw:   helper to load an audio file into vram
   162                          ; -----------------------------------------------------------------------------
   163                          ; filename:   zero-terminated string
   164                          ; vramArress: address to load the raw data
   165                          ; -----------------------------------------------------------------------------
   166                          !macro vLoadAudio filename {
   167                          
   168                            ldx #<filename
   169                            ldy #>filename
   170                            jsr strLen
   171                          
   172                            jsr loadRawPCM
   173                          }
   174                          
   175                          
   176                          ; -----------------------------------------------------------------------------
   177                          ; filename:   zero-terminated string
   178                          ; vramArress: address to load the pixel data
   179                          ; palIndex:  0-15 - high nibble of palette address offset
   180                          ; -----------------------------------------------------------------------------
   181                          !macro vLoadPcx filename, vramAddress, palIndex {
   182                          
   183                            !if palIndex > 15 {
   184                              !error "Invalid palette index: ", palIndex, ". Must be between 0 and 15"
   185                            }
   186                            
   187                            +vchannel1
   188                            
   189                            +vset VERA_PALETTE + (palIndex << 5)
   190                            +vchannel0
   191                            +vset vramAddress
   192                          
   193                            ldx #<filename
   194                            ldy #>filename
   195                            jsr strLen
   196                            
   197                            jsr loadPcxFile
   198                          }
   199                          ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    57                          

; ******** Source: src\common\vera\vera.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA helper subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_ASM_ = 1
    15                          
    16                          
    17                          !zone vera {
    18                          
    19                          ; -----------------------------------------------------------------------------
    20                          ; loadRaw: load raw data file into VRAM
    21                          ; -----------------------------------------------------------------------------
    22                          ; xy contains address of filename
    23                          ; vera already configured:
    24                          ;   channel 0 for data
    25                          ; -----------------------------------------------------------------------------
    26                          loadRaw:
    27                          TMP_ADDR = $A000
    28  0942 20bdff               jsr SETNAM
    29                          
    30  0945 a901                 lda #$01
    31  0947 a208                 ldx #$08      ; default to device 8
    32  0949 a001                 ldy #$01      ; $00 means: load to new address
    33  094b 20baff               jsr SETLFS
    34                          
    35  094e a202                 ldx #<(TMP_ADDR + 2)
    36  0950 a0a0                 ldy #>(TMP_ADDR + 2)
    37  0952 a900                 lda #$00      ; $00 means: load to memory (not verify)
    38  0954 20d5ff               jsr LOAD
    39  0957 b026                 bcs .errorRaw    ; if carry set, a load error has happened
    40                          
    41  0959 8606                 stx R2L
    42  095b 8407                 sty R2H
    43                          
    44  095d a900                 lda #<TMP_ADDR
    45  095f 8504                 sta R1L
    46  0961 a9a0                 lda #>TMP_ADDR
    47  0963 8505                 sta R1H
    48                          
    49  0965 a000                 ldy #0
    50                          
    51                          .checkNextByteRaw:
    52  0967 a505                 lda R1H
    53  0969 c507                 cmp R2H
    54  096b d005                 bne +
    55  096d 98                   tya
    56  096e c506                 cmp R2L
    57  0970 f00c                 beq .doneRaw
    58                          +
    59  0972 b104                 lda (R1),y
    60  0974 8d239f               sta VERA_DATA0
    61  0977 c8                   iny
    62  0978 d002                 bne +
    63  097a e605                 inc R1H
    64                          +
    65  097c 80e9                 bra .checkNextByteRaw
    66                          .doneRaw
    67                          
    68  097e 60                   rts
    69                          .errorRaw
    70                          
    71  097f 60                   rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; loadRawPCM: load raw data file into VRAM
    75                          ; -----------------------------------------------------------------------------
    76                          ; xy contains address of filename
    77                          ; vera already configured:
    78                          ;   channel 0 for data
    79                          ; -----------------------------------------------------------------------------
    80                          loadRawPCM:
    81                          TMP_ADDR = $A000
    82  0980 20bdff               jsr SETNAM
    83                          
    84  0983 a901                 lda #$01
    85  0985 a208                 ldx #$08      ; default to device 8
    86  0987 a001                 ldy #$01      ; $00 means: load to new address
    87  0989 20baff               jsr SETLFS
    88                          
    89  098c a202                 ldx #<(TMP_ADDR + 2)
    90  098e a0a0                 ldy #>(TMP_ADDR + 2)
    91  0990 a900                 lda #$00      ; $00 means: load to memory (not verify)
    92  0992 20d5ff               jsr LOAD
    93  0995 b026                 bcs .errorPcm    ; if carry set, a load error has happened
    94                          
    95  0997 8606                 stx R2L
    96  0999 8407                 sty R2H
    97                          
    98  099b a900                 lda #<TMP_ADDR
    99  099d 8504                 sta R1L
   100  099f a9a0                 lda #>TMP_ADDR
   101  09a1 8505                 sta R1H
   102                          
   103  09a3 a000                 ldy #0
   104                          
   105                          .checkNextByte:
   106  09a5 a505                 lda R1H
   107  09a7 c507                 cmp R2H
   108  09a9 d005                 bne +
   109  09ab 98                   tya
   110  09ac c506                 cmp R2L
   111  09ae f00c                 beq .donePcm
   112                          +
   113  09b0 b104                 lda (R1),y
   114  09b2 8d3d9f               sta $9F3D
   115  09b5 c8                   iny
   116  09b6 d002                 bne +
   117  09b8 e605                 inc R1H
   118                          +
   119  09ba 80e9                 bra .checkNextByte
   120                          .donePcm
   121                          
   122  09bc 60                   rts
   123                          .errorPcm
   124                          
   125  09bd 60                   rts
   126                          

; ******** Source: src\snake.asm
    58                          

; ******** Source: src\common\vera\pcx.asm
     1                          ; Commander X16
     2                          ;
     3                          ; PCX file loader for Vera
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_PCX_ = 1
    14                          
    15                          !zone pcxFile {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; pcx constants
    19                          ; -----------------------------------------------------------------------------
    20                          
    21                          PCX_NUM_COLORS      = 16
    22                          PCX_PALETTE_OFFSET  = $10
    23                          PCX_PIXELS_OFFSET   = $80
    24                          PCX_REPEAT_FLAG     = $c0
    25                          PCX_REPEAT_CNT_MASK = $3f
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; loadPcxFile: load and decode a PCX file into VRAM
    29                          ; -----------------------------------------------------------------------------
    30                          ; xy contains address of filename
    31                          ; vera already configured:
    32                          ;   channel 0 for pixel data
    33                          ;   channel 1 for palette
    34                          ; -----------------------------------------------------------------------------
    35                          loadPcxFile:
    36                          TMP_ADDR = $A000
    37  09be 20bdff               jsr SETNAM
    38                          
    39  09c1 a901                 lda #$01
    40  09c3 a6ba                 ldx $BA       ; last used device number
    41  09c5 d002                 bne +
    42  09c7 a208                 ldx #$08      ; default to device 8
    43  09c9 a000               + ldy #$00      ; $00 means: load to new address
    44  09cb 20baff               jsr SETLFS
    45                          
    46  09ce a202                 ldx #<(TMP_ADDR + 2)
    47  09d0 a0a0                 ldy #>(TMP_ADDR + 2)
    48  09d2 a900                 lda #$00      ; $00 means: load to memory (not verify)
    49  09d4 20d5ff               jsr LOAD
    50  09d7 9002                 bcc .loadedOk ; if carry set, a load error has happened
    51                          
    52  09d9 00                   brk
    53                            ; load error?
    54  09da 60                   rts
    55                          
    56                          ; if we get this far, the file has loaded to TMP_ADDR
    57                          ; and x/y contains the address of the last byte read
    58                          .loadedOk:
    59                          
    60                            ; store pointer to the last byte
    61  09db 8606                 stx R2L
    62  09dd 8407                 sty R2H
    63                          
    64  09df a010                 ldy #PCX_PALETTE_OFFSET
    65  09e1 a210                 ldx #PCX_NUM_COLORS
    66                          
    67                          .nextColor:
    68  09e3 b900a0               lda TMP_ADDR, Y   ; load red, reduce to 4 bits and store in R0L
    69  09e6 4a                   lsr
    70  09e7 4a                   lsr
    71  09e8 4a                   lsr
    72  09e9 4a                   lsr
    73  09ea 8502                 sta R0L
    74  09ec c8                   iny
    75  09ed b900a0               lda TMP_ADDR, Y   ; load green, use high 4 bits and store in R0H
    76  09f0 29f0                 and #$f0
    77  09f2 8503                 sta R0H
    78  09f4 c8                   iny
    79  09f5 b900a0               lda TMP_ADDR, Y    ; load blue, reduce to 4 bits and combine with green
    80  09f8 4a                   lsr
    81  09f9 4a                   lsr
    82  09fa 4a                   lsr
    83  09fb 4a                   lsr
    84  09fc 0503                 ora R0H
    85  09fe 8d249f               sta VERA_DATA1   ; store GB byte in vram
    86  0a01 a502                 lda R0L
    87  0a03 8d249f               sta VERA_DATA1   ; store 0R byte in vram
    88  0a06 c8                   iny
    89  0a07 ca                   dex
    90  0a08 d0d9                 bne .nextColor
    91                            
    92  0a0a a900                 lda #<TMP_ADDR
    93  0a0c 8504                 sta R1L
    94  0a0e a9a0                 lda #>TMP_ADDR
    95  0a10 8505                 sta R1H
    96  0a12 a080                 ldy #PCX_PIXELS_OFFSET
    97                            
    98                          .checkNextPixel:
    99  0a14 a505                 lda R1H
   100  0a16 c507                 cmp R2H
   101  0a18 d005                 bne +
   102  0a1a 98                   tya
   103  0a1b c506                 cmp R2L
   104  0a1d f01f                 beq .done
   105                          
   106  0a1f a201               + ldx #1
   107  0a21 b104                 lda (R1),Y
   108  0a23 c9c0                 cmp #PCX_REPEAT_FLAG
   109  0a25 900a                 bcc .noSequence  ; if is >= c0 (high 2 bits are set), then we're a sequence
   110                          
   111                            ; is a sequence, so get the value and count
   112  0a27 293f                 and #PCX_REPEAT_CNT_MASK
   113  0a29 aa                   tax         ; store count in X
   114  0a2a c8                   iny
   115  0a2b d002                 bne +
   116  0a2d e605                 inc R1H
   117                          +
   118  0a2f b104                 lda (R1),Y
   119                           
   120                            ; not a sequence
   121                          .noSequence:
   122  0a31 8d239f               sta VERA_DATA0
   123  0a34 ca                   dex
   124  0a35 d0fa                 bne .noSequence
   125  0a37 c8                   iny
   126  0a38 d0da                 bne .checkNextPixel
   127  0a3a e605                 inc R1H
   128  0a3c 80d6                 bra .checkNextPixel
   129                          
   130                          .done
   131                          
   132  0a3e a901                 lda #$01
   133  0a40 20c3ff               jsr CLOSE
   134                          
   135  0a43 60                   rts
   136                          ; -----------------------------------------------------------------------------
   137                          

; ******** Source: src\snake.asm
    59                          

; ******** Source: src\common\vera\text.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Raster text subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_VERA_TEXT_ASM_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; outputText: output a raster string to a vera bitmap
    17                          ; -----------------------------------------------------------------------------
    18                          ; vera:
    19                          ;   addr0 set to output location
    20                          ;   addr1 set to font location
    21                          ; inputs:
    22                          ;   X: string address LSB
    23                          ;   Y: string address MSB
    24                          ; -----------------------------------------------------------------------------
    25                          outputText:
    26  0a44 8e640a               stx .getChar + 1
    27  0a47 8c650a               sty .getChar + 2
    28                          
    29  0a4a a9008d259f           +vchannel0
    30  0a4f ad209f               lda VERA_ADDRx_L
    31  0a52 8502                 sta R0L
    32  0a54 ad219f               lda VERA_ADDRx_M
    33  0a57 8503                 sta R0H
    34                          
    35  0a59 a9018d259f           +vchannel1
    36  0a5e ad219f               lda VERA_ADDRx_M
    37  0a61 8505                 sta R1H
    38                          
    39                          .getChar
    40  0a63 adeeee               lda SELF_MODIFY_ADDR
    41  0a66 f04c                 beq .done
    42  0a68 38                   sec
    43  0a69 e920                 sbc #32
    44  0a6b 0a                   asl
    45  0a6c 0a                   asl
    46  0a6d 0a                   asl
    47  0a6e 2a                   rol
    48  0a6f 2a                   rol
    49  0a70 8504                 sta R1L
    50  0a72 2a                   rol
    51  0a73 291f                 and #$1f
    52  0a75 a8                   tay
    53  0a76 a9e0                 lda #$e0
    54  0a78 2504                 and R1L
    55  0a7a 8d209f               sta VERA_ADDRx_L
    56  0a7d 98                   tya
    57  0a7e 18                   clc
    58  0a7f 6505                 adc R1H
    59  0a81 8d219f               sta VERA_ADDRx_M
    60                          
    61  0a84 a9008d259f           +vchannel0
    62                          
    63  0a89 209e0b               jsr outputCharacter
    64                          
    65  0a8c a9008d259f           +vchannel0
    66                          
    67  0a91 a502                 lda R0L
    68  0a93 18                   clc
    69  0a94 6904                 adc #4
    70  0a96 8502                 sta R0L
    71  0a98 8d209f               sta VERA_ADDRx_L
    72  0a9b a503                 lda R0H
    73  0a9d 9001                 bcc +
    74  0a9f 1a                   inc 
    75                          +
    76  0aa0 8503                 sta R0H
    77  0aa2 8d219f               sta VERA_ADDRx_M
    78                          
    79  0aa5 ee640ad003ee650a     +inc16 .getChar + 1
    80                            
    81  0aad a9018d259f           +vchannel1
    82  0ab2 80af                 bra .getChar
    83                          
    84                          .done:
    85  0ab4 a9008d259f           +vchannel0
    86  0ab9 60                   rts
    87                          
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; output3BcdDigits: output 3 bcd digits in raster text
    91                          ; -----------------------------------------------------------------------------
    92                          ; vera:
    93                          ;   addr0 set to output location
    94                          ;   addr1 set to font location
    95                          ; inputs:
    96                          ;   x: first bcd digit
    97                          ;   a: 2x bcd digits
    98                          ; -----------------------------------------------------------------------------
    99                          output3BcdDigits:
   100  0aba 8502                 sta R0
   101  0abc a9008d259f           +vchannel0
   102  0ac1 ad229f48ad219f48...  +vpush
   103  0ad1 8a                   txa
   104  0ad2 20430b               jsr outputBcdChar
   105  0ad5 688d259f688d209f...  +vpop
   106  0ae5 ad239f               lda VERA_DATA0
   107  0ae8 ad239f               lda VERA_DATA0
   108  0aeb ad239f               lda VERA_DATA0
   109  0aee ad239f               lda VERA_DATA0
   110  0af1 ad229f48ad219f48...  +vpush
   111  0b01 a502                 lda R0
   112  0b03 8019                 bra .output2BcdDigitsLateEntry
   113                          
   114                          ; WARNING! FLOWS ON THROUGH HERE
   115                          
   116                          ; -----------------------------------------------------------------------------
   117                          ; output2BcdDigits: output 2 bcd digits in raster text
   118                          ; -----------------------------------------------------------------------------
   119                          ; vera:
   120                          ;   addr0 set to output location
   121                          ;   addr1 set to font location
   122                          ; inputs:
   123                          ;   a: 2x bcd digits
   124                          ; -----------------------------------------------------------------------------
   125                          output2BcdDigits:
   126  0b05 8502                 sta R0
   127  0b07 a9008d259f           +vchannel0 ; save output location
   128  0b0c ad229f48ad219f48...  +vpush
   129  0b1c a502                 lda R0
   130                          .output2BcdDigitsLateEntry:
   131  0b1e 4a                   lsr
   132  0b1f 4a                   lsr
   133  0b20 4a                   lsr
   134  0b21 4a                   lsr
   135  0b22 20430b               jsr outputBcdChar
   136  0b25 688d259f688d209f...  +vpop
   137  0b35 ad239f               lda VERA_DATA0
   138  0b38 ad239f               lda VERA_DATA0
   139  0b3b ad239f               lda VERA_DATA0
   140  0b3e ad239f               lda VERA_DATA0
   141  0b41 a502                 lda R0
   142                          
   143                          
   144                          ; WARNING! FLOWS ON THROUGH HERE
   145                          
   146                          ; -----------------------------------------------------------------------------
   147                          ; outputBcdChar: output a bcd digit in raster text
   148                          ; -----------------------------------------------------------------------------
   149                          ; vera:
   150                          ;   addr0 set to output location
   151                          ;   addr1 set to font location
   152                          ; inputs:
   153                          ;   a: 1x bcd digit in low nibble
   154                          ; -----------------------------------------------------------------------------
   155                          outputBcdChar:
   156  0b43 290f                 and #$0f
   157  0b45 8504                 sta R1L
   158  0b47 a9018d259f           +vchannel1
   159  0b4c ad229f48ad219f48...  +vpush
   160                            
   161  0b5c a504                 lda R1L
   162  0b5e 0910                 ora #$10 ; add 16
   163  0b60 0a                   asl
   164  0b61 0a                   asl
   165  0b62 0a                   asl
   166  0b63 0a                   asl
   167  0b64 2a                   rol
   168  0b65 8504                 sta R1L
   169  0b67 2a                   rol
   170  0b68 291f                 and #$1f
   171  0b6a a8                   tay
   172  0b6b a9e0                 lda #$e0
   173  0b6d 2504                 and R1L
   174  0b6f 8d209f               sta VERA_ADDRx_L
   175  0b72 98                   tya
   176  0b73 18                   clc
   177  0b74 6505                 adc R1H
   178  0b76 8d219f               sta VERA_ADDRx_M
   179                          
   180  0b79 a9008d259f           +vchannel0
   181                          
   182  0b7e 209e0b               jsr outputCharacter
   183                          
   184  0b81 688d259f688d209f...  +vpop
   185                          
   186  0b91 60                   rts
   187                          
   188                          ; -----------------------------------------------------------------------------
   189                          ; setPixelOperationNone: updates instruction in outputCharacter to nop
   190                          ; -----------------------------------------------------------------------------
   191                          setPixelOperationNone:
   192  0b92 a9ea                 lda #$ea ; nop
   193  0b94 8da80b               sta textPixelOperation
   194  0b97 60                   rts
   195                          
   196                          ; -----------------------------------------------------------------------------
   197                          ; setPixelOperationNone: updates instruction in outputCharacter to lsr
   198                          ; -----------------------------------------------------------------------------
   199                          setPixelOperationLSR:
   200  0b98 a90a                 lda #$0a ; lsr
   201  0b9a 8da80b               sta textPixelOperation
   202  0b9d 60                   rts
   203                          
   204                          
   205                          ; -----------------------------------------------------------------------------
   206                          ; outputCharacter: output a raster character
   207                          ; -----------------------------------------------------------------------------
   208                          ; vera:
   209                          ;   addr0 set to output location
   210                          ;   addr1 set to character tile location
   211                          ; -----------------------------------------------------------------------------
   212                          outputCharacter:
   213  0b9e 5a                   phy
   214  0b9f da                   phx
   215  0ba0 48                   pha
   216                          
   217  0ba1 a008                 ldy #8
   218                            
   219                          .nextRow: 
   220  0ba3 a204                 ldx #4 ; 4 bytes per row
   221                          
   222                          .nextCol:
   223  0ba5 ad249f               lda VERA_DATA1
   224                          textPixelOperation:
   225  0ba8 ea                   nop  ; operation which can be substituted
   226  0ba9 8d239f               sta VERA_DATA0
   227                          
   228  0bac ca                   dex
   229  0bad d0f6                 bne .nextCol
   230                          
   231  0baf 18                   clc
   232  0bb0 ad209f               lda VERA_ADDRx_L
   233  0bb3 699c                 adc #160 - 4 ; bytes per row, less our current offset
   234  0bb5 8d209f               sta VERA_ADDRx_L
   235  0bb8 9003                 bcc +
   236  0bba ee219f               inc VERA_ADDRx_M
   237                          +
   238  0bbd 88                   dey
   239  0bbe d0e3                 bne .nextRow
   240                          
   241  0bc0 68                   pla
   242  0bc1 fa                   plx
   243  0bc2 7a                   ply
   244                          

; ******** Source: src\snake.asm
    60  0bc3 60                 

; ******** Source: src\common\vera\vsync.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA Vsync helpers
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_VSYNC_ASM_ = 1
    15                          
    16                          defaultIrqHandler:
    17  0bc4 0000               !word $0000
    18                          
    19                          VSYNC_FLAG = $30
    20                          
    21                          registerVsyncIrq:
    22  0bc6 ad1403                 lda $0314
    23  0bc9 8dc40b                 sta defaultIrqHandler
    24  0bcc ad1503                 lda $0315
    25  0bcf 8dc50b                 sta defaultIrqHandler + 1
    26                          
    27  0bd2 a9dd                   lda #<vSyncIrqhandler
    28  0bd4 8d1403                 sta $0314
    29  0bd7 a90b                   lda #>vSyncIrqhandler + 1
    30  0bd9 8d1503                 sta $0315
    31  0bdc 60                     rts
    32                          
    33                          vSyncIrqhandler:
    34  0bdd ad279f                 lda VERA_ISR
    35  0be0 2901                   and #VERA_IEN_VSYNC
    36  0be2 f002                   beq .irqDone
    37                          
    38                              ; Whatever code your program
    39                              ; wanted to execute...
    40  0be4 6430                   stz VSYNC_FLAG
    41                          
    42                              ; Return to whatever had been interrupted:
    43                          .irqDone:
    44  0be6 6cc40b                 jmp (defaultIrqHandler)

; ******** Source: src\snake.asm
    61                          
    62                          
    63                          

; ******** Source: src\rambank.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; RAM banks
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          ; Central place to keep track of RAM banks used
    13                          
    14                          RAM_BANK_SCRATCH        = 0

; ******** Source: src\snake.asm
    64                          

; ******** Source: src\vram.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; VRAM addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          
    12                          
    13                          ; VERA memory map:
    14                          ; -----------------------------------------------------------------------------
    15                          ;  $0000      (0) -  $09FF   (4095) - (4,096 bytes) UNUSED
    16                          ;  $1A00   (4096) -  $19FF   (8191) - (64 x 32 x 2 = 4,096 bytes) map
    17                          ;  $2000   (8192) -  $3FFF  (16383) - (8,192 bytes) UNUSED
    18                          ;  $4000  (16384) -  $BFFF  (49151) - (16 x 16 x 128 = 32,768 bytes) L0 tiles
    19                          ;  $C000  (49152) - $155FF  (87551) - (320 x 240 / 2 = 38,400 bytes) L1 overlay
    20                          ; $15600  (87552) - $1F9BF (129471) - (41,920 bytes) UNUSED
    21                          ;
    22                          ; $1F9C0 - $1F9FF	PSG registers
    23                          ; $1FA00 - $1FBFF	Palette
    24                          ; $1FC00 - $1FFFF	Sprite attributes
    25                          ;
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; VRAM addresses
    30                          ; -----------------------------------------------------------------------------
    31                          VRADDR_MAP_BASE       = $1000
    32                          VRADDR_TILE_BASE      = $4000
    33                          VRADDR_OVERLAY        = $C000

; ******** Source: src\snake.asm
    65                          

; ******** Source: src\zeropage.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Zero page addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          ; Available locations
    15                          ; https://github.com/commanderx16/x16-docs/blob/master/Commander%20X16%20Programmer%27s%20Reference%20Guide.md#ram-contents
    16                          ;
    17                          ;   $00 - $7F (128 bytes) user zero page   
    18                          ;   $A9 - $FF (87 bytes)  if BASIC or FLOAT functions not used
    19                          ; 
    20                          ; Not available:
    21                          ;   $80 - $A8 (41 bytes)
    22                          
    23                          ; -----------------------------------------------------------------------------
    24                          
    25                          ; $00 - $01 ??
    26                          ; $02 - $21 Virtual registers (R0 -> R15)
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          
    30                          ;
    31                          ; $22 - $2f unused
    32                          ;
    33                          
    34                          ZP_CURRENT_CELL_X        = $30
    35                          ZP_CURRENT_CELL_Y        = $31
    36                          
    37                          ZP_CURRENT_PALETTE       = $32
    38                          
    39                          ZP_CURRENT_DIRECTION     = $33
    40                          
    41                          ZP_HEAD_CELL_X           = $34
    42                          ZP_HEAD_CELL_Y           = $35
    43                          
    44                          ZP_ANIM_INDEX            = $36
    45                          ZP_RANDOM                = $37
    46                          
    47                          ZP_APPLE_CELL_X          = $38
    48                          ZP_APPLE_CELL_Y          = $39
    49                          
    50                          ZP_QUEUE_X_INDEX         = $40
    51                          ZP_QUEUE_X               = $41
    52                          ZP_QUEUE_X_LSB           = ZP_QUEUE_X
    53                          ZP_QUEUE_X_MSB           = ZP_QUEUE_X + 1
    54                          
    55                          ZP_QUEUE_Y_INDEX         = $43
    56                          ZP_QUEUE_Y               = $44
    57                          ZP_QUEUE_Y_LSB           = ZP_QUEUE_Y
    58                          ZP_QUEUE_Y_MSB           = ZP_QUEUE_Y + 1
    59                          
    60                          ZP_QUEUE_D_INDEX         = $46
    61                          ZP_QUEUE_D               = $47
    62                          ZP_QUEUE_D_LSB           = ZP_QUEUE_D
    63                          ZP_QUEUE_D_MSB           = ZP_QUEUE_D + 1
    64                          
    65                          
    66                          ;
    67                          ; $35 - $7f unused
    68                          ;
    69                          
    70                          ; -----------------------------------------------------------------------------
    71                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    72                          ;  \ \ \ \ \ \ \ \ \ \ \ \ $80 - $A8: not available  \ \ \ \ \ \ \ \ \ \ \ \ \
    73                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    74                          ; -----------------------------------------------------------------------------
    75                          
    76                          
    77                          ;
    78                          ; $a9 - $ff unused
    79                          ;

; ******** Source: src\snake.asm
    66                          

; ******** Source: src\display.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Display routines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_DISPLAY_ASM_ = 1
    15                          
    16                          DISPLAY_SIZE_X  = 640
    17                          DISPLAY_SIZE_Y  = 480
    18                          
    19                          DISPLAY_BYTES_PER_ROW = DISPLAY_SIZE_X / 2
    20                          
    21                          BOTTOM_PANEL_SIZE_Y  = 24
    22                          VISIBLE_AREA_X       = DISPLAY_SIZE_X
    23                          VISIBLE_AREA_Y       = DISPLAY_SIZE_Y - BOTTOM_PANEL_SIZE_Y
    24                          VISIBLE_AREA_CX      = VISIBLE_AREA_X / 2
    25                          VISIBLE_AREA_CY      = VISIBLE_AREA_Y / 2
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; disable the display
    29                          ; -----------------------------------------------------------------------------
    30                          disableDisplay:
    31  0be9 a9018d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_OUTPUT_VGA
    32  0bee 60                   rts
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; configure the display
    36                          ; -----------------------------------------------------------------------------
    37                          configDisplay:
    38                          
    39                            ; set up layer 0 to hold our map tiles
    40  0bef a9088d2e9f           +vreg VERA_L0_MAPBASE, VRADDR_MAP_BASE >> 9
    41  0bf4 a9238d2f9f           +vreg VERA_L0_TILEBASE, (VRADDR_TILE_BASE >> 9) | VERA_TILE_WIDTH_16 | VERA_TILE_HEIGHT_16
    42  0bf9 a9128d2d9f           +vreg VERA_L0_CONFIG, VERA_CONFIG_MAP_WIDTH_64 | VERA_CONFIG_MAP_HEIGHT_32 | VERA_CONFIG_4BPP
    43                            ;+vreg VERA_L0_HSCROLL_H, 1
    44                          
    45                            ; layer 1 to hold our hud/ui
    46                            ;+vreg VERA_L1_TILEBASE, (VRADDR_OVERLAY >> 9)
    47                            ;+vreg VERA_L1_CONFIG, VERA_CONFIG_BITMAP_MODE | VERA_CONFIG_4BPP
    48                            ;+vreg VERA_L1_HSCROLL_H, OVERLAY_PAL
    49                          
    50                            ; other display settings
    51                          ;  +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_LAYER1_ENABLED | VERA_VIDEO_OUTPUT_VGA
    52  0bfe a9118d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_OUTPUT_VGA
    53  0c03 a9808d2a9f           +vreg VERA_DC_HSCALE, VERA_SCALE_1x
    54  0c08 a9808d2b9f           +vreg VERA_DC_VSCALE, VERA_SCALE_1x
    55  0c0d a9018d269f           +vreg VERA_IEN, VERA_IEN_VSYNC
    56  0c12 a9018d279f           +vreg VERA_ISR, VERA_IEN_VSYNC
    57                            
    58  0c17 60                   rts
    59                            
    60                            ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    67                          

; ******** Source: src\tiles.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Tile definitions
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          TILE_SIZE         = 16
    15                          HALF_TILE_SIZE    = TILE_SIZE / 2
    16                          TILE_SIZE_BYTES   = 16 * 16 / 2  ; 16 x 16 x 4bpp
    17                          
    18  0c18 736e616b652e7063...snakePcx:   !text "snake.pcx",0
    19  0c22 6170706c652e7063...applePcx:   !text "apple.pcx",0
    20                          
    21                          ; -----------------------------------------------------------------------------
    22                          ; tileset addresses
    23                          ; -----------------------------------------------------------------------------
    24                          SNAKE_ADDR = VRADDR_TILE_BASE
    25                          APPLE_ADDR = SNAKE_ADDR + (16 * 256)
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; palette indexes
    29                          ; -----------------------------------------------------------------------------
    30                          SNAKE_PAL_ODD    = 2
    31                          SNAKE_PAL_EVEN   = 3
    32                          APPLE_PAL_ODD    = 4
    33                          APPLE_PAL_EVEN   = 5
    34                          
    35                          SNAKE_PAL = SNAKE_PAL_ODD
    36                          APPLE_PAL = APPLE_PAL_ODD
    37                          
    38                          ; -----------------------------------------------------------------------------
    39                          ; tile flags
    40                          ; -----------------------------------------------------------------------------
    41                          TILE_FLIP_H = $04
    42                          TILE_FLIP_V = $08
    43                          
    44                          
    45                          !macro ldaTileId tileAddress { lda #(tileAddress - tileTable) >> 3 }
    46                          !macro cmpTileId tileAddress { cmp #(tileAddress - tileTable) >> 3 }
    47                          !macro byteTileId tileAddress { !byte (tileAddress - tileTable) >> 3 }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; load the tiles from disk into vram
    51                          ; -----------------------------------------------------------------------------
    52                          loadTiles:
    53  0c2c a9008d619f           +setRamBank RAM_BANK_SCRATCH
    54  0c31 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_ODD
    55  0c63 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_EVEN
    56  0c95 a9018d259fa9118d...  +vLoadPcx applePcx,  APPLE_ADDR, APPLE_PAL_ODD
    57  0cc7 a9018d259fa9118d...  +vLoadPcx applePcx,  APPLE_ADDR, APPLE_PAL_EVEN
    58                            
    59  0cf9 a9118d229fa9fa8d...  +vset VERA_PALETTE + (SNAKE_PAL_EVEN << 5) + 30
    60  0d08 a9d3                 lda #$d3
    61  0d0a 8d239f               sta VERA_DATA0
    62  0d0d a908                 lda #$08
    63  0d0f 8d239f               sta VERA_DATA0
    64                          
    65  0d12 a9118d229fa9fa8d...  +vset VERA_PALETTE + (APPLE_PAL_EVEN << 5) + 30
    66  0d21 a9d3                 lda #$d3
    67  0d23 8d239f               sta VERA_DATA0
    68  0d26 a908                 lda #$08
    69  0d28 8d239f               sta VERA_DATA0
    70                          
    71  0d2b a9108d229fa9108d...  +vset VRADDR_MAP_BASE
    72                          
    73  0d3a a01f                 ldy #31
    74                          --
    75  0d3c a23f                 ldx #63
    76                          -
    77  0d3e 8630                 stx ZP_CURRENT_CELL_X
    78  0d40 8431                 sty ZP_CURRENT_CELL_Y
    79  0d42 20c70d               jsr setCellVram
    80  0d45 a914                 +ldaTileId tileBlank
    81  0d47 20e60d               jsr outputTile
    82  0d4a ca                   dex
    83  0d4b 10f1                 bpl -
    84  0d4d 88                   dey
    85  0d4e 10ec                 bpl --
    86                          
    87  0d50 6441                 stz ZP_QUEUE_X_LSB
    88  0d52 20b30886408542       +qCreate ZP_QUEUE_X_INDEX, ZP_QUEUE_X_MSB
    89  0d59 6444                 stz ZP_QUEUE_Y_LSB
    90  0d5b 20b30886438545       +qCreate ZP_QUEUE_Y_INDEX, ZP_QUEUE_Y_MSB
    91  0d62 6447                 stz ZP_QUEUE_D_LSB
    92  0d64 20b30886468548       +qCreate ZP_QUEUE_D_INDEX, ZP_QUEUE_D_MSB
    93                          
    94  0d6b a900                 lda #0
    95  0d6d a64020ca08           +qPush ZP_QUEUE_X_INDEX
    96  0d72 1a                   inc
    97  0d73 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    98  0d78 1a                   inc
    99  0d79 a64020ca08           +qPush ZP_QUEUE_X_INDEX
   100  0d7e 1a                   inc
   101  0d7f a64020ca08           +qPush ZP_QUEUE_X_INDEX
   102  0d84 8534                 sta ZP_HEAD_CELL_X
   103                          
   104  0d86 a907                 lda #7
   105  0d88 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   106  0d8d a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   107  0d92 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   108  0d97 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   109  0d9c 8535                 sta ZP_HEAD_CELL_Y
   110                          
   111  0d9e a90f                 lda #DIR_RIGHT << 2 | DIR_RIGHT
   112  0da0 a90f                 +ldaTileId tileBodyRight
   113  0da2 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   114  0da7 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   115  0dac a64620ca08           +qPush ZP_QUEUE_D_INDEX
   116  0db1 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   117                          
   118  0db6 a90d                 lda #13
   119  0db8 8538                 sta ZP_APPLE_CELL_X
   120  0dba a904                 lda #4
   121  0dbc 8539                 sta ZP_APPLE_CELL_Y
   122                          
   123                          
   124  0dbe a903                 lda #DIR_RIGHT
   125  0dc0 8533                 sta ZP_CURRENT_DIRECTION
   126                          
   127  0dc2 a901                 lda #1
   128  0dc4 8536                 sta ZP_ANIM_INDEX
   129                          
   130  0dc6 60                   rts
   131                          
   132                          
   133                          setCellVram:
   134  0dc7 a530                 lda ZP_CURRENT_CELL_X
   135  0dc9 0a                   asl
   136  0dca 0a                   asl
   137  0dcb 8d209f             	sta VERA_ADDRx_L
   138                          
   139  0dce a910               	lda #<(VRADDR_MAP_BASE >> 8)
   140  0dd0 18                   clc
   141  0dd1 6531                 adc ZP_CURRENT_CELL_Y
   142  0dd3 8d219f             	sta VERA_ADDRx_M
   143                          
   144  0dd6 18                   clc
   145  0dd7 6432                 stz ZP_CURRENT_PALETTE
   146  0dd9 a530                 lda ZP_CURRENT_CELL_X
   147  0ddb 6531                 adc ZP_CURRENT_CELL_Y
   148  0ddd 8901                 bit #1
   149  0ddf f004                 beq +
   150  0de1 a910                 lda #16
   151  0de3 8532                 sta ZP_CURRENT_PALETTE
   152                          +
   153                          
   154  0de5 60                   rts
   155                          
   156                          
   157                          
   158                          !macro outputTile startOffset {
   159                            lda startOffset, y
   160                            sta VERA_DATA0  
   161                            lda startOffset + 1, y  
   162                            ora ZP_CURRENT_PALETTE
   163                            sta VERA_DATA0
   164                            lda startOffset + 2, y
   165                            sta VERA_DATA0  
   166                            lda startOffset + 3, y
   167                            ora ZP_CURRENT_PALETTE
   168                            sta VERA_DATA0
   169                            clc
   170                            lda VERA_ADDRx_L
   171                            adc #124
   172                            sta VERA_ADDRx_L
   173                            lda startOffset + 4, y
   174                            sta VERA_DATA0  
   175                            lda startOffset + 5, y
   176                            ora ZP_CURRENT_PALETTE
   177                            sta VERA_DATA0
   178                            lda startOffset + 6, y
   179                            sta VERA_DATA0  
   180                            lda startOffset + 7, y
   181                            ora ZP_CURRENT_PALETTE
   182                            sta VERA_DATA0
   183                          }
   184                          
   185                          
   186                          DIR_UP    = $0
   187                          DIR_LEFT  = $1
   188                          DIR_DOWN  = $2
   189                          DIR_RIGHT = $3
   190                          
   191                          
   192                          ; -----------------------------------------------------------------------------
   193                          ; outputTile
   194                          ; -----------------------------------------------------------------------------
   195                          ; Inputs:
   196                          ;  a: tileId
   197                          ;
   198                          ; Prerequisites:
   199                          ;  VERA address already set
   200                          ; -----------------------------------------------------------------------------
   201                          outputTile:
   202  0de6 5a                   phy
   203  0de7 0a                   asl ; 2x
   204  0de8 0a                   asl ; 4x
   205  0de9 0a                   asl ; 8x
   206  0dea a8                   tay
   207                          
   208  0deb 9043                 bcc .firstHalf
   209                          
   210  0ded b900108d239fb901...  +outputTile tileTable + $100
   211  0e2e 7a                   ply
   212  0e2f 60                   rts
   213                          
   214                          .firstHalf:
   215  0e30 b9000f8d239fb901...  +outputTile tileTable
   216  0e71 7a                   ply
   217  0e72 60                   rts
   218                          ; -----------------------------------------------------------------------------
   219                          
   220                          
   221                          ; -----------------------------------------------------------------------------
   222                          ; tile definitions
   223                          ; -----------------------------------------------------------------------------
   224                          ; two bytes per tile in the VERA tile format:
   225                          ;
   226                          ; Offset	Bit 7	Bit 6	Bit 5	Bit 4	Bit 3	Bit 2	Bit 1	Bit 0
   227                          ; 0	        [ Tile index (7:0)                                            ]
   228                          ; 1	        [ Palette offset              ][V-flip][H-flip][Tile index 9:8]
   229                          ;
   230                          ; -----------------------------------------------------------------------------
   231                          !macro tileDef index, tilesetAddr, tileOffset, tilePalette, tileFlags {
   232                              
   233                              .tilesetOffset = (tilesetAddr - VRADDR_TILE_BASE) / TILE_SIZE_BYTES
   234                          
   235                              ; tile offset
   236                              .tileOffset    = .tilesetOffset + tileOffset
   237                          
   238                              ; tile index (7:0)
   239                              !byte .tileOffset & $ff
   240                          
   241                              ; palette offset (7:4), flags, tile offset (9:8)
   242                              !byte (tilePalette << 4) | tileFlags | (.tileOffset >> 8)
   243                          }
   244                          
   245  0e73 eaeaeaeaeaeaeaea...!align 255,0
   246                          tileTable:
   247  0f00 0220               tileBodyUp:       +tileDef    0, SNAKE_ADDR, 2,  SNAKE_PAL, 0
   248  0f02 1220                                 +tileDef    0, SNAKE_ADDR, 18, SNAKE_PAL, 0
   249  0f04 0220                                 +tileDef    0, SNAKE_ADDR, 2,  SNAKE_PAL, 0                  
   250  0f06 1220                                 +tileDef    0, SNAKE_ADDR, 18, SNAKE_PAL, 0                  
   251  0f08 1b2c               tileBodyUpLeft:   +tileDef    1, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   252  0f0a 0b2c                                 +tileDef    1, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   253  0f0c 1a2c                                 +tileDef    1, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   254  0f0e 0a2c                                 +tileDef    1, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   255  0f10 112c               tileHeadDown:     +tileDef    2, SNAKE_ADDR, 17, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   256  0f12 012c                                 +tileDef    2, SNAKE_ADDR, 1,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   257  0f14 102c                                 +tileDef    2, SNAKE_ADDR, 16, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   258  0f16 002c                                 +tileDef    2, SNAKE_ADDR, 0,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   259  0f18 0b28               tileBodyUpRight:  +tileDef    3, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_V
   260  0f1a 1b28                                 +tileDef    3, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_V
   261  0f1c 0a28                                 +tileDef    3, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_V
   262  0f1e 1a28                                 +tileDef    3, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_V
   263  0f20 0928               tileBodyLeftUp:   +tileDef    4, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_V
   264  0f22 1928                                 +tileDef    4, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_V
   265  0f24 0828                                 +tileDef    4, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_V
   266  0f26 1828                                 +tileDef    4, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_V
   267  0f28 132c               tileBodyLeft      +tileDef    5, SNAKE_ADDR, 19, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   268  0f2a 132c                                 +tileDef    5, SNAKE_ADDR, 19, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   269  0f2c 032c                                 +tileDef    5, SNAKE_ADDR, 3,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   270  0f2e 032c                                 +tileDef    5, SNAKE_ADDR, 3,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   271  0f30 0820               tileBodyLeftDown: +tileDef    6, SNAKE_ADDR, 8,  SNAKE_PAL, 0
   272  0f32 1820                                 +tileDef    6, SNAKE_ADDR, 24, SNAKE_PAL, 0
   273  0f34 0920                                 +tileDef    6, SNAKE_ADDR, 9,  SNAKE_PAL, 0
   274  0f36 1920                                 +tileDef    6, SNAKE_ADDR, 25, SNAKE_PAL, 0
   275  0f38 0c20               tileHeadRight     +tileDef    7, SNAKE_ADDR, 12, SNAKE_PAL, 0
   276  0f3a 1c20                                 +tileDef    7, SNAKE_ADDR, 28, SNAKE_PAL, 0
   277  0f3c 0d20                                 +tileDef    7, SNAKE_ADDR, 13, SNAKE_PAL, 0
   278  0f3e 1d20                                 +tileDef    7, SNAKE_ADDR, 29, SNAKE_PAL, 0
   279  0f40 0020               tileHeadUp:       +tileDef    8, SNAKE_ADDR, 0,  SNAKE_PAL, 0
   280  0f42 1020                                 +tileDef    8, SNAKE_ADDR, 16, SNAKE_PAL, 0
   281  0f44 0120                                 +tileDef    8, SNAKE_ADDR, 1,  SNAKE_PAL, 0                  
   282  0f46 1120                                 +tileDef    8, SNAKE_ADDR, 17, SNAKE_PAL, 0                  
   283  0f48 1a24               tileBodyDownLeft: +tileDef    9, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_H
   284  0f4a 0a24                                 +tileDef    9, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_H
   285  0f4c 1b24                                 +tileDef    9, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_H
   286  0f4e 0b24                                 +tileDef    9, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_H
   287  0f50 122c               tileBodyDown:     +tileDef   10, SNAKE_ADDR, 18, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   288  0f52 022c                                 +tileDef   10, SNAKE_ADDR, 2,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   289  0f54 122c                                 +tileDef   10, SNAKE_ADDR, 18, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   290  0f56 022c                                 +tileDef   10, SNAKE_ADDR, 2,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   291  0f58 0a20               tileBodyDownRight:+tileDef   11, SNAKE_ADDR, 10, SNAKE_PAL, 0
   292  0f5a 1a20                                 +tileDef   11, SNAKE_ADDR, 26, SNAKE_PAL, 0
   293  0f5c 0b20                                 +tileDef   11, SNAKE_ADDR, 11, SNAKE_PAL, 0
   294  0f5e 1b20                                 +tileDef   11, SNAKE_ADDR, 27, SNAKE_PAL, 0
   295  0f60 192c               tileBodyRightUp:  +tileDef   12, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   296  0f62 092c                                 +tileDef   12, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   297  0f64 182c                                 +tileDef   12, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   298  0f66 082c                                 +tileDef   12, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   299  0f68 1d2c               tileHeadLeft:     +tileDef   13, SNAKE_ADDR, 29, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   300  0f6a 0d2c                                 +tileDef   13, SNAKE_ADDR, 13, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   301  0f6c 1c2c                                 +tileDef   13, SNAKE_ADDR, 28, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   302  0f6e 0c2c                                 +tileDef   13, SNAKE_ADDR, 12, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   303  0f70 1824               tileBodyRightDown:+tileDef   14, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_H
   304  0f72 0824                                 +tileDef   14, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_H
   305  0f74 1924                                 +tileDef   14, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_H
   306  0f76 0924                                 +tileDef   14, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_H
   307  0f78 0320               tileBodyRight     +tileDef   15, SNAKE_ADDR, 3,  SNAKE_PAL, 0
   308  0f7a 0320                                 +tileDef   15, SNAKE_ADDR, 3,  SNAKE_PAL, 0
   309  0f7c 1320                                 +tileDef   15, SNAKE_ADDR, 19, SNAKE_PAL, 0
   310  0f7e 1320                                 +tileDef   15, SNAKE_ADDR, 19, SNAKE_PAL, 0
   311  0f80 0420               tileTailUp:       +tileDef   16, SNAKE_ADDR, 4,  SNAKE_PAL, 0
   312  0f82 1420                                 +tileDef   16, SNAKE_ADDR, 20, SNAKE_PAL, 0
   313  0f84 0520                                 +tileDef   16, SNAKE_ADDR, 5,  SNAKE_PAL, 0                  
   314  0f86 1520                                 +tileDef   16, SNAKE_ADDR, 21, SNAKE_PAL, 0                  
   315  0f88 1f2c               tileTailLeft      +tileDef   17, SNAKE_ADDR, 31, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   316  0f8a 0f2c                                 +tileDef   17, SNAKE_ADDR, 15, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   317  0f8c 1e2c                                 +tileDef   17, SNAKE_ADDR, 30, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   318  0f8e 0e2c                                 +tileDef   17, SNAKE_ADDR, 14, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   319  0f90 152c               tileTailDown:     +tileDef   18, SNAKE_ADDR, 21, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   320  0f92 052c                                 +tileDef   18, SNAKE_ADDR, 5,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   321  0f94 142c                                 +tileDef   18, SNAKE_ADDR, 20, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   322  0f96 042c                                 +tileDef   18, SNAKE_ADDR, 4,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   323  0f98 0e20               tileTailRight:    +tileDef   19, SNAKE_ADDR, 14, SNAKE_PAL, 0
   324  0f9a 1e20                                 +tileDef   19, SNAKE_ADDR, 30, SNAKE_PAL, 0
   325  0f9c 0f20                                 +tileDef   19, SNAKE_ADDR, 15, SNAKE_PAL, 0
   326  0f9e 1f20                                 +tileDef   19, SNAKE_ADDR, 31, SNAKE_PAL, 0
   327  0fa0 0620               tileBlank:        +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0
   328  0fa2 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0
   329  0fa4 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0                  
   330  0fa6 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0                  
   331  0fa8 2040               tileApple:        +tileDef   21, APPLE_ADDR, 0,  APPLE_PAL, 0
   332  0faa 2240                                 +tileDef   21, APPLE_ADDR, 2,  APPLE_PAL, 0
   333  0fac 2140                                 +tileDef   21, APPLE_ADDR, 1,  APPLE_PAL, 0                  
   334  0fae 2340                                 +tileDef   21, APPLE_ADDR, 3,  APPLE_PAL, 0                  

; ******** Source: src\snake.asm
    68                          

; ******** Source: src\gameloop.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Game loop
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_GAMELOOP_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; loop to wait for vsync
    19                          ; -----------------------------------------------------------------------------
    20                          waitForVsync:
    21  0fb0 cb                   !byte $CB  ; WAI instruction
    22  0fb1 a530                 lda VSYNC_FLAG
    23  0fb3 d0fb                 bne waitForVsync
    24                          
    25                            ; flow on through to the.... 
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; main game loop
    29                          ; -----------------------------------------------------------------------------
    30                          gameLoop:
    31                          
    32  0fb5 c636                 dec ZP_ANIM_INDEX
    33  0fb7 d003                 bne +
    34  0fb9 20e810               jsr updateFrame
    35                          +
    36  0fbc 2056ff               jsr JOYSTICK_GET
    37  0fbf 6537                 adc ZP_RANDOM
    38  0fc1 8537                 sta ZP_RANDOM
    39                          
    40  0fc3 a901                 lda #1
    41  0fc5 8530                 sta VSYNC_FLAG
    42                          
    43  0fc7 80e7               	bra waitForVsync
    44                          
    45                          doInput:
    46                           
    47  0fc9 2056ff               jsr JOYSTICK_GET
    48  0fcc 8908                 bit #JOY_UP
    49  0fce d032                 bne .testDown
    50                          
    51  0fd0 a533                 lda ZP_CURRENT_DIRECTION
    52  0fd2 2903                 and #3
    53  0fd4 c902                 cmp #DIR_DOWN 
    54  0fd6 f02a                 beq .testDown
    55  0fd8 0a                   asl
    56  0fd9 0a                   asl
    57  0fda 0900                 ora #DIR_UP
    58  0fdc 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
    59  0fe6 9147                 sta (ZP_QUEUE_D), y
    60  0fe8 a900                 lda #DIR_UP << 2 | DIR_UP
    61  0fea 8533                 sta ZP_CURRENT_DIRECTION
    62  0fec a64620ca08           +qPush ZP_QUEUE_D_INDEX
    63                          
    64  0ff1 a534                 lda ZP_HEAD_CELL_X
    65  0ff3 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    66                          
    67  0ff8 c635                 dec ZP_HEAD_CELL_Y
    68  0ffa a535                 lda ZP_HEAD_CELL_Y
    69  0ffc a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    70                          
    71  1001 60                   rts
    72                          .testDown:
    73  1002 8904                 bit #JOY_DOWN
    74  1004 d032                 bne .testRight
    75                          
    76  1006 a533                 lda ZP_CURRENT_DIRECTION
    77  1008 2903                 and #3
    78  100a c900                 cmp #DIR_UP
    79  100c f02a                 beq .testRight
    80  100e 0a                   asl
    81  100f 0a                   asl
    82  1010 0902                 ora #DIR_DOWN
    83  1012 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
    84  101c 9147                 sta (ZP_QUEUE_D), y
    85  101e a90a                 lda #DIR_DOWN << 2 | DIR_DOWN
    86  1020 8533                 sta ZP_CURRENT_DIRECTION
    87  1022 a64620ca08           +qPush ZP_QUEUE_D_INDEX
    88                          
    89  1027 a534                 lda ZP_HEAD_CELL_X
    90  1029 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    91                          
    92  102e e635                 inc ZP_HEAD_CELL_Y
    93  1030 a535                 lda ZP_HEAD_CELL_Y
    94  1032 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    95                          
    96  1037 60                   rts
    97                          .testRight:
    98  1038 8901                 bit #JOY_RIGHT
    99  103a d032                 bne .testLeft
   100                          
   101  103c a533                 lda ZP_CURRENT_DIRECTION
   102  103e 2903                 and #3
   103  1040 c901                 cmp #DIR_LEFT
   104  1042 f02a                 beq .testLeft
   105  1044 0a                   asl
   106  1045 0a                   asl
   107  1046 0903                 ora #DIR_RIGHT
   108  1048 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
   109  1052 9147                 sta (ZP_QUEUE_D), y
   110  1054 a90f                 lda #DIR_RIGHT << 2 | DIR_RIGHT
   111  1056 8533                 sta ZP_CURRENT_DIRECTION
   112  1058 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   113                            
   114  105d e634                 inc ZP_HEAD_CELL_X
   115  105f a534                 lda ZP_HEAD_CELL_X
   116  1061 a64020ca08           +qPush ZP_QUEUE_X_INDEX
   117                          
   118  1066 a535                 lda ZP_HEAD_CELL_Y
   119  1068 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   120                          
   121  106d 60                   rts
   122                          .testLeft:
   123  106e 8902                 bit #JOY_LEFT
   124  1070 d032                 bne .doneTests
   125                          
   126  1072 a533                 lda ZP_CURRENT_DIRECTION
   127  1074 2903                 and #3
   128  1076 c903                 cmp #DIR_RIGHT
   129  1078 f02a                 beq .doneTests
   130  107a 0a                   asl
   131  107b 0a                   asl
   132  107c 0901                 ora #DIR_LEFT
   133  107e 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
   134  1088 9147                 sta (ZP_QUEUE_D), y
   135  108a a905                 lda #DIR_LEFT << 2 | DIR_LEFT
   136  108c 8533                 sta ZP_CURRENT_DIRECTION
   137  108e a64620ca08           +qPush ZP_QUEUE_D_INDEX
   138                            
   139  1093 c634                 dec ZP_HEAD_CELL_X
   140  1095 a534                 lda ZP_HEAD_CELL_X
   141  1097 a64020ca08           +qPush ZP_QUEUE_X_INDEX
   142                          
   143  109c a535                 lda ZP_HEAD_CELL_Y
   144  109e a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   145                          
   146  10a3 60                   rts
   147                          .doneTests:
   148                          
   149  10a4 a533                 lda ZP_CURRENT_DIRECTION
   150  10a6 2903                 and #3
   151  10a8 c900                 cmp #DIR_UP
   152  10aa d004                 bne +
   153  10ac c635                 dec ZP_HEAD_CELL_Y
   154  10ae 8018                 bra .doneMove
   155                          +
   156  10b0 c902                 cmp #DIR_DOWN
   157  10b2 d004                 bne +
   158  10b4 e635                 inc ZP_HEAD_CELL_Y
   159  10b6 8010                 bra .doneMove
   160                          +
   161  10b8 c901                 cmp #DIR_LEFT
   162  10ba d004                 bne +
   163  10bc c634                 dec ZP_HEAD_CELL_X
   164  10be 8008                 bra .doneMove
   165                          +
   166  10c0 c903                 cmp #DIR_RIGHT
   167  10c2 d004                 bne +
   168  10c4 e634                 inc ZP_HEAD_CELL_X
   169  10c6 8000                 bra .doneMove
   170                          +
   171                          
   172                          .doneMove:
   173  10c8 a534                 lda ZP_HEAD_CELL_X
   174  10ca a64020ca08           +qPush ZP_QUEUE_X_INDEX
   175                          
   176  10cf a535                 lda ZP_HEAD_CELL_Y
   177  10d1 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   178                          
   179  10d6 a533                 lda ZP_CURRENT_DIRECTION
   180  10d8 2903                 and #3
   181  10da 8533                 sta ZP_CURRENT_DIRECTION
   182  10dc 0a                   asl
   183  10dd 0a                   asl
   184  10de 0533                 ora ZP_CURRENT_DIRECTION
   185  10e0 8533                 sta ZP_CURRENT_DIRECTION
   186  10e2 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   187  10e7 60                   rts
   188                          
   189                          
   190                          updateFrame:
   191                          
   192  10e8 20c90f               jsr doInput
   193                            
   194  10eb a538                 lda ZP_APPLE_CELL_X
   195  10ed 8530                 sta ZP_CURRENT_CELL_X
   196  10ef a539                 lda ZP_APPLE_CELL_Y
   197  10f1 8531                 sta ZP_CURRENT_CELL_Y
   198  10f3 20c70d               jsr setCellVram
   199  10f6 a915                 +ldaTileId tileApple
   200  10f8 20e60d               jsr outputTile
   201                          
   202  10fb a640                 ldx ZP_QUEUE_X_INDEX
   203  10fd 200209               jsr qSize
   204  1100 48                   pha
   205  1101 200d09               jsr qIterate
   206  1104 fa                   plx  ; here, x i size, y is starting offset, a is queue msb
   207                          
   208  1105 b141                 lda (ZP_QUEUE_X), y
   209  1107 8530                 sta ZP_CURRENT_CELL_X
   210  1109 b144                 lda (ZP_QUEUE_Y), y
   211  110b 8531                 sta ZP_CURRENT_CELL_Y
   212  110d 20c70d               jsr setCellVram
   213  1110 a914                 +ldaTileId tileBlank
   214  1112 20e60d               jsr outputTile
   215  1115 c8                   iny
   216  1116 ca                   dex
   217                          
   218  1117 b141                 lda (ZP_QUEUE_X), y
   219  1119 8530                 sta ZP_CURRENT_CELL_X
   220  111b b144                 lda (ZP_QUEUE_Y), y
   221  111d 8531                 sta ZP_CURRENT_CELL_Y
   222  111f 20c70d               jsr setCellVram
   223  1122 b147                 lda (ZP_QUEUE_D), y
   224  1124 2903                 and #$03  ; tail
   225  1126 0910                 ora #$10
   226  1128 20e60d               jsr outputTile
   227  112b c8                   iny
   228  112c ca                   dex
   229                          
   230                          
   231                          --
   232  112d b141                 lda (ZP_QUEUE_X), y
   233  112f 8530                 sta ZP_CURRENT_CELL_X
   234  1131 b144                 lda (ZP_QUEUE_Y), y
   235  1133 8531                 sta ZP_CURRENT_CELL_Y
   236  1135 20c70d               jsr setCellVram
   237  1138 b147                 lda (ZP_QUEUE_D), y
   238  113a e001                 cpx #1   
   239  113c d002                 bne +
   240  113e 4908                 eor #$08  ; head
   241                          +
   242  1140 20e60d               jsr outputTile
   243                          
   244  1143 c8                   iny
   245  1144 ca                   dex
   246  1145 d0e6                 bne --  
   247                          
   248  1147 a534                 lda ZP_HEAD_CELL_X 
   249  1149 c538                 cmp ZP_APPLE_CELL_X
   250  114b d018                 bne .doPop
   251  114d a535                 lda ZP_HEAD_CELL_Y 
   252  114f c539                 cmp ZP_APPLE_CELL_Y
   253  1151 d012                 bne .doPop
   254                          
   255  1153 a538                 lda ZP_APPLE_CELL_X
   256  1155 6537                 adc ZP_RANDOM
   257  1157 290f                 and #15
   258  1159 8538                 sta ZP_APPLE_CELL_X
   259                          
   260  115b a539                 lda ZP_APPLE_CELL_Y
   261  115d 6537                 adc ZP_RANDOM
   262  115f 290e                 and #14
   263  1161 8539                 sta ZP_APPLE_CELL_Y
   264                          
   265                          
   266  1163 800f                 bra .noPop
   267                          
   268                          .doPop:
   269  1165 a64020e308           +qPop ZP_QUEUE_X_INDEX
   270  116a a64320e308           +qPop ZP_QUEUE_Y_INDEX
   271  116f a64620e308           +qPop ZP_QUEUE_D_INDEX
   272                          
   273                          .noPop:
   274  1174 a906                 lda #6
   275  1176 8536                 sta ZP_ANIM_INDEX
   276                          
   277  1178 60                   rts

; ******** Source: src\snake.asm
    69                          
