
; ******** Source: src\snake.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/cx16-snake
     8                          ;
     9                          ;
    10                          
    11                          !cpu 65c02
    12                          

; ******** Source: src\common\bootstrap.asm
     1                          ; Commander X16
     2                          ;
     3                          ; ACME assembler bootstrap for 6502
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          ; standard bootstrap
    14                          ; generate SYS 2064 ($810)
    15                          
    16                          *=$0801			; Assembled code should start at $0801
    17                          
    18                          			; (where BASIC programs start)
    19                          			; The real program starts at $0810 = 2064
    20                                
    21  0801 0c08               !byte $0C,$08		; $080C - pointer to next line of BASIC code
    22  0803 0a00               !byte $0A,$00		; 2-byte line number ($000A = 10)
    23  0805 9e                 !byte $9E		; SYS BASIC token
    24  0806 20                 !byte $20		; [space]
    25  0807 32303634           !text "2064"	; $32="2",$30="0",$36="6",$34="4"
    26                          			; (ASCII encoded nums for dec starting addr)
    27  080b 000000             !byte $00,$00,$00	
    28                          

; ******** Source: src\snake.asm
    13                          

; ******** Source: src\common\kernal\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; CX16 Kernal Constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_KERNAL_CONSTANTS_ASM_ = 1
    13                          
    14                          !cpu 65c02
    15                          
    16                          ; temporary address used where self-modifying code will update an instruction
    17                          SELF_MODIFY_MSB_ADDR = $ee00
    18                          SELF_MODIFY_ADDR     = $eeee
    19                          
    20                          
    21                          CHROUT      = $FFD2	; CHROUT outputs a character (C64 Kernal API)
    22                          CHRIN       = $FFCF		; CHRIN read from default input
    23                          
    24                          SETLFS			= $FFBA
    25                          SETNAM			= $FFBD
    26                          LOAD			  = $FFD5
    27                          OPEN        = $FFC0
    28                          CLOSE       = $FFC3
    29                          
    30                          BANKED_RAM_START    = $A000
    31                          BANKED_RAM_END      = $BFFF
    32                          ROM_BANK            = $9F60
    33                          RAM_BANK            = $9F61
    34                          
    35                          ; have a separate one for sanity checks
    36                          ; so I can find the others I use temporarily
    37                          ; easier
    38                          !macro dbgSanityCheckBreak {
    39                            !ifdef SANITY { !byte $ff }
    40                          }
    41                          
    42                          !macro dbgBreak {
    43                            !ifdef DEBUG { !byte $ff }
    44                          }
    45                          
    46                          !macro setRamBank bank {
    47                            lda #bank
    48                            sta RAM_BANK
    49                          }
    50                          
    51                          !macro setRomBank bank {
    52                            lda #bank
    53                            sta ROM_BANK
    54                          }
    55                          
    56                          !macro ramBankSanityCheck bank {
    57                            !ifdef SANITY {
    58                              phy
    59                              ldy RAM_BANK
    60                              cpy #bank
    61                              beq +
    62                              !byte $ff
    63                          +
    64                              ply
    65                            }
    66                          }
    67                          
    68                          
    69                          ; Joystick constants
    70                          ; ----------------------------------------------------------------------------
    71                          ; subroutines
    72                          
    73                          JOYSTICK_SCAN = $ff53
    74                          
    75                          ; Get joystick state
    76                          ; A = buttons
    77                          ; X = xtended buttons (SNES)
    78                          ; Y = device present ($00) or not ($FF)
    79                          JOYSTICK_GET  = $ff56
    80                          
    81                          ; constants
    82                          JOY_RIGHT  = %00000001
    83                          JOY_LEFT   = %00000010
    84                          JOY_DOWN   = %00000100
    85                          JOY_UP     = %00001000
    86                          JOY_START  = %00010000
    87                          JOY_SELECT = %00100000
    88                          JOY_B      = %01000000
    89                          JOY_A      = %10000000
    90                          
    91                          JOYSTICK_PRESENT     = $00
    92                          JOYSTICK_NOT_PRESENT = $ff
    93                          
    94                          CLOCK_GET_DATE_TIME = $ff50
    95                          
    96                          ; Virtual registers
    97                          ; ----------------------------------------------------------------------------
    98                          R0  = $02
    99                          R0L = R0
   100                          R0H = R0 + 1
   101                          R1  = $04
   102                          R1L = R1
   103                          R1H = R1 + 1
   104                          R2  = $06
   105                          R2L = R2
   106                          R2H = R2 + 1
   107                          R3  = $08
   108                          R3L = R3
   109                          R3H = R3 + 1
   110                          R4  = $0a
   111                          R4L = R4
   112                          R4H = R4 + 1
   113                          R5  = $0c
   114                          R5L = R5
   115                          R5H = R5 + 1
   116                          R6  = $0e
   117                          R6L = R6
   118                          R6H = R6 + 1
   119                          R7  = $10
   120                          R7L = R7
   121                          R7H = R7 + 1
   122                          R8  = $12
   123                          R8L = R8
   124                          R8H = R8 + 1
   125                          R9  = $14
   126                          R9L = R9
   127                          R9H = R9 + 1
   128                          R10  = $16
   129                          R10L = R10
   130                          R10H = R10 + 1
   131                          R11  = $18
   132                          R11L = R11
   133                          R11H = R11 + 1

; ******** Source: src\snake.asm
    14                          
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; constants
    18                          ; -----------------------------------------------------------------------------
    19                          ADDR_QUEUE_HEADERS = $6000 ; 4KB
    20                          
    21                          
    22                          ; -----------------------------------------------------------------------------
    23                          ; program entry
    24                          ; -----------------------------------------------------------------------------
    25                          
    26  0810 78                   sei
    27                          
    28                            ; turn off the display while we're setting things up
    29  0811 20e90b               jsr disableDisplay
    30                          
    31                            ; initialise queues
    32  0814 20af08               jsr qInit
    33                          
    34  0817 20220c               jsr loadTiles
    35                          
    36                            ; set up and enable the display
    37  081a 20ef0b               jsr configDisplay
    38                          
    39                            ; register the vsync interrupt handler
    40  081d 20c60b               jsr registerVsyncIrq
    41                          
    42  0820 58                   cli
    43                          
    44                            ; enter the game loop
    45  0821 4ca80e               jmp waitForVsync
    46                          
    47  0824 60                   rts
    48                          
    49                          

; ******** Source: src\common\util.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Utility subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_UTIL_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; +dec16: decement a 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  addr: address containing LSB of value to decrement
    22                          ; -----------------------------------------------------------------------------
    23                          !macro dec16 addr {
    24                            lda addr
    25                            bne +
    26                            dec addr + 1
    27                          +
    28                            dec addr
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; +inc16: increment a 16-bit value
    33                          ; -----------------------------------------------------------------------------
    34                          ; Inputs:
    35                          ;  addr: address containing LSB of value to increment
    36                          ; -----------------------------------------------------------------------------
    37                          !macro inc16 addr {
    38                            inc addr
    39                            bne +
    40                            inc addr + 1
    41                          +
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; +cmp16: compare two 16-bit values in memory
    46                          ; -----------------------------------------------------------------------------
    47                          ; Inputs:
    48                          ;  left:  address containing LSB of left value to comapre
    49                          ;  right: address containing LSB of right value to comapre
    50                          ; -----------------------------------------------------------------------------
    51                          !macro cmp16 left, right {
    52                            lda left + 1
    53                            cmp right + 1
    54                          	bne +
    55                          	lda left
    56                          	cmp right
    57                          +
    58                          }
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; +cmp16: compare two 16-bit values in memory
    62                          ; -----------------------------------------------------------------------------
    63                          ; Inputs:
    64                          ;  value: immediate value to compare
    65                          ;  x:     msb
    66                          ;  a:     lsb
    67                          ; -----------------------------------------------------------------------------
    68                          !macro cmp16xa value {
    69                            cpx #>value
    70                          	bne +
    71                          	cmp #<value
    72                          +
    73                          }
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; +sub16: subtract 16 bit numbers
    77                          ; -----------------------------------------------------------------------------
    78                          ; Inputs:
    79                          ;  left:  address containing LSB of left value
    80                          ;  right: address containing LSB of right value
    81                          ; Outputs:
    82                          ;  res:   address containing LSB of result
    83                          ; -----------------------------------------------------------------------------
    84                          !macro sub16 left, right, res {
    85                            sec
    86                            lda left
    87                            sbc right
    88                            sta res
    89                            lda left + 1
    90                            sbc right + 1
    91                            sta res + 1
    92                          }
    93                          
    94                          ; -----------------------------------------------------------------------------
    95                          ; +sub16: subtract 16 bit numbers - result in ax registers
    96                          ; -----------------------------------------------------------------------------
    97                          ; Inputs:
    98                          ;  left:  address containing LSB of left value
    99                          ;  right: address containing LSB of right value
   100                          ; Outputs:
   101                          ;  a:     result msb
   102                          ;  x:     result lsb
   103                          ; -----------------------------------------------------------------------------
   104                          !macro sub16 left, right {
   105                            sec
   106                            lda left
   107                            sbc right
   108                            tax
   109                            lda left + 1
   110                            sbc right + 1
   111                          }
   112                          
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   116                          ; -----------------------------------------------------------------------------
   117                          ; Inputs:
   118                          ;  left:  address containing LSB of left value
   119                          ;  right: immediate 8-bit value
   120                          ; Outputs:
   121                          ;  res:   address containing LSB of result
   122                          ; -----------------------------------------------------------------------------
   123                          !macro subImm8From16 left, right, res {
   124                            sec
   125                            lda left
   126                            sbc #right
   127                            sta res
   128                            lda left + 1
   129                            sbc #0
   130                            sta res + 1
   131                          }
   132                          
   133                          ; -----------------------------------------------------------------------------
   134                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   135                          ; -----------------------------------------------------------------------------
   136                          ; Inputs:
   137                          ;  addr:  address containing BCD value
   138                          ; -----------------------------------------------------------------------------
   139                          !macro incBcd addr {
   140                            lda addr
   141                            sed
   142                            clc
   143                            adc #1
   144                            cld
   145                            sta addr
   146                          }
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;  addr:  address containing BCD value
   153                          ; -----------------------------------------------------------------------------
   154                          !macro decBcd addr {
   155                            lda addr
   156                            sed
   157                            sec
   158                            sbc #1
   159                            cld
   160                            sta addr
   161                          }
   162                          
   163                          ; -----------------------------------------------------------------------------
   164                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
   165                          ; -----------------------------------------------------------------------------
   166                          ; Inputs:
   167                          ;   A: value
   168                          ; Outputs:
   169                          ;   BCD value in R8
   170                          ; -----------------------------------------------------------------------------
   171                          bin2bcd8:
   172  0825 8510                 sta R7L
   173  0827 6412                 stz R8L
   174  0829 6413                 stz R8H
   175  082b a208                 ldx #8 
   176  082d f8                   sed    
   177                          .loop:
   178  082e 0610                 asl R7L
   179  0830 a512                 lda R8L
   180  0832 6512                 adc R8L
   181  0834 8512                 sta R8L
   182  0836 a513                 lda R8H
   183  0838 6513                 adc R8H
   184  083a 8513                 sta R8H
   185  083c ca                   dex
   186  083d d0ef                 bne .loop
   187  083f d8                   cld   
   188  0840 60                   rts
   189                          

; ******** Source: src\snake.asm
    50                          

; ******** Source: src\common\file.asm
     1                          ; Commander X16
     2                          ;
     3                          ; File utilities
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_FILE_ASM_ = 1
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; setFile:   set the current file to work with
    18                          ; -----------------------------------------------------------------------------
    19                          ; filename:  address of zero-terminated string
    20                          ; -----------------------------------------------------------------------------
    21                          !macro setFile filename {
    22                            ldx #<filename
    23                            ldy #>filename
    24                            jsr strLen
    25                            jsr SETNAM
    26                          }
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; loadFile:   helper to load a file into ram
    30                          ; -----------------------------------------------------------------------------
    31                          ; filename:  zero-terminated string
    32                          ; ramArress: address to load the raw data
    33                          ; -----------------------------------------------------------------------------
    34                          !macro loadFile filename, address {
    35                          
    36                            !if <address != $00 {
    37                              !error "output address must be aligned to a page boundry"
    38                            }
    39                          
    40                            +setFile filename
    41                          
    42                            lda #>address
    43                          
    44                            jsr loadFile
    45                          }
    46                          
    47                          ; -----------------------------------------------------------------------------
    48                          ; loadFile: load raw data file into ram
    49                          ; -----------------------------------------------------------------------------
    50                          ; Prerequisites:
    51                          ;   SETNAME called 
    52                          ; Inputs:
    53                          ;   A: MSB of output address
    54                          ; -----------------------------------------------------------------------------
    55                          loadFile:
    56  0841 48                   pha
    57  0842 a901                 lda #$01
    58  0844 a208                 ldx #$08      ; default to device 8
    59  0846 a000                 ldy #$00      ; $00 means: load to new address
    60  0848 20baff               jsr SETLFS
    61                          
    62  084b a202                 ldx #$02        ; account for address header 
    63  084d 7a                   ply
    64  084e a900                 lda #$00      ; $00 means: load to memory (not verify)
    65  0850 20d5ff               jsr LOAD
    66  0853 b005                 bcs .errorLoad    ; if carry set, a load error has happened
    67                          
    68  0855 8606                 stx R2L
    69  0857 8407                 sty R2H
    70                          
    71  0859 60                   rts
    72                          .errorLoad
    73  085a 00                   brk
    74  085b 60                   rts

; ******** Source: src\snake.asm
    51                          

; ******** Source: src\common\memory.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Memory subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_MEMORY_ASM_ = 1
    14                          
    15                          !zone memcpy {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; memcpy: Copy a fixed number of bytes from src to dest
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  src: source address
    22                          ;  dst: destination address
    23                          ;  cnt: number of bytes
    24                          ; -----------------------------------------------------------------------------
    25                          !macro memcpy src, dst, cnt {
    26                            lda #<src
    27                            sta R0L
    28                            lda #>src
    29                            sta R0H
    30                          
    31                            lda #<dst
    32                            sta R1L
    33                            lda #>dst
    34                            sta R1H
    35                          
    36                            ldy #<cnt
    37                          
    38                            !if cnt <= 255 {
    39                              jsr memcpySinglePage 
    40                            } else {
    41                              ldx #>cnt
    42                              jsr memcpyMultiPage
    43                            }
    44                          }
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; memcpySinglePage: Copy up to 255 bytes 
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  R0: src address
    51                          ;  R1: dst address
    52                          ;  Y:  bytes
    53                          ; -----------------------------------------------------------------------------
    54                          memcpySinglePage:
    55  085c b102                 lda (R0), Y
    56  085e 9104                 sta (R1), Y
    57  0860 88                   dey
    58  0861 d0f9                 bne memcpySinglePage
    59  0863 60                   rts
    60                          ; -----------------------------------------------------------------------------
    61                          
    62                          
    63                          ; -----------------------------------------------------------------------------
    64                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    65                          ; -----------------------------------------------------------------------------
    66                          ; Inputs:
    67                          ;  R0: src address
    68                          ;  R1: dst address
    69                          ;  X:  bytes MSB
    70                          ;  Y:  bytes LSB
    71                          ; -----------------------------------------------------------------------------
    72                          memcpyMultiPage:
    73  0864 a502                 lda R0L
    74  0866 8d7908               sta .loadIns + 1
    75  0869 a503                 lda R0H
    76  086b 8d7a08               sta .loadIns + 2
    77                          
    78  086e a504                 lda R1L
    79  0870 8d7c08               sta .storeIns + 1
    80  0873 a505                 lda R1H
    81  0875 8d7d08               sta .storeIns + 2
    82                          
    83                          .loadIns:
    84  0878 b9eeee               lda SELF_MODIFY_ADDR, Y
    85                            
    86                          .storeIns:
    87  087b 99eeee               sta SELF_MODIFY_ADDR, Y
    88  087e 88                   dey
    89  087f d0f7                 bne .loadIns
    90  0881 ee7a08               inc .loadIns + 2
    91  0884 ee7d08               inc .storeIns + 2
    92  0887 ca                   dex
    93  0888 d0ee                 bne .loadIns
    94                          
    95  088a 60                   rts
    96                          ; -----------------------------------------------------------------------------
    97                          
    98                          }
    99                          
   100                          
   101                          
   102                          
   103                          !zone mem2reg {
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; mem2regSinglePage: Copy up to 255 bytes from ram to a register stream
   107                          ; -----------------------------------------------------------------------------
   108                          ; Inputs:
   109                          ;  R0: src address
   110                          ;  R1: output register address
   111                          ;  X:  bytes
   112                          ; -----------------------------------------------------------------------------
   113                          !macro mem2regSinglePage outReg {
   114                            ldy #0
   115                          -
   116                            lda (R0), y
   117                            sta outReg
   118                            iny
   119                            dex
   120                            bne -
   121                          }
   122                          ; -----------------------------------------------------------------------------
   123                          
   124                          
   125                          ; -----------------------------------------------------------------------------
   126                          ; mem2reg: Copy a fixed number of bytes from src to dest
   127                          ; -----------------------------------------------------------------------------
   128                          ; Inputs:
   129                          ;  src: source address
   130                          ;  dst: destination register stream address
   131                          ;  cnt: number of bytes
   132                          ; -----------------------------------------------------------------------------
   133                          !macro mem2reg src, dst, cnt {
   134                            lda #<src
   135                            sta R0L
   136                            lda #>src
   137                            sta R0H
   138                          
   139                            ldx #<cnt
   140                          
   141                            !if cnt <= 255 {
   142                              +mem2regSinglePage dst
   143                            } else {
   144                              lda #<dst
   145                              sta mem2regMultiPageStoreIns + 1
   146                              lda #>dst
   147                              sta mem2regMultiPageStoreIns + 2
   148                              ldy #>cnt
   149                              jsr mem2regMultiPage
   150                            }
   151                          }
   152                          
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; mem2regMultiPage: Copy memory to a register stream 
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  R0: src address
   159                          ;  R1: output register address
   160                          ;  X:  bytes LSB
   161                          ;  Y:  bytes MSB
   162                          ; -----------------------------------------------------------------------------
   163                          mem2regMultiPage:
   164  088b a502                 lda R0L
   165  088d 8d9b08               sta .loadIns + 1
   166  0890 a503                 lda R0H
   167  0892 8d9c08               sta .loadIns + 2
   168                          
   169  0895 c8                   iny
   170                            
   171  0896 8a                   txa
   172  0897 d001                 bne +
   173  0899 88                   dey
   174                          +
   175                          
   176                           
   177                          .loadIns:
   178  089a adffff               lda $ffff
   179                            
   180                          mem2regMultiPageStoreIns:
   181  089d 8dffff               sta $ffff
   182  08a0 ee9b08d003ee9c08     +inc16 .loadIns + 1
   183  08a8 ca                   dex
   184  08a9 d0ef                 bne .loadIns
   185  08ab 88                   dey
   186  08ac d0ec                 bne .loadIns
   187                          
   188  08ae 60                   rts
   189                          ; -----------------------------------------------------------------------------
   190                          

; ******** Source: src\snake.asm
    52                          

; ******** Source: src\common\queue.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Queue management
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_QUEUE_ASM_ = 1
    13                          
    14                          !ifndef ADDR_QUEUE_HEADERS  { !error "Must set address for queue system to use: ADDR_QUEUE_HEADERS" }
    15                          
    16                          QUEUE_HEADER_SIZE = 4
    17                          
    18                          ; queue data structure (ADDR_QUEUE_HEADERS)
    19                          ; 0:  count of queues created
    20                          ; 1: unused
    21                          ;   (below repeated for each queue created). page is >ADDR_QUEUE_HEADERS + queue index
    22                          ; 2: head (page offset)
    23                          ; 3: tail (page offset)
    24                          
    25                          QUEUE_OFFSET_HEAD = 0
    26                          QUEUE_OFFSET_TAIL = 1
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; qInit: Initialise queue manager
    30                          ; -----------------------------------------------------------------------------
    31                          qInit:
    32  08af 9c0060               stz ADDR_QUEUE_HEADERS
    33  08b2 60                   rts
    34                          
    35                          ; -----------------------------------------------------------------------------
    36                          ; qInit: create a queue, store its id in address
    37                          ; -----------------------------------------------------------------------------
    38                          !macro qCreate index, addressMsb {
    39                            jsr qCreate
    40                            stx index
    41                            sta addressMsb
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; qPush: push a value to a queue
    46                          ; -----------------------------------------------------------------------------
    47                          !macro qPush index {
    48                            ldx index
    49                            jsr qPush
    50                          }
    51                          
    52                          ; -----------------------------------------------------------------------------
    53                          ; qPop: pop a value from the queue
    54                          ; -----------------------------------------------------------------------------
    55                          !macro qPop index {
    56                            ldx index
    57                            jsr qPop
    58                          }
    59                          
    60                          
    61                          ; -----------------------------------------------------------------------------
    62                          ; qFront: get offset to front of queue
    63                          ; -----------------------------------------------------------------------------
    64                          !macro qFront index {
    65                            ldx index
    66                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
    67                          }
    68                          
    69                          
    70                          ; -----------------------------------------------------------------------------
    71                          ; qBack: get offset to back of queue
    72                          ; -----------------------------------------------------------------------------
    73                          !macro qBack index {
    74                            pha
    75                            lda index
    76                            asl
    77                            tax
    78                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
    79                            dey
    80                            pla
    81                          }
    82                          
    83                          ; -----------------------------------------------------------------------------
    84                          ; qIterate: iterate a queue
    85                          ; -----------------------------------------------------------------------------
    86                          !macro qIterate index {
    87                            ldx index
    88                            jsr qIterate
    89                          }
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; qSize: return size of queue
    93                          ; -----------------------------------------------------------------------------
    94                          !macro qSize index {
    95                            ldx index
    96                            jsr qSize
    97                          }
    98                          
    99                          ; -----------------------------------------------------------------------------
   100                          ; qInit: create a queue
   101                          ; -----------------------------------------------------------------------------
   102                          ; Inputs: none
   103                          ; Returns:
   104                          ;   x: Queue index
   105                          ;   a: Queue MSB
   106                          ; -----------------------------------------------------------------------------
   107                          qCreate:
   108                            ; get the current number of queues
   109                            ; increment it and store it
   110  08b3 ad0060               lda ADDR_QUEUE_HEADERS
   111  08b6 1a                   inc
   112  08b7 aa                   tax
   113  08b8 8e0060               stx ADDR_QUEUE_HEADERS
   114                          
   115                            ; now write the queue header (head and tail will be zero)
   116  08bb 0a                   asl ; double it since there are 2 bytes per queue header
   117  08bc a8                   tay
   118  08bd a900                 lda #0
   119  08bf 990060               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD,y
   120  08c2 990160               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL,y
   121  08c5 98                   tya
   122  08c6 18                   clc
   123  08c7 6960                 adc #>ADDR_QUEUE_HEADERS
   124  08c9 60                   rts
   125                          
   126                          ; -----------------------------------------------------------------------------
   127                          ; qPushBack: push a value onto the back of a queue
   128                          ; -----------------------------------------------------------------------------
   129                          ; inputs:
   130                          ;   A: value to push
   131                          ;   X: queue index
   132                          ; -----------------------------------------------------------------------------
   133                          qPush:
   134                          qPushBack:
   135  08ca 48                   pha
   136  08cb da                   phx
   137                            ; get queue tail
   138                            
   139  08cc 8a                   txa
   140  08cd 0a                   asl
   141  08ce 18                   clc
   142  08cf 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   143  08d1 8de108               sta .ldaOffsetPush + 2
   144  08d4 8a                   txa   ; find the tail, place in y
   145  08d5 0a                   asl
   146  08d6 aa                   tax
   147  08d7 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   148  08da fe0160               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   149  08dd fa                   plx
   150  08de 68                   pla
   151                          .ldaOffsetPush
   152  08df 9900ee               sta SELF_MODIFY_MSB_ADDR, y
   153  08e2 60                   rts
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; qPopFront: pop a value from the from of the front of the queue
   157                          ; -----------------------------------------------------------------------------
   158                          ; inputs:
   159                          ;   X: queue index
   160                          ; returns
   161                          ;   A: value
   162                          ; -----------------------------------------------------------------------------
   163                          qPop:
   164                          qPopFront:
   165  08e3 da                   phx
   166  08e4 8a                   txa
   167  08e5 18                   clc
   168  08e6 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   169  08e8 8df708               sta .ldaOffsetPop + 2
   170  08eb 8a                   txa   ; find the head, place in y
   171  08ec 0a                   asl
   172  08ed aa                   tax
   173  08ee bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   174  08f1 fe0060               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   175  08f4 fa                   plx
   176                          .ldaOffsetPop
   177  08f5 b900ee               lda SELF_MODIFY_MSB_ADDR, y
   178  08f8 60                   rts
   179                          
   180                          ; -----------------------------------------------------------------------------
   181                          ; qBack: get offset to front of queue
   182                          ; -----------------------------------------------------------------------------
   183                          ; inputs:
   184                          ;   X: queue index
   185                          ; returns
   186                          ;   Y: front offset
   187                          ; -----------------------------------------------------------------------------
   188                          qBack:
   189  08f9 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   190  08fc 88                   dey
   191  08fd 60                   rts
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; qFront: get offset to front of queue
   195                          ; -----------------------------------------------------------------------------
   196                          ; inputs:
   197                          ;   X: queue index
   198                          ; returns
   199                          ;   Y: front offset
   200                          ; -----------------------------------------------------------------------------
   201                          qFront:
   202  08fe bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   203  0901 60                   rts
   204                          ; -----------------------------------------------------------------------------
   205                          ; qSize: return the queue size
   206                          ; -----------------------------------------------------------------------------
   207                          ; inputs:
   208                          ;   X: queue index
   209                          ; returns
   210                          ;   A: size
   211                          ; -----------------------------------------------------------------------------
   212                          qSize:
   213  0902 8a                   txa
   214  0903 0a                   asl ; get offset
   215  0904 a8                   tay
   216  0905 b90160               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, y
   217  0908 38                   sec
   218  0909 f90060               sbc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   219  090c 60                   rts
   220                          
   221                          ; -----------------------------------------------------------------------------
   222                          ; qIterate: set up to iterate a queue
   223                          ; -----------------------------------------------------------------------------
   224                          ; inputs:
   225                          ;   X: queue index
   226                          ; returns
   227                          ;   A: MSB byte of queue
   228                          ;   Y: starting offset (head index)
   229                          ; -----------------------------------------------------------------------------
   230                          qIterate:
   231  090d 8a                   txa
   232  090e 0a                   asl ; get offset
   233  090f a8                   tay
   234  0910 b90060               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   235  0913 a8                   tay
   236  0914 8a                   txa
   237  0915 0a                   asl
   238  0916 18                   clc
   239  0917 6960                 adc #>ADDR_QUEUE_HEADERS
   240  0919 60                   rts

; ******** Source: src\snake.asm
    53                          

; ******** Source: src\common\string.asm
     1                          ; Commander X16
     2                          ;
     3                          ; String subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_STRING_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; strLen: Length of a null-terminated string
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  X: address LSB
    22                          ;  Y: address MSB
    23                          ; Outputs:
    24                          ;  A: length
    25                          ; -----------------------------------------------------------------------------
    26                          strLen:
    27                          !zone
    28  091a 5a                   phy
    29  091b 8e2409               stx .loop + 1        ; save string pointer LSB
    30  091e 8c2509               sty .loop + 2        ; save string pointer MSB
    31  0921 a000                 ldy #0               ; starting string index
    32                          
    33                          .loop:
    34  0923 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    35  0926 f003                 beq .end             ; end of string
    36  0928 c8                   iny                  ; next
    37  0929 80f8                 bra .loop
    38                          
    39                          .end:
    40  092b 98                   tya
    41  092c 7a                   ply
    42  092d 60                   rts
    43                          ; -----------------------------------------------------------------------------
    44                          
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; printStr: Print a null-terminated string
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  X: address LSB
    51                          ;  Y: address MSB
    52                          ; -----------------------------------------------------------------------------
    53                          printStr:
    54                          !zone 
    55  092e 8e3709               stx .loop + 1        ; save string pointer LSB
    56  0931 8c3809               sty .loop + 2        ; save string pointer MSB
    57  0934 a000                 ldy #0               ; starting string index
    58                          
    59                          .loop:
    60  0936 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    61  0939 f006                 beq .end             ; end of string
    62                          
    63  093b 20d2ff               jsr CHROUT           ; print character
    64  093e c8                   iny                  ; next
    65  093f 80f5                 bra .loop
    66                          
    67                          .end:
    68  0941 60                   rts
    69                          ; -----------------------------------------------------------------------------
    70                          
    71                          
    72                          !macro printStr stringAddr {
    73                            ldx #<stringAddr
    74                            ldy #>stringAddr
    75                            jsr printStr

; ******** Source: src\snake.asm
    54                          
    55                          

; ******** Source: src\common\vera\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_VERA_CONSTANTS_ = 1
    13                          
    14                          VERA_ADDRx_L      = $9F20
    15                          VERA_ADDRx_M      = $9F21
    16                          VERA_ADDRx_H      = $9F22
    17                          VERA_DATA0        = $9F23
    18                          VERA_DATA1        = $9F24
    19                          VERA_CTRL         = $9F25
    20                          VERA_IEN          = $9F26
    21                          VERA_ISR          = $9F27
    22                          VERA_IRQLINE_L    = $9F28
    23                          VERA_DC_VIDEO     = $9F29
    24                          VERA_DC_HSCALE    = $9F2A
    25                          VERA_DC_VSCALE    = $9F2B
    26                          VERA_DC_BORDER    = $9F2C
    27                          VERA_DC_HSTART    = $9F29
    28                          VERA_DC_HSTOP     = $9F2A
    29                          VERA_DC_VSTART    = $9F2B
    30                          VERA_DC_VSTOP     = $9F2C
    31                          VERA_L0_CONFIG    = $9F2D
    32                          VERA_L0_MAPBASE   = $9F2E
    33                          VERA_L0_TILEBASE  = $9F2F
    34                          VERA_L0_HSCROLL_L = $9F30
    35                          VERA_L0_HSCROLL_H = $9F31
    36                          VERA_L0_VSCROLL_L = $9F32
    37                          VERA_L0_VSCROLL_H = $9F33
    38                          VERA_L1_CONFIG    = $9F34
    39                          VERA_L1_MAPBASE   = $9F35
    40                          VERA_L1_TILEBASE  = $9F36
    41                          VERA_L1_HSCROLL_L = $9F37
    42                          VERA_L1_HSCROLL_H = $9F38
    43                          VERA_L1_VSCROLL_L = $9F39
    44                          VERA_L1_VSCROLL_H = $9F3A
    45                          VERA_AUDIO_CTRL   = $9F3B
    46                          VERA_AUDIO_RATE   = $9F3C
    47                          VERA_AUDIO_DATA   = $9F3D
    48                          VERA_SPI_DATA     = $9F3E
    49                          VERA_SPI_CTRL     = $9F3F
    50                          
    51                          ; ADDRx_H increments
    52                          ; -----------------------------------------------------------------------------
    53                          VERA_INCR_0   = $00
    54                          VERA_INCR_1   = $10
    55                          VERA_INCR_2   = $20
    56                          VERA_INCR_4   = $30
    57                          VERA_INCR_8   = $40
    58                          VERA_INCR_16  = $50
    59                          VERA_INCR_32  = $60
    60                          VERA_INCR_64  = $70
    61                          VERA_INCR_128 = $80
    62                          VERA_INCR_256 = $90
    63                          VERA_INCR_512 = $A0
    64                          VERA_INCR_40  = $B0
    65                          VERA_INCR_80  = $C0
    66                          VERA_INCR_160 = $D0
    67                          VERA_INCR_320 = $E0
    68                          VERA_INCR_640 = $F0
    69                          
    70                          VERA_DECR     = $08
    71                          
    72                          
    73                          ; Interrupts
    74                          ; -----------------------------------------------------------------------------
    75                          VERA_IEN_VSYNC  = $01
    76                          VERA_IEN_LINE   = $02
    77                          VERA_IEN_SPRCOL = $04
    78                          VERA_IEN_AFLOW  = $08
    79                          
    80                          
    81                          ; DC_VIDEO
    82                          ; -----------------------------------------------------------------------------
    83                          VERA_VIDEO_SPRITES_ENABLED  = $40
    84                          VERA_VIDEO_LAYER1_ENABLED   = $20
    85                          VERA_VIDEO_LAYER0_ENABLED   = $10
    86                          VERA_VIDEO_OUTPUT_DISABLED  = $00
    87                          VERA_VIDEO_OUTPUT_VGA       = $01
    88                          VERA_VIDEO_OUTPUT_NTSC      = $02
    89                          VERA_VIDEO_OUTPUT_RGB       = $03
    90                          
    91                          ; DC_SCALE
    92                          ; -----------------------------------------------------------------------------
    93                          VERA_SCALE_1x               = $80
    94                          VERA_SCALE_2x               = $40
    95                          VERA_SCALE_4x               = $20
    96                          
    97                          ; Lx_CONFIG
    98                          ; -----------------------------------------------------------------------------
    99                          VERA_CONFIG_1BPP          = $0
   100                          VERA_CONFIG_2BPP          = $1
   101                          VERA_CONFIG_4BPP          = $2
   102                          VERA_CONFIG_8BPP          = $3
   103                          
   104                          VERA_CONFIG_BITMAP_MODE   = $4
   105                          
   106                          VERA_CONFIG_MAP_WIDTH_32  = ($0 << 4)
   107                          VERA_CONFIG_MAP_WIDTH_64  = ($1 << 4)
   108                          VERA_CONFIG_MAP_WIDTH_128 = ($2 << 4)
   109                          VERA_CONFIG_MAP_WIDTH_256 = ($3 << 4)
   110                          
   111                          VERA_CONFIG_MAP_HEIGHT_32  = ($0 << 6)
   112                          VERA_CONFIG_MAP_HEIGHT_64  = ($1 << 6)
   113                          VERA_CONFIG_MAP_HEIGHT_128 = ($2 << 6)
   114                          VERA_CONFIG_MAP_HEIGHT_256 = ($3 << 6)
   115                          
   116                          ; Lx_TILEBASE
   117                          ; -----------------------------------------------------------------------------
   118                          VERA_TILE_WIDTH_8   = $00
   119                          VERA_TILE_WIDTH_16  = $01
   120                          VERA_TILE_HEIGHT_8  = $00
   121                          VERA_TILE_HEIGHT_16 = $02
   122                          
   123                          ; Other Vera addresses
   124                          ; -----------------------------------------------------------------------------
   125                          VERA_PALETTE = $1FA00
   126                          VERA_SPRITES = $1FC00
   127                          
   128                          ; Sprites
   129                          ; -----------------------------------------------------------------------------
   130                          VERA_SPRITE_DISABLED  = $00 << 2
   131                          VERA_SPRITE_BELOW_L0  = $01 << 2
   132                          VERA_SPRITE_BELOW_L1  = $02 << 2
   133                          VERA_SPRITE_ABOVE_L1  = $03 << 2
   134                          VERA_SPRITE_HFLIP     = $01
   135                          VERA_SPRITE_VFLIP     = $02
   136                          VERA_SPRITE_WIDTH_8   = $00 << 4
   137                          VERA_SPRITE_WIDTH_16  = $01 << 4
   138                          VERA_SPRITE_WIDTH_32  = $02 << 4
   139                          VERA_SPRITE_WIDTH_64  = $03 << 4
   140                          VERA_SPRITE_HEIGHT_8  = $00 << 6
   141                          VERA_SPRITE_HEIGHT_16 = $01 << 6
   142                          VERA_SPRITE_HEIGHT_32 = $02 << 6
   143                          VERA_SPRITE_HEIGHT_64 = $03 << 6

; ******** Source: src\snake.asm
    56                          

; ******** Source: src\common\vera\macros.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_MACROS_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; vset: set the address and incrment
    17                          ; -----------------------------------------------------------------------------
    18                          !macro vset .addr, increment {
    19                          	lda #<(.addr >> 16) | increment
    20                          	sta VERA_ADDRx_H
    21                          	lda #<(.addr >> 8)
    22                          	sta VERA_ADDRx_M
    23                          	lda #<(.addr)
    24                          	sta VERA_ADDRx_L
    25                          }
    26                          
    27                          !macro vset .addr {
    28                            +vset .addr, VERA_INCR_1
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; vpush: push vera address from stack
    33                          ; -----------------------------------------------------------------------------
    34                          !macro vpush {
    35                            lda VERA_ADDRx_H
    36                            pha
    37                            lda VERA_ADDRx_M
    38                            pha
    39                            lda VERA_ADDRx_L
    40                            pha
    41                            lda VERA_CTRL
    42                            pha
    43                          }
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; vpop: pop vera address from stack
    47                          ; -----------------------------------------------------------------------------
    48                          !macro vpop {
    49                            pla
    50                            sta VERA_CTRL
    51                            pla
    52                            sta VERA_ADDRx_L
    53                            pla
    54                            sta VERA_ADDRx_M
    55                            pla
    56                            sta VERA_ADDRx_H
    57                          }
    58                          
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; vchannel: set the current vera channel
    62                          ; -----------------------------------------------------------------------------
    63                          !macro vchannel .channel {
    64                            +vreg VERA_CTRL, .channel 
    65                          }
    66                          
    67                          !macro vchannel0 {
    68                            +vchannel $00 
    69                          }
    70                          
    71                          !macro vchannel1 {
    72                            +vchannel $01 
    73                          }
    74                          
    75                          
    76                          ; -----------------------------------------------------------------------------
    77                          ; vReadByte: read a byte from vram
    78                          ; -----------------------------------------------------------------------------
    79                          !macro vReadByte0 .addr {
    80                          	+vset .addr
    81                          	lda VERA_DATA0
    82                          }
    83                          
    84                          !macro vReadByte1 .addr {
    85                          	+vset .addr
    86                          	lda VERA_DATA1
    87                          }
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; vreg16: write an 8-bit value to vram
    91                          ; -----------------------------------------------------------------------------
    92                          !macro vreg register, value {
    93                            lda #value
    94                            sta register
    95                          }
    96                          
    97                          !macro vWriteByte0 value {
    98                            +vreg VERA_DATA0, value
    99                          }
   100                          
   101                          !macro vWriteByte1 value {
   102                            +vreg VERA_DATA1, value
   103                          }
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; vreg16: write a 16-bit value to vram
   107                          ; -----------------------------------------------------------------------------
   108                          !macro vreg16 register, value {
   109                            lda #<value
   110                            sta register
   111                            lda #>value
   112                            sta register
   113                          }
   114                          
   115                          !macro vWriteWord0 value {
   116                            +vreg16 VERA_DATA0, value
   117                          }
   118                          
   119                          !macro vWriteWord1 value {
   120                            +vreg16 VERA_DATA1, value
   121                          }
   122                          
   123                          ; -----------------------------------------------------------------------------
   124                          ; vClear: clear a range of vram (set to zeros)
   125                          ; -----------------------------------------------------------------------------
   126                          ; start:  start address
   127                          ; length: length in bytes to clear
   128                          ; -----------------------------------------------------------------------------
   129                          !macro vClear start, length {
   130                            +vset start
   131                          
   132                            ldx #<length
   133                            ldy #>length
   134                            lda #0
   135                          
   136                          -
   137                            sta VERA_DATA0
   138                            dex
   139                            bne -
   140                            dey
   141                            bne -
   142                          }
   143                          
   144                          ; -----------------------------------------------------------------------------
   145                          ; vLoadRaw:   helper to load a file into vram
   146                          ; -----------------------------------------------------------------------------
   147                          ; filename:   zero-terminated string
   148                          ; vramArress: address to load the raw data
   149                          ; -----------------------------------------------------------------------------
   150                          !macro vLoadRaw filename, vramAddress {
   151                            +vset vramAddress
   152                          
   153                            ldx #<filename
   154                            ldy #>filename
   155                            jsr strLen
   156                          
   157                            jsr loadRaw
   158                          }
   159                          
   160                          ; -----------------------------------------------------------------------------
   161                          ; vLoadRaw:   helper to load an audio file into vram
   162                          ; -----------------------------------------------------------------------------
   163                          ; filename:   zero-terminated string
   164                          ; vramArress: address to load the raw data
   165                          ; -----------------------------------------------------------------------------
   166                          !macro vLoadAudio filename {
   167                          
   168                            ldx #<filename
   169                            ldy #>filename
   170                            jsr strLen
   171                          
   172                            jsr loadRawPCM
   173                          }
   174                          
   175                          
   176                          ; -----------------------------------------------------------------------------
   177                          ; filename:   zero-terminated string
   178                          ; vramArress: address to load the pixel data
   179                          ; palIndex:  0-15 - high nibble of palette address offset
   180                          ; -----------------------------------------------------------------------------
   181                          !macro vLoadPcx filename, vramAddress, palIndex {
   182                          
   183                            !if palIndex > 15 {
   184                              !error "Invalid palette index: ", palIndex, ". Must be between 0 and 15"
   185                            }
   186                            
   187                            +vchannel1
   188                            
   189                            +vset VERA_PALETTE + (palIndex << 5)
   190                            +vchannel0
   191                            +vset vramAddress
   192                          
   193                            ldx #<filename
   194                            ldy #>filename
   195                            jsr strLen
   196                            
   197                            jsr loadPcxFile
   198                          }
   199                          ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    57                          

; ******** Source: src\common\vera\vera.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA helper subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_ASM_ = 1
    15                          
    16                          
    17                          !zone vera {
    18                          
    19                          ; -----------------------------------------------------------------------------
    20                          ; loadRaw: load raw data file into VRAM
    21                          ; -----------------------------------------------------------------------------
    22                          ; xy contains address of filename
    23                          ; vera already configured:
    24                          ;   channel 0 for data
    25                          ; -----------------------------------------------------------------------------
    26                          loadRaw:
    27                          TMP_ADDR = $A000
    28  0942 20bdff               jsr SETNAM
    29                          
    30  0945 a901                 lda #$01
    31  0947 a208                 ldx #$08      ; default to device 8
    32  0949 a001                 ldy #$01      ; $00 means: load to new address
    33  094b 20baff               jsr SETLFS
    34                          
    35  094e a202                 ldx #<(TMP_ADDR + 2)
    36  0950 a0a0                 ldy #>(TMP_ADDR + 2)
    37  0952 a900                 lda #$00      ; $00 means: load to memory (not verify)
    38  0954 20d5ff               jsr LOAD
    39  0957 b026                 bcs .errorRaw    ; if carry set, a load error has happened
    40                          
    41  0959 8606                 stx R2L
    42  095b 8407                 sty R2H
    43                          
    44  095d a900                 lda #<TMP_ADDR
    45  095f 8504                 sta R1L
    46  0961 a9a0                 lda #>TMP_ADDR
    47  0963 8505                 sta R1H
    48                          
    49  0965 a000                 ldy #0
    50                          
    51                          .checkNextByteRaw:
    52  0967 a505                 lda R1H
    53  0969 c507                 cmp R2H
    54  096b d005                 bne +
    55  096d 98                   tya
    56  096e c506                 cmp R2L
    57  0970 f00c                 beq .doneRaw
    58                          +
    59  0972 b104                 lda (R1),y
    60  0974 8d239f               sta VERA_DATA0
    61  0977 c8                   iny
    62  0978 d002                 bne +
    63  097a e605                 inc R1H
    64                          +
    65  097c 80e9                 bra .checkNextByteRaw
    66                          .doneRaw
    67                          
    68  097e 60                   rts
    69                          .errorRaw
    70                          
    71  097f 60                   rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; loadRawPCM: load raw data file into VRAM
    75                          ; -----------------------------------------------------------------------------
    76                          ; xy contains address of filename
    77                          ; vera already configured:
    78                          ;   channel 0 for data
    79                          ; -----------------------------------------------------------------------------
    80                          loadRawPCM:
    81                          TMP_ADDR = $A000
    82  0980 20bdff               jsr SETNAM
    83                          
    84  0983 a901                 lda #$01
    85  0985 a208                 ldx #$08      ; default to device 8
    86  0987 a001                 ldy #$01      ; $00 means: load to new address
    87  0989 20baff               jsr SETLFS
    88                          
    89  098c a202                 ldx #<(TMP_ADDR + 2)
    90  098e a0a0                 ldy #>(TMP_ADDR + 2)
    91  0990 a900                 lda #$00      ; $00 means: load to memory (not verify)
    92  0992 20d5ff               jsr LOAD
    93  0995 b026                 bcs .errorPcm    ; if carry set, a load error has happened
    94                          
    95  0997 8606                 stx R2L
    96  0999 8407                 sty R2H
    97                          
    98  099b a900                 lda #<TMP_ADDR
    99  099d 8504                 sta R1L
   100  099f a9a0                 lda #>TMP_ADDR
   101  09a1 8505                 sta R1H
   102                          
   103  09a3 a000                 ldy #0
   104                          
   105                          .checkNextByte:
   106  09a5 a505                 lda R1H
   107  09a7 c507                 cmp R2H
   108  09a9 d005                 bne +
   109  09ab 98                   tya
   110  09ac c506                 cmp R2L
   111  09ae f00c                 beq .donePcm
   112                          +
   113  09b0 b104                 lda (R1),y
   114  09b2 8d3d9f               sta $9F3D
   115  09b5 c8                   iny
   116  09b6 d002                 bne +
   117  09b8 e605                 inc R1H
   118                          +
   119  09ba 80e9                 bra .checkNextByte
   120                          .donePcm
   121                          
   122  09bc 60                   rts
   123                          .errorPcm
   124                          
   125  09bd 60                   rts
   126                          

; ******** Source: src\snake.asm
    58                          

; ******** Source: src\common\vera\pcx.asm
     1                          ; Commander X16
     2                          ;
     3                          ; PCX file loader for Vera
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_PCX_ = 1
    14                          
    15                          !zone pcxFile {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; pcx constants
    19                          ; -----------------------------------------------------------------------------
    20                          
    21                          PCX_NUM_COLORS      = 16
    22                          PCX_PALETTE_OFFSET  = $10
    23                          PCX_PIXELS_OFFSET   = $80
    24                          PCX_REPEAT_FLAG     = $c0
    25                          PCX_REPEAT_CNT_MASK = $3f
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; loadPcxFile: load and decode a PCX file into VRAM
    29                          ; -----------------------------------------------------------------------------
    30                          ; xy contains address of filename
    31                          ; vera already configured:
    32                          ;   channel 0 for pixel data
    33                          ;   channel 1 for palette
    34                          ; -----------------------------------------------------------------------------
    35                          loadPcxFile:
    36                          TMP_ADDR = $A000
    37  09be 20bdff               jsr SETNAM
    38                          
    39  09c1 a901                 lda #$01
    40  09c3 a6ba                 ldx $BA       ; last used device number
    41  09c5 d002                 bne +
    42  09c7 a208                 ldx #$08      ; default to device 8
    43  09c9 a000               + ldy #$00      ; $00 means: load to new address
    44  09cb 20baff               jsr SETLFS
    45                          
    46  09ce a202                 ldx #<(TMP_ADDR + 2)
    47  09d0 a0a0                 ldy #>(TMP_ADDR + 2)
    48  09d2 a900                 lda #$00      ; $00 means: load to memory (not verify)
    49  09d4 20d5ff               jsr LOAD
    50  09d7 9002                 bcc .loadedOk ; if carry set, a load error has happened
    51                          
    52  09d9 00                   brk
    53                            ; load error?
    54  09da 60                   rts
    55                          
    56                          ; if we get this far, the file has loaded to TMP_ADDR
    57                          ; and x/y contains the address of the last byte read
    58                          .loadedOk:
    59                          
    60                            ; store pointer to the last byte
    61  09db 8606                 stx R2L
    62  09dd 8407                 sty R2H
    63                          
    64  09df a010                 ldy #PCX_PALETTE_OFFSET
    65  09e1 a210                 ldx #PCX_NUM_COLORS
    66                          
    67                          .nextColor:
    68  09e3 b900a0               lda TMP_ADDR, Y   ; load red, reduce to 4 bits and store in R0L
    69  09e6 4a                   lsr
    70  09e7 4a                   lsr
    71  09e8 4a                   lsr
    72  09e9 4a                   lsr
    73  09ea 8502                 sta R0L
    74  09ec c8                   iny
    75  09ed b900a0               lda TMP_ADDR, Y   ; load green, use high 4 bits and store in R0H
    76  09f0 29f0                 and #$f0
    77  09f2 8503                 sta R0H
    78  09f4 c8                   iny
    79  09f5 b900a0               lda TMP_ADDR, Y    ; load blue, reduce to 4 bits and combine with green
    80  09f8 4a                   lsr
    81  09f9 4a                   lsr
    82  09fa 4a                   lsr
    83  09fb 4a                   lsr
    84  09fc 0503                 ora R0H
    85  09fe 8d249f               sta VERA_DATA1   ; store GB byte in vram
    86  0a01 a502                 lda R0L
    87  0a03 8d249f               sta VERA_DATA1   ; store 0R byte in vram
    88  0a06 c8                   iny
    89  0a07 ca                   dex
    90  0a08 d0d9                 bne .nextColor
    91                            
    92  0a0a a900                 lda #<TMP_ADDR
    93  0a0c 8504                 sta R1L
    94  0a0e a9a0                 lda #>TMP_ADDR
    95  0a10 8505                 sta R1H
    96  0a12 a080                 ldy #PCX_PIXELS_OFFSET
    97                            
    98                          .checkNextPixel:
    99  0a14 a505                 lda R1H
   100  0a16 c507                 cmp R2H
   101  0a18 d005                 bne +
   102  0a1a 98                   tya
   103  0a1b c506                 cmp R2L
   104  0a1d f01f                 beq .done
   105                          
   106  0a1f a201               + ldx #1
   107  0a21 b104                 lda (R1),Y
   108  0a23 c9c0                 cmp #PCX_REPEAT_FLAG
   109  0a25 900a                 bcc .noSequence  ; if is >= c0 (high 2 bits are set), then we're a sequence
   110                          
   111                            ; is a sequence, so get the value and count
   112  0a27 293f                 and #PCX_REPEAT_CNT_MASK
   113  0a29 aa                   tax         ; store count in X
   114  0a2a c8                   iny
   115  0a2b d002                 bne +
   116  0a2d e605                 inc R1H
   117                          +
   118  0a2f b104                 lda (R1),Y
   119                           
   120                            ; not a sequence
   121                          .noSequence:
   122  0a31 8d239f               sta VERA_DATA0
   123  0a34 ca                   dex
   124  0a35 d0fa                 bne .noSequence
   125  0a37 c8                   iny
   126  0a38 d0da                 bne .checkNextPixel
   127  0a3a e605                 inc R1H
   128  0a3c 80d6                 bra .checkNextPixel
   129                          
   130                          .done
   131                          
   132  0a3e a901                 lda #$01
   133  0a40 20c3ff               jsr CLOSE
   134                          
   135  0a43 60                   rts
   136                          ; -----------------------------------------------------------------------------
   137                          

; ******** Source: src\snake.asm
    59                          

; ******** Source: src\common\vera\text.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Raster text subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_VERA_TEXT_ASM_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; outputText: output a raster string to a vera bitmap
    17                          ; -----------------------------------------------------------------------------
    18                          ; vera:
    19                          ;   addr0 set to output location
    20                          ;   addr1 set to font location
    21                          ; inputs:
    22                          ;   X: string address LSB
    23                          ;   Y: string address MSB
    24                          ; -----------------------------------------------------------------------------
    25                          outputText:
    26  0a44 8e640a               stx .getChar + 1
    27  0a47 8c650a               sty .getChar + 2
    28                          
    29  0a4a a9008d259f           +vchannel0
    30  0a4f ad209f               lda VERA_ADDRx_L
    31  0a52 8502                 sta R0L
    32  0a54 ad219f               lda VERA_ADDRx_M
    33  0a57 8503                 sta R0H
    34                          
    35  0a59 a9018d259f           +vchannel1
    36  0a5e ad219f               lda VERA_ADDRx_M
    37  0a61 8505                 sta R1H
    38                          
    39                          .getChar
    40  0a63 adeeee               lda SELF_MODIFY_ADDR
    41  0a66 f04c                 beq .done
    42  0a68 38                   sec
    43  0a69 e920                 sbc #32
    44  0a6b 0a                   asl
    45  0a6c 0a                   asl
    46  0a6d 0a                   asl
    47  0a6e 2a                   rol
    48  0a6f 2a                   rol
    49  0a70 8504                 sta R1L
    50  0a72 2a                   rol
    51  0a73 291f                 and #$1f
    52  0a75 a8                   tay
    53  0a76 a9e0                 lda #$e0
    54  0a78 2504                 and R1L
    55  0a7a 8d209f               sta VERA_ADDRx_L
    56  0a7d 98                   tya
    57  0a7e 18                   clc
    58  0a7f 6505                 adc R1H
    59  0a81 8d219f               sta VERA_ADDRx_M
    60                          
    61  0a84 a9008d259f           +vchannel0
    62                          
    63  0a89 209e0b               jsr outputCharacter
    64                          
    65  0a8c a9008d259f           +vchannel0
    66                          
    67  0a91 a502                 lda R0L
    68  0a93 18                   clc
    69  0a94 6904                 adc #4
    70  0a96 8502                 sta R0L
    71  0a98 8d209f               sta VERA_ADDRx_L
    72  0a9b a503                 lda R0H
    73  0a9d 9001                 bcc +
    74  0a9f 1a                   inc 
    75                          +
    76  0aa0 8503                 sta R0H
    77  0aa2 8d219f               sta VERA_ADDRx_M
    78                          
    79  0aa5 ee640ad003ee650a     +inc16 .getChar + 1
    80                            
    81  0aad a9018d259f           +vchannel1
    82  0ab2 80af                 bra .getChar
    83                          
    84                          .done:
    85  0ab4 a9008d259f           +vchannel0
    86  0ab9 60                   rts
    87                          
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; output3BcdDigits: output 3 bcd digits in raster text
    91                          ; -----------------------------------------------------------------------------
    92                          ; vera:
    93                          ;   addr0 set to output location
    94                          ;   addr1 set to font location
    95                          ; inputs:
    96                          ;   x: first bcd digit
    97                          ;   a: 2x bcd digits
    98                          ; -----------------------------------------------------------------------------
    99                          output3BcdDigits:
   100  0aba 8502                 sta R0
   101  0abc a9008d259f           +vchannel0
   102  0ac1 ad229f48ad219f48...  +vpush
   103  0ad1 8a                   txa
   104  0ad2 20430b               jsr outputBcdChar
   105  0ad5 688d259f688d209f...  +vpop
   106  0ae5 ad239f               lda VERA_DATA0
   107  0ae8 ad239f               lda VERA_DATA0
   108  0aeb ad239f               lda VERA_DATA0
   109  0aee ad239f               lda VERA_DATA0
   110  0af1 ad229f48ad219f48...  +vpush
   111  0b01 a502                 lda R0
   112  0b03 8019                 bra .output2BcdDigitsLateEntry
   113                          
   114                          ; WARNING! FLOWS ON THROUGH HERE
   115                          
   116                          ; -----------------------------------------------------------------------------
   117                          ; output2BcdDigits: output 2 bcd digits in raster text
   118                          ; -----------------------------------------------------------------------------
   119                          ; vera:
   120                          ;   addr0 set to output location
   121                          ;   addr1 set to font location
   122                          ; inputs:
   123                          ;   a: 2x bcd digits
   124                          ; -----------------------------------------------------------------------------
   125                          output2BcdDigits:
   126  0b05 8502                 sta R0
   127  0b07 a9008d259f           +vchannel0 ; save output location
   128  0b0c ad229f48ad219f48...  +vpush
   129  0b1c a502                 lda R0
   130                          .output2BcdDigitsLateEntry:
   131  0b1e 4a                   lsr
   132  0b1f 4a                   lsr
   133  0b20 4a                   lsr
   134  0b21 4a                   lsr
   135  0b22 20430b               jsr outputBcdChar
   136  0b25 688d259f688d209f...  +vpop
   137  0b35 ad239f               lda VERA_DATA0
   138  0b38 ad239f               lda VERA_DATA0
   139  0b3b ad239f               lda VERA_DATA0
   140  0b3e ad239f               lda VERA_DATA0
   141  0b41 a502                 lda R0
   142                          
   143                          
   144                          ; WARNING! FLOWS ON THROUGH HERE
   145                          
   146                          ; -----------------------------------------------------------------------------
   147                          ; outputBcdChar: output a bcd digit in raster text
   148                          ; -----------------------------------------------------------------------------
   149                          ; vera:
   150                          ;   addr0 set to output location
   151                          ;   addr1 set to font location
   152                          ; inputs:
   153                          ;   a: 1x bcd digit in low nibble
   154                          ; -----------------------------------------------------------------------------
   155                          outputBcdChar:
   156  0b43 290f                 and #$0f
   157  0b45 8504                 sta R1L
   158  0b47 a9018d259f           +vchannel1
   159  0b4c ad229f48ad219f48...  +vpush
   160                            
   161  0b5c a504                 lda R1L
   162  0b5e 0910                 ora #$10 ; add 16
   163  0b60 0a                   asl
   164  0b61 0a                   asl
   165  0b62 0a                   asl
   166  0b63 0a                   asl
   167  0b64 2a                   rol
   168  0b65 8504                 sta R1L
   169  0b67 2a                   rol
   170  0b68 291f                 and #$1f
   171  0b6a a8                   tay
   172  0b6b a9e0                 lda #$e0
   173  0b6d 2504                 and R1L
   174  0b6f 8d209f               sta VERA_ADDRx_L
   175  0b72 98                   tya
   176  0b73 18                   clc
   177  0b74 6505                 adc R1H
   178  0b76 8d219f               sta VERA_ADDRx_M
   179                          
   180  0b79 a9008d259f           +vchannel0
   181                          
   182  0b7e 209e0b               jsr outputCharacter
   183                          
   184  0b81 688d259f688d209f...  +vpop
   185                          
   186  0b91 60                   rts
   187                          
   188                          ; -----------------------------------------------------------------------------
   189                          ; setPixelOperationNone: updates instruction in outputCharacter to nop
   190                          ; -----------------------------------------------------------------------------
   191                          setPixelOperationNone:
   192  0b92 a9ea                 lda #$ea ; nop
   193  0b94 8da80b               sta textPixelOperation
   194  0b97 60                   rts
   195                          
   196                          ; -----------------------------------------------------------------------------
   197                          ; setPixelOperationNone: updates instruction in outputCharacter to lsr
   198                          ; -----------------------------------------------------------------------------
   199                          setPixelOperationLSR:
   200  0b98 a90a                 lda #$0a ; lsr
   201  0b9a 8da80b               sta textPixelOperation
   202  0b9d 60                   rts
   203                          
   204                          
   205                          ; -----------------------------------------------------------------------------
   206                          ; outputCharacter: output a raster character
   207                          ; -----------------------------------------------------------------------------
   208                          ; vera:
   209                          ;   addr0 set to output location
   210                          ;   addr1 set to character tile location
   211                          ; -----------------------------------------------------------------------------
   212                          outputCharacter:
   213  0b9e 5a                   phy
   214  0b9f da                   phx
   215  0ba0 48                   pha
   216                          
   217  0ba1 a008                 ldy #8
   218                            
   219                          .nextRow: 
   220  0ba3 a204                 ldx #4 ; 4 bytes per row
   221                          
   222                          .nextCol:
   223  0ba5 ad249f               lda VERA_DATA1
   224                          textPixelOperation:
   225  0ba8 ea                   nop  ; operation which can be substituted
   226  0ba9 8d239f               sta VERA_DATA0
   227                          
   228  0bac ca                   dex
   229  0bad d0f6                 bne .nextCol
   230                          
   231  0baf 18                   clc
   232  0bb0 ad209f               lda VERA_ADDRx_L
   233  0bb3 699c                 adc #160 - 4 ; bytes per row, less our current offset
   234  0bb5 8d209f               sta VERA_ADDRx_L
   235  0bb8 9003                 bcc +
   236  0bba ee219f               inc VERA_ADDRx_M
   237                          +
   238  0bbd 88                   dey
   239  0bbe d0e3                 bne .nextRow
   240                          
   241  0bc0 68                   pla
   242  0bc1 fa                   plx
   243  0bc2 7a                   ply
   244                          

; ******** Source: src\snake.asm
    60  0bc3 60                 

; ******** Source: src\common\vera\vsync.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA Vsync helpers
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_VSYNC_ASM_ = 1
    15                          
    16                          defaultIrqHandler:
    17  0bc4 0000               !word $0000
    18                          
    19                          VSYNC_FLAG = $30
    20                          
    21                          registerVsyncIrq:
    22  0bc6 ad1403                 lda $0314
    23  0bc9 8dc40b                 sta defaultIrqHandler
    24  0bcc ad1503                 lda $0315
    25  0bcf 8dc50b                 sta defaultIrqHandler + 1
    26                          
    27  0bd2 a9dd                   lda #<vSyncIrqhandler
    28  0bd4 8d1403                 sta $0314
    29  0bd7 a90b                   lda #>vSyncIrqhandler + 1
    30  0bd9 8d1503                 sta $0315
    31  0bdc 60                     rts
    32                          
    33                          vSyncIrqhandler:
    34  0bdd ad279f                 lda VERA_ISR
    35  0be0 2901                   and #VERA_IEN_VSYNC
    36  0be2 f002                   beq .irqDone
    37                          
    38                              ; Whatever code your program
    39                              ; wanted to execute...
    40  0be4 6430                   stz VSYNC_FLAG
    41                          
    42                              ; Return to whatever had been interrupted:
    43                          .irqDone:
    44  0be6 6cc40b                 jmp (defaultIrqHandler)

; ******** Source: src\snake.asm
    61                          
    62                          
    63                          

; ******** Source: src\rambank.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; RAM banks
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          ; Central place to keep track of RAM banks used
    13                          
    14                          RAM_BANK_SCRATCH        = 0

; ******** Source: src\snake.asm
    64                          

; ******** Source: src\vram.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; VRAM addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          
    12                          
    13                          ; VERA memory map:
    14                          ; -----------------------------------------------------------------------------
    15                          ;  $0000      (0) -  $09FF   (4095) - (4,096 bytes) UNUSED
    16                          ;  $1A00   (4096) -  $19FF   (8191) - (64 x 32 x 2 = 4,096 bytes) map
    17                          ;  $2000   (8192) -  $3FFF  (16383) - (8,192 bytes) UNUSED
    18                          ;  $4000  (16384) -  $BFFF  (49151) - (16 x 16 x 128 = 32,768 bytes) L0 tiles
    19                          ;  $C000  (49152) - $155FF  (87551) - (320 x 240 / 2 = 38,400 bytes) L1 overlay
    20                          ; $15600  (87552) - $1F9BF (129471) - (41,920 bytes) UNUSED
    21                          ;
    22                          ; $1F9C0 - $1F9FF	PSG registers
    23                          ; $1FA00 - $1FBFF	Palette
    24                          ; $1FC00 - $1FFFF	Sprite attributes
    25                          ;
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; VRAM addresses
    30                          ; -----------------------------------------------------------------------------
    31                          VRADDR_MAP_BASE       = $1000
    32                          VRADDR_TILE_BASE      = $4000
    33                          VRADDR_OVERLAY        = $C000

; ******** Source: src\snake.asm
    65                          

; ******** Source: src\zeropage.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Zero page addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          ; Available locations
    15                          ; https://github.com/commanderx16/x16-docs/blob/master/Commander%20X16%20Programmer%27s%20Reference%20Guide.md#ram-contents
    16                          ;
    17                          ;   $00 - $7F (128 bytes) user zero page   
    18                          ;   $A9 - $FF (87 bytes)  if BASIC or FLOAT functions not used
    19                          ; 
    20                          ; Not available:
    21                          ;   $80 - $A8 (41 bytes)
    22                          
    23                          ; -----------------------------------------------------------------------------
    24                          
    25                          ; $00 - $01 ??
    26                          ; $02 - $21 Virtual registers (R0 -> R15)
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          
    30                          ;
    31                          ; $22 - $2f unused
    32                          ;
    33                          
    34                          ZP_CURRENT_CELL_X        = $30
    35                          ZP_CURRENT_CELL_Y        = $31
    36                          
    37                          ZP_CURRENT_PALETTE       = $32
    38                          
    39                          ZP_CURRENT_DIRECTION     = $33
    40                          
    41                          ZP_HEAD_CELL_X           = $34
    42                          ZP_HEAD_CELL_Y           = $35
    43                          
    44                          ZP_ANIM_INDEX            = $36
    45                          
    46                          ZP_QUEUE_X_INDEX         = $40
    47                          ZP_QUEUE_X               = $41
    48                          ZP_QUEUE_X_LSB           = ZP_QUEUE_X
    49                          ZP_QUEUE_X_MSB           = ZP_QUEUE_X + 1
    50                          
    51                          ZP_QUEUE_Y_INDEX         = $43
    52                          ZP_QUEUE_Y               = $44
    53                          ZP_QUEUE_Y_LSB           = ZP_QUEUE_Y
    54                          ZP_QUEUE_Y_MSB           = ZP_QUEUE_Y + 1
    55                          
    56                          ZP_QUEUE_D_INDEX         = $46
    57                          ZP_QUEUE_D               = $47
    58                          ZP_QUEUE_D_LSB           = ZP_QUEUE_D
    59                          ZP_QUEUE_D_MSB           = ZP_QUEUE_D + 1
    60                          
    61                          
    62                          ;
    63                          ; $35 - $7f unused
    64                          ;
    65                          
    66                          ; -----------------------------------------------------------------------------
    67                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    68                          ;  \ \ \ \ \ \ \ \ \ \ \ \ $80 - $A8: not available  \ \ \ \ \ \ \ \ \ \ \ \ \
    69                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    70                          ; -----------------------------------------------------------------------------
    71                          
    72                          
    73                          ;
    74                          ; $a9 - $ff unused
    75                          ;

; ******** Source: src\snake.asm
    66                          

; ******** Source: src\display.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Display routines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_DISPLAY_ASM_ = 1
    15                          
    16                          DISPLAY_SIZE_X  = 640
    17                          DISPLAY_SIZE_Y  = 480
    18                          
    19                          DISPLAY_BYTES_PER_ROW = DISPLAY_SIZE_X / 2
    20                          
    21                          BOTTOM_PANEL_SIZE_Y  = 24
    22                          VISIBLE_AREA_X       = DISPLAY_SIZE_X
    23                          VISIBLE_AREA_Y       = DISPLAY_SIZE_Y - BOTTOM_PANEL_SIZE_Y
    24                          VISIBLE_AREA_CX      = VISIBLE_AREA_X / 2
    25                          VISIBLE_AREA_CY      = VISIBLE_AREA_Y / 2
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; disable the display
    29                          ; -----------------------------------------------------------------------------
    30                          disableDisplay:
    31  0be9 a9018d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_OUTPUT_VGA
    32  0bee 60                   rts
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; configure the display
    36                          ; -----------------------------------------------------------------------------
    37                          configDisplay:
    38                          
    39                            ; set up layer 0 to hold our map tiles
    40  0bef a9088d2e9f           +vreg VERA_L0_MAPBASE, VRADDR_MAP_BASE >> 9
    41  0bf4 a9238d2f9f           +vreg VERA_L0_TILEBASE, (VRADDR_TILE_BASE >> 9) | VERA_TILE_WIDTH_16 | VERA_TILE_HEIGHT_16
    42  0bf9 a9128d2d9f           +vreg VERA_L0_CONFIG, VERA_CONFIG_MAP_WIDTH_64 | VERA_CONFIG_MAP_HEIGHT_32 | VERA_CONFIG_4BPP
    43                            ;+vreg VERA_L0_HSCROLL_H, 1
    44                          
    45                            ; layer 1 to hold our hud/ui
    46                            ;+vreg VERA_L1_TILEBASE, (VRADDR_OVERLAY >> 9)
    47                            ;+vreg VERA_L1_CONFIG, VERA_CONFIG_BITMAP_MODE | VERA_CONFIG_4BPP
    48                            ;+vreg VERA_L1_HSCROLL_H, OVERLAY_PAL
    49                          
    50                            ; other display settings
    51                          ;  +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_LAYER1_ENABLED | VERA_VIDEO_OUTPUT_VGA
    52  0bfe a9118d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_OUTPUT_VGA
    53  0c03 a9808d2a9f           +vreg VERA_DC_HSCALE, VERA_SCALE_1x
    54  0c08 a9808d2b9f           +vreg VERA_DC_VSCALE, VERA_SCALE_1x
    55  0c0d a9018d269f           +vreg VERA_IEN, VERA_IEN_VSYNC
    56  0c12 a9018d279f           +vreg VERA_ISR, VERA_IEN_VSYNC
    57                            
    58  0c17 60                   rts
    59                            
    60                            ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    67                          

; ******** Source: src\tiles.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Tile definitions
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          TILE_SIZE         = 16
    15                          HALF_TILE_SIZE    = TILE_SIZE / 2
    16                          TILE_SIZE_BYTES   = 16 * 16 / 2  ; 16 x 16 x 4bpp
    17                          
    18  0c18 736e616b652e7063...snakePcx:   !text "snake.pcx",0
    19                          
    20                          ; -----------------------------------------------------------------------------
    21                          ; tileset addresses
    22                          ; -----------------------------------------------------------------------------
    23                          SNAKE_ADDR = VRADDR_TILE_BASE
    24                          
    25                          ; -----------------------------------------------------------------------------
    26                          ; palette indexes
    27                          ; -----------------------------------------------------------------------------
    28                          SNAKE_PAL_ODD    = 2
    29                          SNAKE_PAL_EVEN   = 3
    30                          
    31                          SNAKE_PAL = SNAKE_PAL_ODD
    32                          
    33                          ; -----------------------------------------------------------------------------
    34                          ; tile flags
    35                          ; -----------------------------------------------------------------------------
    36                          TILE_FLIP_H = $04
    37                          TILE_FLIP_V = $08
    38                          
    39                          
    40                          !macro ldaTileId tileAddress { lda #(tileAddress - tileTable) >> 3 }
    41                          !macro cmpTileId tileAddress { cmp #(tileAddress - tileTable) >> 3 }
    42                          !macro byteTileId tileAddress { !byte (tileAddress - tileTable) >> 3 }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; load the tiles from disk into vram
    46                          ; -----------------------------------------------------------------------------
    47                          loadTiles:
    48  0c22 a9008d619f           +setRamBank RAM_BANK_SCRATCH
    49  0c27 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_ODD
    50  0c59 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_EVEN
    51                            
    52  0c8b a9118d229fa9fa8d...  +vset VERA_PALETTE + (SNAKE_PAL_EVEN << 5) + 30
    53  0c9a a9d3                 lda #$d3
    54  0c9c 8d239f               sta VERA_DATA0
    55  0c9f a908                 lda #$08
    56  0ca1 8d239f               sta VERA_DATA0
    57                          
    58  0ca4 a9108d229fa9108d...  +vset VRADDR_MAP_BASE
    59                          
    60  0cb3 a01f                 ldy #31
    61                          --
    62  0cb5 a23f                 ldx #63
    63                          -
    64  0cb7 8630                 stx ZP_CURRENT_CELL_X
    65  0cb9 8431                 sty ZP_CURRENT_CELL_Y
    66  0cbb 20380d               jsr setCellVram
    67  0cbe a914                 +ldaTileId tileBlank
    68  0cc0 20570d               jsr outputTile
    69  0cc3 ca                   dex
    70  0cc4 10f1                 bpl -
    71  0cc6 88                   dey
    72  0cc7 10ec                 bpl --
    73                          
    74  0cc9 6441                 stz ZP_QUEUE_X_LSB
    75  0ccb 20b30886408542       +qCreate ZP_QUEUE_X_INDEX, ZP_QUEUE_X_MSB
    76  0cd2 6444                 stz ZP_QUEUE_Y_LSB
    77  0cd4 20b30886438545       +qCreate ZP_QUEUE_Y_INDEX, ZP_QUEUE_Y_MSB
    78  0cdb 6447                 stz ZP_QUEUE_D_LSB
    79  0cdd 20b30886468548       +qCreate ZP_QUEUE_D_INDEX, ZP_QUEUE_D_MSB
    80                          
    81  0ce4 a900                 lda #0
    82  0ce6 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    83  0ceb 1a                   inc
    84  0cec a64020ca08           +qPush ZP_QUEUE_X_INDEX
    85  0cf1 1a                   inc
    86  0cf2 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    87  0cf7 1a                   inc
    88  0cf8 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    89  0cfd 8534                 sta ZP_HEAD_CELL_X
    90                          
    91  0cff a907                 lda #7
    92  0d01 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    93  0d06 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    94  0d0b a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    95  0d10 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    96  0d15 8535                 sta ZP_HEAD_CELL_Y
    97                          
    98  0d17 a90f                 lda #DIR_RIGHT << 2 | DIR_RIGHT
    99  0d19 a90f                 +ldaTileId tileBodyRight
   100  0d1b a64620ca08           +qPush ZP_QUEUE_D_INDEX
   101  0d20 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   102  0d25 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   103  0d2a a64620ca08           +qPush ZP_QUEUE_D_INDEX
   104                          
   105                          
   106  0d2f a903                 lda #DIR_RIGHT
   107  0d31 8533                 sta ZP_CURRENT_DIRECTION
   108                          
   109  0d33 a901                 lda #1
   110  0d35 8536                 sta ZP_ANIM_INDEX
   111                          
   112  0d37 60                   rts
   113                          
   114                          
   115                          setCellVram:
   116  0d38 a530                 lda ZP_CURRENT_CELL_X
   117  0d3a 0a                   asl
   118  0d3b 0a                   asl
   119  0d3c 8d209f             	sta VERA_ADDRx_L
   120                          
   121  0d3f a910               	lda #<(VRADDR_MAP_BASE >> 8)
   122  0d41 18                   clc
   123  0d42 6531                 adc ZP_CURRENT_CELL_Y
   124  0d44 8d219f             	sta VERA_ADDRx_M
   125                          
   126  0d47 18                   clc
   127  0d48 6432                 stz ZP_CURRENT_PALETTE
   128  0d4a a530                 lda ZP_CURRENT_CELL_X
   129  0d4c 6531                 adc ZP_CURRENT_CELL_Y
   130  0d4e 8901                 bit #1
   131  0d50 f004                 beq +
   132  0d52 a910                 lda #16
   133  0d54 8532                 sta ZP_CURRENT_PALETTE
   134                          +
   135                          
   136  0d56 60                   rts
   137                          
   138                          
   139                          
   140                          !macro outputTile startOffset {
   141                            lda startOffset, y
   142                            sta VERA_DATA0  
   143                            lda startOffset + 1, y  
   144                            ora ZP_CURRENT_PALETTE
   145                            sta VERA_DATA0
   146                            lda startOffset + 2, y
   147                            sta VERA_DATA0  
   148                            lda startOffset + 3, y
   149                            ora ZP_CURRENT_PALETTE
   150                            sta VERA_DATA0
   151                            clc
   152                            lda VERA_ADDRx_L
   153                            adc #124
   154                            sta VERA_ADDRx_L
   155                            lda startOffset + 4, y
   156                            sta VERA_DATA0  
   157                            lda startOffset + 5, y
   158                            ora ZP_CURRENT_PALETTE
   159                            sta VERA_DATA0
   160                            lda startOffset + 6, y
   161                            sta VERA_DATA0  
   162                            lda startOffset + 7, y
   163                            ora ZP_CURRENT_PALETTE
   164                            sta VERA_DATA0
   165                          }
   166                          
   167                          
   168                          DIR_UP    = $0
   169                          DIR_LEFT  = $1
   170                          DIR_DOWN  = $2
   171                          DIR_RIGHT = $3
   172                          
   173                          
   174                          ; -----------------------------------------------------------------------------
   175                          ; outputTile
   176                          ; -----------------------------------------------------------------------------
   177                          ; Inputs:
   178                          ;  a: tileId
   179                          ;
   180                          ; Prerequisites:
   181                          ;  VERA address already set
   182                          ; -----------------------------------------------------------------------------
   183                          outputTile:
   184  0d57 5a                   phy
   185  0d58 0a                   asl ; 2x
   186  0d59 0a                   asl ; 4x
   187  0d5a 0a                   asl ; 8x
   188  0d5b a8                   tay
   189                          
   190  0d5c 9043                 bcc .firstHalf
   191                          
   192  0d5e b9000f8d239fb901...  +outputTile tileTable + $100
   193  0d9f 7a                   ply
   194  0da0 60                   rts
   195                          
   196                          .firstHalf:
   197  0da1 b9000e8d239fb901...  +outputTile tileTable
   198  0de2 7a                   ply
   199  0de3 60                   rts
   200                          ; -----------------------------------------------------------------------------
   201                          
   202                          
   203                          ; -----------------------------------------------------------------------------
   204                          ; tile definitions
   205                          ; -----------------------------------------------------------------------------
   206                          ; two bytes per tile in the VERA tile format:
   207                          ;
   208                          ; Offset	Bit 7	Bit 6	Bit 5	Bit 4	Bit 3	Bit 2	Bit 1	Bit 0
   209                          ; 0	        [ Tile index (7:0)                                            ]
   210                          ; 1	        [ Palette offset              ][V-flip][H-flip][Tile index 9:8]
   211                          ;
   212                          ; -----------------------------------------------------------------------------
   213                          !macro tileDef index, tilesetAddr, tileOffset, tilePalette, tileFlags {
   214                              
   215                              .tilesetOffset = (tilesetAddr - VRADDR_TILE_BASE) / TILE_SIZE_BYTES
   216                          
   217                              ; tile offset
   218                              .tileOffset    = .tilesetOffset + tileOffset
   219                          
   220                              ; tile index (7:0)
   221                              !byte .tileOffset & $ff
   222                          
   223                              ; palette offset (7:4), flags, tile offset (9:8)
   224                              !byte (tilePalette << 4) | tileFlags | (.tileOffset >> 8)
   225                          }
   226                          
   227  0de4 eaeaeaeaeaeaeaea...!align 255,0
   228                          tileTable:
   229  0e00 0220               tileBodyUp:       +tileDef    0, SNAKE_ADDR, 2,  SNAKE_PAL, 0
   230  0e02 1220                                 +tileDef    0, SNAKE_ADDR, 18, SNAKE_PAL, 0
   231  0e04 0220                                 +tileDef    0, SNAKE_ADDR, 2,  SNAKE_PAL, 0                  
   232  0e06 1220                                 +tileDef    0, SNAKE_ADDR, 18, SNAKE_PAL, 0                  
   233  0e08 1b2c               tileBodyUpLeft:   +tileDef    1, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   234  0e0a 0b2c                                 +tileDef    1, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   235  0e0c 1a2c                                 +tileDef    1, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   236  0e0e 0a2c                                 +tileDef    1, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   237  0e10 112c               tileHeadDown:     +tileDef    2, SNAKE_ADDR, 17, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   238  0e12 012c                                 +tileDef    2, SNAKE_ADDR, 1,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   239  0e14 102c                                 +tileDef    2, SNAKE_ADDR, 16, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   240  0e16 002c                                 +tileDef    2, SNAKE_ADDR, 0,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   241  0e18 0b28               tileBodyUpRight:  +tileDef    3, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_V
   242  0e1a 1b28                                 +tileDef    3, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_V
   243  0e1c 0a28                                 +tileDef    3, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_V
   244  0e1e 1a28                                 +tileDef    3, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_V
   245  0e20 0928               tileBodyLeftUp:   +tileDef    4, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_V
   246  0e22 1928                                 +tileDef    4, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_V
   247  0e24 0828                                 +tileDef    4, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_V
   248  0e26 1828                                 +tileDef    4, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_V
   249  0e28 132c               tileBodyLeft      +tileDef    5, SNAKE_ADDR, 19, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   250  0e2a 132c                                 +tileDef    5, SNAKE_ADDR, 19, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   251  0e2c 032c                                 +tileDef    5, SNAKE_ADDR, 3,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   252  0e2e 032c                                 +tileDef    5, SNAKE_ADDR, 3,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   253  0e30 0820               tileBodyLeftDown: +tileDef    6, SNAKE_ADDR, 8,  SNAKE_PAL, 0
   254  0e32 1820                                 +tileDef    6, SNAKE_ADDR, 24, SNAKE_PAL, 0
   255  0e34 0920                                 +tileDef    6, SNAKE_ADDR, 9,  SNAKE_PAL, 0
   256  0e36 1920                                 +tileDef    6, SNAKE_ADDR, 25, SNAKE_PAL, 0
   257  0e38 0c20               tileHeadRight     +tileDef    7, SNAKE_ADDR, 12, SNAKE_PAL, 0
   258  0e3a 1c20                                 +tileDef    7, SNAKE_ADDR, 28, SNAKE_PAL, 0
   259  0e3c 0d20                                 +tileDef    7, SNAKE_ADDR, 13, SNAKE_PAL, 0
   260  0e3e 1d20                                 +tileDef    7, SNAKE_ADDR, 29, SNAKE_PAL, 0
   261  0e40 0020               tileHeadUp:       +tileDef    8, SNAKE_ADDR, 0,  SNAKE_PAL, 0
   262  0e42 1020                                 +tileDef    8, SNAKE_ADDR, 16, SNAKE_PAL, 0
   263  0e44 0120                                 +tileDef    8, SNAKE_ADDR, 1,  SNAKE_PAL, 0                  
   264  0e46 1120                                 +tileDef    8, SNAKE_ADDR, 17, SNAKE_PAL, 0                  
   265  0e48 1a24               tileBodyDownLeft: +tileDef    9, SNAKE_ADDR, 26, SNAKE_PAL, TILE_FLIP_H
   266  0e4a 0a24                                 +tileDef    9, SNAKE_ADDR, 10, SNAKE_PAL, TILE_FLIP_H
   267  0e4c 1b24                                 +tileDef    9, SNAKE_ADDR, 27, SNAKE_PAL, TILE_FLIP_H
   268  0e4e 0b24                                 +tileDef    9, SNAKE_ADDR, 11, SNAKE_PAL, TILE_FLIP_H
   269  0e50 122c               tileBodyDown:     +tileDef   10, SNAKE_ADDR, 18, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   270  0e52 022c                                 +tileDef   10, SNAKE_ADDR, 2,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   271  0e54 122c                                 +tileDef   10, SNAKE_ADDR, 18, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   272  0e56 022c                                 +tileDef   10, SNAKE_ADDR, 2,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   273  0e58 0a20               tileBodyDownRight:+tileDef   11, SNAKE_ADDR, 10, SNAKE_PAL, 0
   274  0e5a 1a20                                 +tileDef   11, SNAKE_ADDR, 26, SNAKE_PAL, 0
   275  0e5c 0b20                                 +tileDef   11, SNAKE_ADDR, 11, SNAKE_PAL, 0
   276  0e5e 1b20                                 +tileDef   11, SNAKE_ADDR, 27, SNAKE_PAL, 0
   277  0e60 192c               tileBodyRightUp:  +tileDef   12, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   278  0e62 092c                                 +tileDef   12, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   279  0e64 182c                                 +tileDef   12, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   280  0e66 082c                                 +tileDef   12, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   281  0e68 1d2c               tileHeadLeft:     +tileDef   13, SNAKE_ADDR, 29, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   282  0e6a 0d2c                                 +tileDef   13, SNAKE_ADDR, 13, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   283  0e6c 1c2c                                 +tileDef   13, SNAKE_ADDR, 28, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   284  0e6e 0c2c                                 +tileDef   13, SNAKE_ADDR, 12, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   285  0e70 1824               tileBodyRightDown:+tileDef   14, SNAKE_ADDR, 24, SNAKE_PAL, TILE_FLIP_H
   286  0e72 0824                                 +tileDef   14, SNAKE_ADDR, 8,  SNAKE_PAL, TILE_FLIP_H
   287  0e74 1924                                 +tileDef   14, SNAKE_ADDR, 25, SNAKE_PAL, TILE_FLIP_H
   288  0e76 0924                                 +tileDef   14, SNAKE_ADDR, 9,  SNAKE_PAL, TILE_FLIP_H
   289  0e78 0320               tileBodyRight     +tileDef   15, SNAKE_ADDR, 3,  SNAKE_PAL, 0
   290  0e7a 0320                                 +tileDef   15, SNAKE_ADDR, 3,  SNAKE_PAL, 0
   291  0e7c 1320                                 +tileDef   15, SNAKE_ADDR, 19, SNAKE_PAL, 0
   292  0e7e 1320                                 +tileDef   15, SNAKE_ADDR, 19, SNAKE_PAL, 0
   293  0e80 0420               tileTailUp:       +tileDef   16, SNAKE_ADDR, 4,  SNAKE_PAL, 0
   294  0e82 1420                                 +tileDef   16, SNAKE_ADDR, 20, SNAKE_PAL, 0
   295  0e84 0520                                 +tileDef   16, SNAKE_ADDR, 5,  SNAKE_PAL, 0                  
   296  0e86 1520                                 +tileDef   16, SNAKE_ADDR, 21, SNAKE_PAL, 0                  
   297  0e88 1f2c               tileTailLeft      +tileDef   17, SNAKE_ADDR, 31, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   298  0e8a 0f2c                                 +tileDef   17, SNAKE_ADDR, 15, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   299  0e8c 1e2c                                 +tileDef   17, SNAKE_ADDR, 30, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   300  0e8e 0e2c                                 +tileDef   17, SNAKE_ADDR, 14, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   301  0e90 152c               tileTailDown:     +tileDef   18, SNAKE_ADDR, 21, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   302  0e92 052c                                 +tileDef   18, SNAKE_ADDR, 5,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   303  0e94 142c                                 +tileDef   18, SNAKE_ADDR, 20, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   304  0e96 042c                                 +tileDef   18, SNAKE_ADDR, 4,  SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   305  0e98 0e20               tileTailRight:    +tileDef   19, SNAKE_ADDR, 14, SNAKE_PAL, 0
   306  0e9a 1e20                                 +tileDef   19, SNAKE_ADDR, 30, SNAKE_PAL, 0
   307  0e9c 0f20                                 +tileDef   19, SNAKE_ADDR, 15, SNAKE_PAL, 0
   308  0e9e 1f20                                 +tileDef   19, SNAKE_ADDR, 31, SNAKE_PAL, 0
   309  0ea0 0620               tileBlank:        +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0
   310  0ea2 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0
   311  0ea4 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0                  
   312  0ea6 0620                                 +tileDef   20, SNAKE_ADDR, 6,  SNAKE_PAL, 0                  

; ******** Source: src\snake.asm
    68                          

; ******** Source: src\gameloop.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Game loop
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_GAMELOOP_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; loop to wait for vsync
    19                          ; -----------------------------------------------------------------------------
    20                          waitForVsync:
    21  0ea8 cb                   !byte $CB  ; WAI instruction
    22  0ea9 a530                 lda VSYNC_FLAG
    23  0eab d0fb                 bne waitForVsync
    24                          
    25                            ; flow on through to the.... 
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; main game loop
    29                          ; -----------------------------------------------------------------------------
    30                          gameLoop:
    31                          
    32  0ead c636                 dec ZP_ANIM_INDEX
    33  0eaf d003                 bne +
    34  0eb1 20a50f               jsr updateFrame
    35                          +
    36                          
    37  0eb4 a901                 lda #1
    38  0eb6 8530                 sta VSYNC_FLAG
    39                          
    40  0eb8 80ee               	bra waitForVsync
    41                          
    42                          doInput:
    43                           
    44  0eba 2056ff               jsr JOYSTICK_GET
    45  0ebd 8908                 bit #JOY_UP
    46  0ebf d02e                 bne .testDown
    47  0ec1 a534                 lda ZP_HEAD_CELL_X
    48  0ec3 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    49                          
    50  0ec8 c635                 dec ZP_HEAD_CELL_Y
    51  0eca a535                 lda ZP_HEAD_CELL_Y
    52  0ecc a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    53                          
    54  0ed1 a533                 lda ZP_CURRENT_DIRECTION
    55  0ed3 2903                 and #3
    56  0ed5 0a                   asl
    57  0ed6 0a                   asl
    58  0ed7 0900                 ora #DIR_UP
    59  0ed9 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
    60  0ee3 9147                 sta (ZP_QUEUE_D), y
    61  0ee5 a900                 lda #DIR_UP << 2 | DIR_UP
    62  0ee7 8533                 sta ZP_CURRENT_DIRECTION
    63  0ee9 a64620ca08           +qPush ZP_QUEUE_D_INDEX
    64  0eee 60                   rts
    65                          .testDown:
    66  0eef 8904                 bit #JOY_DOWN
    67  0ef1 d02e                 bne .testRight
    68                            
    69  0ef3 a534                 lda ZP_HEAD_CELL_X
    70  0ef5 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    71                          
    72  0efa e635                 inc ZP_HEAD_CELL_Y
    73  0efc a535                 lda ZP_HEAD_CELL_Y
    74  0efe a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    75                          
    76  0f03 a533                 lda ZP_CURRENT_DIRECTION
    77  0f05 2903                 and #3
    78  0f07 0a                   asl
    79  0f08 0a                   asl
    80  0f09 0902                 ora #DIR_DOWN
    81  0f0b 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
    82  0f15 9147                 sta (ZP_QUEUE_D), y
    83  0f17 a90a                 lda #DIR_DOWN << 2 | DIR_DOWN
    84  0f19 8533                 sta ZP_CURRENT_DIRECTION
    85  0f1b a64620ca08           +qPush ZP_QUEUE_D_INDEX
    86  0f20 60                   rts
    87                          .testRight:
    88  0f21 8901                 bit #JOY_RIGHT
    89  0f23 d02e                 bne .testLeft
    90  0f25 e634                 inc ZP_HEAD_CELL_X
    91  0f27 a534                 lda ZP_HEAD_CELL_X
    92  0f29 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    93                          
    94  0f2e a535                 lda ZP_HEAD_CELL_Y
    95  0f30 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
    96                          
    97  0f35 a533                 lda ZP_CURRENT_DIRECTION
    98  0f37 2903                 and #3
    99  0f39 0a                   asl
   100  0f3a 0a                   asl
   101  0f3b 0903                 ora #DIR_RIGHT
   102  0f3d 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
   103  0f47 9147                 sta (ZP_QUEUE_D), y
   104  0f49 a90f                 lda #DIR_RIGHT << 2 | DIR_RIGHT
   105  0f4b 8533                 sta ZP_CURRENT_DIRECTION
   106  0f4d a64620ca08           +qPush ZP_QUEUE_D_INDEX
   107  0f52 60                   rts
   108                          .testLeft:
   109  0f53 8902                 bit #JOY_LEFT
   110  0f55 d02e                 bne .doneTests
   111  0f57 c634                 dec ZP_HEAD_CELL_X
   112  0f59 a534                 lda ZP_HEAD_CELL_X
   113  0f5b a64020ca08           +qPush ZP_QUEUE_X_INDEX
   114                          
   115  0f60 a535                 lda ZP_HEAD_CELL_Y
   116  0f62 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   117                          
   118  0f67 a533                 lda ZP_CURRENT_DIRECTION
   119  0f69 2903                 and #3
   120  0f6b 0a                   asl
   121  0f6c 0a                   asl
   122  0f6d 0901                 ora #DIR_LEFT
   123  0f6f 48a5460aaabc0160...  +qBack ZP_QUEUE_D_INDEX
   124  0f79 9147                 sta (ZP_QUEUE_D), y
   125  0f7b a905                 lda #DIR_LEFT << 2 | DIR_LEFT
   126  0f7d 8533                 sta ZP_CURRENT_DIRECTION
   127  0f7f a64620ca08           +qPush ZP_QUEUE_D_INDEX
   128  0f84 60                   rts
   129                          .doneTests:
   130                          ;  inc ZP_HEAD_CELL_X
   131  0f85 a534                 lda ZP_HEAD_CELL_X
   132  0f87 a64020ca08           +qPush ZP_QUEUE_X_INDEX
   133                          
   134  0f8c a535                 lda ZP_HEAD_CELL_Y
   135  0f8e a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   136                          
   137  0f93 a533                 lda ZP_CURRENT_DIRECTION
   138  0f95 2903                 and #3
   139  0f97 8533                 sta ZP_CURRENT_DIRECTION
   140  0f99 0a                   asl
   141  0f9a 0a                   asl
   142  0f9b 0533                 ora ZP_CURRENT_DIRECTION
   143  0f9d 8533                 sta ZP_CURRENT_DIRECTION
   144  0f9f a64620ca08           +qPush ZP_QUEUE_D_INDEX
   145  0fa4 60                   rts
   146                          
   147                          
   148                          updateFrame:
   149                          
   150  0fa5 20ba0e               jsr doInput
   151                          
   152  0fa8 a640                 ldx ZP_QUEUE_X_INDEX
   153  0faa 200209               jsr qSize
   154  0fad 48                   pha
   155  0fae 200d09               jsr qIterate
   156  0fb1 fa                   plx  ; here, x i size, y is starting offset, a is queue msb
   157                          
   158  0fb2 b141                 lda (ZP_QUEUE_X), y
   159  0fb4 8530                 sta ZP_CURRENT_CELL_X
   160  0fb6 b144                 lda (ZP_QUEUE_Y), y
   161  0fb8 8531                 sta ZP_CURRENT_CELL_Y
   162  0fba 20380d               jsr setCellVram
   163  0fbd a914                 +ldaTileId tileBlank
   164  0fbf 20570d               jsr outputTile
   165  0fc2 c8                   iny
   166  0fc3 ca                   dex
   167                          
   168  0fc4 b141                 lda (ZP_QUEUE_X), y
   169  0fc6 8530                 sta ZP_CURRENT_CELL_X
   170  0fc8 b144                 lda (ZP_QUEUE_Y), y
   171  0fca 8531                 sta ZP_CURRENT_CELL_Y
   172  0fcc 20380d               jsr setCellVram
   173  0fcf b147                 lda (ZP_QUEUE_D), y
   174  0fd1 2903                 and #$03  ; tail
   175  0fd3 0910                 ora #$10
   176  0fd5 20570d               jsr outputTile
   177  0fd8 c8                   iny
   178  0fd9 ca                   dex
   179                          
   180                          
   181                          --
   182  0fda b141                 lda (ZP_QUEUE_X), y
   183  0fdc 8530                 sta ZP_CURRENT_CELL_X
   184  0fde b144                 lda (ZP_QUEUE_Y), y
   185  0fe0 8531                 sta ZP_CURRENT_CELL_Y
   186  0fe2 20380d               jsr setCellVram
   187  0fe5 b147                 lda (ZP_QUEUE_D), y
   188  0fe7 e001                 cpx #1   
   189  0fe9 d002                 bne +
   190  0feb 4908                 eor #$08  ; head
   191                          +
   192  0fed 20570d               jsr outputTile
   193                          
   194  0ff0 c8                   iny
   195  0ff1 ca                   dex
   196  0ff2 d0e6                 bne --  
   197                          
   198                          
   199  0ff4 a64020e308           +qPop ZP_QUEUE_X_INDEX
   200  0ff9 a64320e308           +qPop ZP_QUEUE_Y_INDEX
   201  0ffe a64620e308           +qPop ZP_QUEUE_D_INDEX
   202                          
   203  1003 a908                 lda #8
   204  1005 8536                 sta ZP_ANIM_INDEX
   205                          
   206  1007 60                   rts

; ******** Source: src\snake.asm
    69                          
