
; ******** Source: src\snake.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Copyright (c) 2020 Troy Schrapel
     4                          ;
     5                          ; This code is licensed under the MIT license
     6                          ;
     7                          ; https://github.com/visrealm/cx16-snake
     8                          ;
     9                          ;
    10                          
    11                          !cpu 65c02
    12                          

; ******** Source: src\common\bootstrap.asm
     1                          ; Commander X16
     2                          ;
     3                          ; ACME assembler bootstrap for 6502
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          ; standard bootstrap
    14                          ; generate SYS 2064 ($810)
    15                          
    16                          *=$0801			; Assembled code should start at $0801
    17                          
    18                          			; (where BASIC programs start)
    19                          			; The real program starts at $0810 = 2064
    20                                
    21  0801 0c08               !byte $0C,$08		; $080C - pointer to next line of BASIC code
    22  0803 0a00               !byte $0A,$00		; 2-byte line number ($000A = 10)
    23  0805 9e                 !byte $9E		; SYS BASIC token
    24  0806 20                 !byte $20		; [space]
    25  0807 32303634           !text "2064"	; $32="2",$30="0",$36="6",$34="4"
    26                          			; (ASCII encoded nums for dec starting addr)
    27  080b 000000             !byte $00,$00,$00	
    28                          

; ******** Source: src\snake.asm
    13                          

; ******** Source: src\common\kernal\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; CX16 Kernal Constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_KERNAL_CONSTANTS_ASM_ = 1
    13                          
    14                          !cpu 65c02
    15                          
    16                          ; temporary address used where self-modifying code will update an instruction
    17                          SELF_MODIFY_MSB_ADDR = $ee00
    18                          SELF_MODIFY_ADDR     = $eeee
    19                          
    20                          
    21                          CHROUT      = $FFD2	; CHROUT outputs a character (C64 Kernal API)
    22                          CHRIN       = $FFCF		; CHRIN read from default input
    23                          
    24                          SETLFS			= $FFBA
    25                          SETNAM			= $FFBD
    26                          LOAD			  = $FFD5
    27                          OPEN        = $FFC0
    28                          CLOSE       = $FFC3
    29                          
    30                          BANKED_RAM_START    = $A000
    31                          BANKED_RAM_END      = $BFFF
    32                          ROM_BANK            = $9F60
    33                          RAM_BANK            = $9F61
    34                          
    35                          ; have a separate one for sanity checks
    36                          ; so I can find the others I use temporarily
    37                          ; easier
    38                          !macro dbgSanityCheckBreak {
    39                            !ifdef SANITY { !byte $ff }
    40                          }
    41                          
    42                          !macro dbgBreak {
    43                            !ifdef DEBUG { !byte $ff }
    44                          }
    45                          
    46                          !macro setRamBank bank {
    47                            lda #bank
    48                            sta RAM_BANK
    49                          }
    50                          
    51                          !macro setRomBank bank {
    52                            lda #bank
    53                            sta ROM_BANK
    54                          }
    55                          
    56                          !macro ramBankSanityCheck bank {
    57                            !ifdef SANITY {
    58                              phy
    59                              ldy RAM_BANK
    60                              cpy #bank
    61                              beq +
    62                              !byte $ff
    63                          +
    64                              ply
    65                            }
    66                          }
    67                          
    68                          
    69                          ; Joystick constants
    70                          ; ----------------------------------------------------------------------------
    71                          ; subroutines
    72                          
    73                          JOYSTICK_SCAN = $ff53
    74                          
    75                          ; Get joystick state
    76                          ; A = buttons
    77                          ; X = xtended buttons (SNES)
    78                          ; Y = device present ($00) or not ($FF)
    79                          JOYSTICK_GET  = $ff56
    80                          
    81                          ; constants
    82                          JOY_RIGHT  = %00000001
    83                          JOY_LEFT   = %00000010
    84                          JOY_DOWN   = %00000100
    85                          JOY_UP     = %00001000
    86                          JOY_START  = %00010000
    87                          JOY_SELECT = %00100000
    88                          JOY_B      = %01000000
    89                          JOY_A      = %10000000
    90                          
    91                          JOYSTICK_PRESENT     = $00
    92                          JOYSTICK_NOT_PRESENT = $ff
    93                          
    94                          CLOCK_GET_DATE_TIME = $ff50
    95                          
    96                          ; Virtual registers
    97                          ; ----------------------------------------------------------------------------
    98                          R0  = $02
    99                          R0L = R0
   100                          R0H = R0 + 1
   101                          R1  = $04
   102                          R1L = R1
   103                          R1H = R1 + 1
   104                          R2  = $06
   105                          R2L = R2
   106                          R2H = R2 + 1
   107                          R3  = $08
   108                          R3L = R3
   109                          R3H = R3 + 1
   110                          R4  = $0a
   111                          R4L = R4
   112                          R4H = R4 + 1
   113                          R5  = $0c
   114                          R5L = R5
   115                          R5H = R5 + 1
   116                          R6  = $0e
   117                          R6L = R6
   118                          R6H = R6 + 1
   119                          R7  = $10
   120                          R7L = R7
   121                          R7H = R7 + 1
   122                          R8  = $12
   123                          R8L = R8
   124                          R8H = R8 + 1
   125                          R9  = $14
   126                          R9L = R9
   127                          R9H = R9 + 1
   128                          R10  = $16
   129                          R10L = R10
   130                          R10H = R10 + 1
   131                          R11  = $18
   132                          R11L = R11
   133                          R11H = R11 + 1

; ******** Source: src\snake.asm
    14                          
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; constants
    18                          ; -----------------------------------------------------------------------------
    19                          ADDR_QUEUE_HEADERS = $6000 ; 4KB
    20                          
    21                          
    22                          ; -----------------------------------------------------------------------------
    23                          ; program entry
    24                          ; -----------------------------------------------------------------------------
    25                          
    26  0810 78                   sei
    27                          
    28                            ; turn off the display while we're setting things up
    29  0811 20e90b               jsr disableDisplay
    30                          
    31                            ; initialise queues
    32  0814 20af08               jsr qInit
    33                          
    34  0817 202c0c               jsr loadTiles
    35                          
    36                            ; set up and enable the display
    37  081a 20ef0b               jsr configDisplay
    38                          
    39                            ; register the vsync interrupt handler
    40  081d 20c60b               jsr registerVsyncIrq
    41                          
    42  0820 58                   cli
    43                          
    44                            ; enter the game loop
    45  0821 4c8014               jmp waitForVsync
    46                          
    47  0824 60                   rts
    48                          
    49                          

; ******** Source: src\common\util.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Utility subroutines and macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_UTIL_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; +dec16: decement a 16-bit value
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  addr: address containing LSB of value to decrement
    22                          ; -----------------------------------------------------------------------------
    23                          !macro dec16 addr {
    24                            lda addr
    25                            bne +
    26                            dec addr + 1
    27                          +
    28                            dec addr
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; +inc16: increment a 16-bit value
    33                          ; -----------------------------------------------------------------------------
    34                          ; Inputs:
    35                          ;  addr: address containing LSB of value to increment
    36                          ; -----------------------------------------------------------------------------
    37                          !macro inc16 addr {
    38                            inc addr
    39                            bne +
    40                            inc addr + 1
    41                          +
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; +cmp16: compare two 16-bit values in memory
    46                          ; -----------------------------------------------------------------------------
    47                          ; Inputs:
    48                          ;  left:  address containing LSB of left value to comapre
    49                          ;  right: address containing LSB of right value to comapre
    50                          ; -----------------------------------------------------------------------------
    51                          !macro cmp16 left, right {
    52                            lda left + 1
    53                            cmp right + 1
    54                          	bne +
    55                          	lda left
    56                          	cmp right
    57                          +
    58                          }
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; +cmp16: compare two 16-bit values in memory
    62                          ; -----------------------------------------------------------------------------
    63                          ; Inputs:
    64                          ;  value: immediate value to compare
    65                          ;  x:     msb
    66                          ;  a:     lsb
    67                          ; -----------------------------------------------------------------------------
    68                          !macro cmp16xa value {
    69                            cpx #>value
    70                          	bne +
    71                          	cmp #<value
    72                          +
    73                          }
    74                          
    75                          ; -----------------------------------------------------------------------------
    76                          ; +sub16: subtract 16 bit numbers
    77                          ; -----------------------------------------------------------------------------
    78                          ; Inputs:
    79                          ;  left:  address containing LSB of left value
    80                          ;  right: address containing LSB of right value
    81                          ; Outputs:
    82                          ;  res:   address containing LSB of result
    83                          ; -----------------------------------------------------------------------------
    84                          !macro sub16 left, right, res {
    85                            sec
    86                            lda left
    87                            sbc right
    88                            sta res
    89                            lda left + 1
    90                            sbc right + 1
    91                            sta res + 1
    92                          }
    93                          
    94                          ; -----------------------------------------------------------------------------
    95                          ; +sub16: subtract 16 bit numbers - result in ax registers
    96                          ; -----------------------------------------------------------------------------
    97                          ; Inputs:
    98                          ;  left:  address containing LSB of left value
    99                          ;  right: address containing LSB of right value
   100                          ; Outputs:
   101                          ;  a:     result msb
   102                          ;  x:     result lsb
   103                          ; -----------------------------------------------------------------------------
   104                          !macro sub16 left, right {
   105                            sec
   106                            lda left
   107                            sbc right
   108                            tax
   109                            lda left + 1
   110                            sbc right + 1
   111                          }
   112                          
   113                          
   114                          ; -----------------------------------------------------------------------------
   115                          ; +subImm8From16: subtract an 8 bit number from a 16 bit number
   116                          ; -----------------------------------------------------------------------------
   117                          ; Inputs:
   118                          ;  left:  address containing LSB of left value
   119                          ;  right: immediate 8-bit value
   120                          ; Outputs:
   121                          ;  res:   address containing LSB of result
   122                          ; -----------------------------------------------------------------------------
   123                          !macro subImm8From16 left, right, res {
   124                            sec
   125                            lda left
   126                            sbc #right
   127                            sta res
   128                            lda left + 1
   129                            sbc #0
   130                            sta res + 1
   131                          }
   132                          
   133                          ; -----------------------------------------------------------------------------
   134                          ; +incBcd: increment a BCD byte (inc instruction doesn't work in bcd mode)
   135                          ; -----------------------------------------------------------------------------
   136                          ; Inputs:
   137                          ;  addr:  address containing BCD value
   138                          ; -----------------------------------------------------------------------------
   139                          !macro incBcd addr {
   140                            lda addr
   141                            sed
   142                            clc
   143                            adc #1
   144                            cld
   145                            sta addr
   146                          }
   147                          
   148                          ; -----------------------------------------------------------------------------
   149                          ; +decBcd: decrement a BCD byte (inc instruction doesn't work in bcd mode)
   150                          ; -----------------------------------------------------------------------------
   151                          ; Inputs:
   152                          ;  addr:  address containing BCD value
   153                          ; -----------------------------------------------------------------------------
   154                          !macro decBcd addr {
   155                            lda addr
   156                            sed
   157                            sec
   158                            sbc #1
   159                            cld
   160                            sta addr
   161                          }
   162                          
   163                          ; -----------------------------------------------------------------------------
   164                          ; bin2bcd8: convert an unsigned byte to a 2-digit bcd value
   165                          ; -----------------------------------------------------------------------------
   166                          ; Inputs:
   167                          ;   A: value
   168                          ; Outputs:
   169                          ;   BCD value in R8
   170                          ; -----------------------------------------------------------------------------
   171                          bin2bcd8:
   172  0825 8510                 sta R7L
   173  0827 6412                 stz R8L
   174  0829 6413                 stz R8H
   175  082b a208                 ldx #8 
   176  082d f8                   sed    
   177                          .loop:
   178  082e 0610                 asl R7L
   179  0830 a512                 lda R8L
   180  0832 6512                 adc R8L
   181  0834 8512                 sta R8L
   182  0836 a513                 lda R8H
   183  0838 6513                 adc R8H
   184  083a 8513                 sta R8H
   185  083c ca                   dex
   186  083d d0ef                 bne .loop
   187  083f d8                   cld   
   188  0840 60                   rts
   189                          

; ******** Source: src\snake.asm
    50                          

; ******** Source: src\common\file.asm
     1                          ; Commander X16
     2                          ;
     3                          ; File utilities
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_FILE_ASM_ = 1
    15                          
    16                          ; -----------------------------------------------------------------------------
    17                          ; setFile:   set the current file to work with
    18                          ; -----------------------------------------------------------------------------
    19                          ; filename:  address of zero-terminated string
    20                          ; -----------------------------------------------------------------------------
    21                          !macro setFile filename {
    22                            ldx #<filename
    23                            ldy #>filename
    24                            jsr strLen
    25                            jsr SETNAM
    26                          }
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; loadFile:   helper to load a file into ram
    30                          ; -----------------------------------------------------------------------------
    31                          ; filename:  zero-terminated string
    32                          ; ramArress: address to load the raw data
    33                          ; -----------------------------------------------------------------------------
    34                          !macro loadFile filename, address {
    35                          
    36                            !if <address != $00 {
    37                              !error "output address must be aligned to a page boundry"
    38                            }
    39                          
    40                            +setFile filename
    41                          
    42                            lda #>address
    43                          
    44                            jsr loadFile
    45                          }
    46                          
    47                          ; -----------------------------------------------------------------------------
    48                          ; loadFile: load raw data file into ram
    49                          ; -----------------------------------------------------------------------------
    50                          ; Prerequisites:
    51                          ;   SETNAME called 
    52                          ; Inputs:
    53                          ;   A: MSB of output address
    54                          ; -----------------------------------------------------------------------------
    55                          loadFile:
    56  0841 48                   pha
    57  0842 a901                 lda #$01
    58  0844 a208                 ldx #$08      ; default to device 8
    59  0846 a000                 ldy #$00      ; $00 means: load to new address
    60  0848 20baff               jsr SETLFS
    61                          
    62  084b a202                 ldx #$02        ; account for address header 
    63  084d 7a                   ply
    64  084e a900                 lda #$00      ; $00 means: load to memory (not verify)
    65  0850 20d5ff               jsr LOAD
    66  0853 b005                 bcs .errorLoad    ; if carry set, a load error has happened
    67                          
    68  0855 8606                 stx R2L
    69  0857 8407                 sty R2H
    70                          
    71  0859 60                   rts
    72                          .errorLoad
    73  085a 00                   brk
    74  085b 60                   rts

; ******** Source: src\snake.asm
    51                          

; ******** Source: src\common\memory.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Memory subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_MEMORY_ASM_ = 1
    14                          
    15                          !zone memcpy {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; memcpy: Copy a fixed number of bytes from src to dest
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  src: source address
    22                          ;  dst: destination address
    23                          ;  cnt: number of bytes
    24                          ; -----------------------------------------------------------------------------
    25                          !macro memcpy src, dst, cnt {
    26                            lda #<src
    27                            sta R0L
    28                            lda #>src
    29                            sta R0H
    30                          
    31                            lda #<dst
    32                            sta R1L
    33                            lda #>dst
    34                            sta R1H
    35                          
    36                            ldy #<cnt
    37                          
    38                            !if cnt <= 255 {
    39                              jsr memcpySinglePage 
    40                            } else {
    41                              ldx #>cnt
    42                              jsr memcpyMultiPage
    43                            }
    44                          }
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; memcpySinglePage: Copy up to 255 bytes 
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  R0: src address
    51                          ;  R1: dst address
    52                          ;  Y:  bytes
    53                          ; -----------------------------------------------------------------------------
    54                          memcpySinglePage:
    55  085c b102                 lda (R0), Y
    56  085e 9104                 sta (R1), Y
    57  0860 88                   dey
    58  0861 d0f9                 bne memcpySinglePage
    59  0863 60                   rts
    60                          ; -----------------------------------------------------------------------------
    61                          
    62                          
    63                          ; -----------------------------------------------------------------------------
    64                          ; memcpyMultiPage: Copy an up to 2^15 bytes 
    65                          ; -----------------------------------------------------------------------------
    66                          ; Inputs:
    67                          ;  R0: src address
    68                          ;  R1: dst address
    69                          ;  X:  bytes MSB
    70                          ;  Y:  bytes LSB
    71                          ; -----------------------------------------------------------------------------
    72                          memcpyMultiPage:
    73  0864 a502                 lda R0L
    74  0866 8d7908               sta .loadIns + 1
    75  0869 a503                 lda R0H
    76  086b 8d7a08               sta .loadIns + 2
    77                          
    78  086e a504                 lda R1L
    79  0870 8d7c08               sta .storeIns + 1
    80  0873 a505                 lda R1H
    81  0875 8d7d08               sta .storeIns + 2
    82                          
    83                          .loadIns:
    84  0878 b9eeee               lda SELF_MODIFY_ADDR, Y
    85                            
    86                          .storeIns:
    87  087b 99eeee               sta SELF_MODIFY_ADDR, Y
    88  087e 88                   dey
    89  087f d0f7                 bne .loadIns
    90  0881 ee7a08               inc .loadIns + 2
    91  0884 ee7d08               inc .storeIns + 2
    92  0887 ca                   dex
    93  0888 d0ee                 bne .loadIns
    94                          
    95  088a 60                   rts
    96                          ; -----------------------------------------------------------------------------
    97                          
    98                          }
    99                          
   100                          
   101                          
   102                          
   103                          !zone mem2reg {
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; mem2regSinglePage: Copy up to 255 bytes from ram to a register stream
   107                          ; -----------------------------------------------------------------------------
   108                          ; Inputs:
   109                          ;  R0: src address
   110                          ;  R1: output register address
   111                          ;  X:  bytes
   112                          ; -----------------------------------------------------------------------------
   113                          !macro mem2regSinglePage outReg {
   114                            ldy #0
   115                          -
   116                            lda (R0), y
   117                            sta outReg
   118                            iny
   119                            dex
   120                            bne -
   121                          }
   122                          ; -----------------------------------------------------------------------------
   123                          
   124                          
   125                          ; -----------------------------------------------------------------------------
   126                          ; mem2reg: Copy a fixed number of bytes from src to dest
   127                          ; -----------------------------------------------------------------------------
   128                          ; Inputs:
   129                          ;  src: source address
   130                          ;  dst: destination register stream address
   131                          ;  cnt: number of bytes
   132                          ; -----------------------------------------------------------------------------
   133                          !macro mem2reg src, dst, cnt {
   134                            lda #<src
   135                            sta R0L
   136                            lda #>src
   137                            sta R0H
   138                          
   139                            ldx #<cnt
   140                          
   141                            !if cnt <= 255 {
   142                              +mem2regSinglePage dst
   143                            } else {
   144                              lda #<dst
   145                              sta mem2regMultiPageStoreIns + 1
   146                              lda #>dst
   147                              sta mem2regMultiPageStoreIns + 2
   148                              ldy #>cnt
   149                              jsr mem2regMultiPage
   150                            }
   151                          }
   152                          
   153                          
   154                          ; -----------------------------------------------------------------------------
   155                          ; mem2regMultiPage: Copy memory to a register stream 
   156                          ; -----------------------------------------------------------------------------
   157                          ; Inputs:
   158                          ;  R0: src address
   159                          ;  R1: output register address
   160                          ;  X:  bytes LSB
   161                          ;  Y:  bytes MSB
   162                          ; -----------------------------------------------------------------------------
   163                          mem2regMultiPage:
   164  088b a502                 lda R0L
   165  088d 8d9b08               sta .loadIns + 1
   166  0890 a503                 lda R0H
   167  0892 8d9c08               sta .loadIns + 2
   168                          
   169  0895 c8                   iny
   170                            
   171  0896 8a                   txa
   172  0897 d001                 bne +
   173  0899 88                   dey
   174                          +
   175                          
   176                           
   177                          .loadIns:
   178  089a adffff               lda $ffff
   179                            
   180                          mem2regMultiPageStoreIns:
   181  089d 8dffff               sta $ffff
   182  08a0 ee9b08d003ee9c08     +inc16 .loadIns + 1
   183  08a8 ca                   dex
   184  08a9 d0ef                 bne .loadIns
   185  08ab 88                   dey
   186  08ac d0ec                 bne .loadIns
   187                          
   188  08ae 60                   rts
   189                          ; -----------------------------------------------------------------------------
   190                          

; ******** Source: src\snake.asm
    52                          

; ******** Source: src\common\queue.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Queue management
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_QUEUE_ASM_ = 1
    13                          
    14                          !ifndef ADDR_QUEUE_HEADERS  { !error "Must set address for queue system to use: ADDR_QUEUE_HEADERS" }
    15                          
    16                          QUEUE_HEADER_SIZE = 4
    17                          
    18                          ; queue data structure (ADDR_QUEUE_HEADERS)
    19                          ; 0:  count of queues created
    20                          ; 1: unused
    21                          ;   (below repeated for each queue created). page is >ADDR_QUEUE_HEADERS + queue index
    22                          ; 2: head (page offset)
    23                          ; 3: tail (page offset)
    24                          
    25                          QUEUE_OFFSET_HEAD = 0
    26                          QUEUE_OFFSET_TAIL = 1
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; qInit: Initialise queue manager
    30                          ; -----------------------------------------------------------------------------
    31                          qInit:
    32  08af 9c0060               stz ADDR_QUEUE_HEADERS
    33  08b2 60                   rts
    34                          
    35                          ; -----------------------------------------------------------------------------
    36                          ; qInit: create a queue, store its id in address
    37                          ; -----------------------------------------------------------------------------
    38                          !macro qCreate index, addressMsb {
    39                            jsr qCreate
    40                            stx index
    41                            sta addressMsb
    42                          }
    43                          
    44                          ; -----------------------------------------------------------------------------
    45                          ; qPush: push a value to a queue
    46                          ; -----------------------------------------------------------------------------
    47                          !macro qPush index {
    48                            ldx index
    49                            jsr qPush
    50                          }
    51                          
    52                          ; -----------------------------------------------------------------------------
    53                          ; qPop: pop a value from the queue
    54                          ; -----------------------------------------------------------------------------
    55                          !macro qPop index {
    56                            ldx index
    57                            jsr qPop
    58                          }
    59                          
    60                          
    61                          ; -----------------------------------------------------------------------------
    62                          ; qFront: get offset to front of queue
    63                          ; -----------------------------------------------------------------------------
    64                          !macro qFront index {
    65                            ldx index
    66                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
    67                          }
    68                          
    69                          
    70                          ; -----------------------------------------------------------------------------
    71                          ; qBack: get offset to back of queue
    72                          ; -----------------------------------------------------------------------------
    73                          !macro qBack index {
    74                            pha
    75                            lda index
    76                            asl
    77                            tax
    78                            ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
    79                            dey
    80                            pla
    81                          }
    82                          
    83                          ; -----------------------------------------------------------------------------
    84                          ; qIterate: iterate a queue
    85                          ; -----------------------------------------------------------------------------
    86                          !macro qIterate index {
    87                            ldx index
    88                            jsr qIterate
    89                          }
    90                          
    91                          ; -----------------------------------------------------------------------------
    92                          ; qSize: return size of queue
    93                          ; -----------------------------------------------------------------------------
    94                          !macro qSize index {
    95                            ldx index
    96                            jsr qSize
    97                          }
    98                          
    99                          ; -----------------------------------------------------------------------------
   100                          ; qInit: create a queue
   101                          ; -----------------------------------------------------------------------------
   102                          ; Inputs: none
   103                          ; Returns:
   104                          ;   x: Queue index
   105                          ;   a: Queue MSB
   106                          ; -----------------------------------------------------------------------------
   107                          qCreate:
   108                            ; get the current number of queues
   109                            ; increment it and store it
   110  08b3 ad0060               lda ADDR_QUEUE_HEADERS
   111  08b6 1a                   inc
   112  08b7 aa                   tax
   113  08b8 8e0060               stx ADDR_QUEUE_HEADERS
   114                          
   115                            ; now write the queue header (head and tail will be zero)
   116  08bb 0a                   asl ; double it since there are 2 bytes per queue header
   117  08bc a8                   tay
   118  08bd a900                 lda #0
   119  08bf 990060               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD,y
   120  08c2 990160               sta ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL,y
   121  08c5 98                   tya
   122  08c6 18                   clc
   123  08c7 6960                 adc #>ADDR_QUEUE_HEADERS
   124  08c9 60                   rts
   125                          
   126                          ; -----------------------------------------------------------------------------
   127                          ; qPushBack: push a value onto the back of a queue
   128                          ; -----------------------------------------------------------------------------
   129                          ; inputs:
   130                          ;   A: value to push
   131                          ;   X: queue index
   132                          ; -----------------------------------------------------------------------------
   133                          qPush:
   134                          qPushBack:
   135  08ca 48                   pha
   136  08cb da                   phx
   137                            ; get queue tail
   138                            
   139  08cc 8a                   txa
   140  08cd 0a                   asl
   141  08ce 18                   clc
   142  08cf 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   143  08d1 8de108               sta .ldaOffsetPush + 2
   144  08d4 8a                   txa   ; find the tail, place in y
   145  08d5 0a                   asl
   146  08d6 aa                   tax
   147  08d7 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   148  08da fe0160               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   149  08dd fa                   plx
   150  08de 68                   pla
   151                          .ldaOffsetPush
   152  08df 9900ee               sta SELF_MODIFY_MSB_ADDR, y
   153  08e2 60                   rts
   154                          
   155                          ; -----------------------------------------------------------------------------
   156                          ; qPopFront: pop a value from the from of the front of the queue
   157                          ; -----------------------------------------------------------------------------
   158                          ; inputs:
   159                          ;   X: queue index
   160                          ; returns
   161                          ;   A: value
   162                          ; -----------------------------------------------------------------------------
   163                          qPop:
   164                          qPopFront:
   165  08e3 da                   phx
   166  08e4 8a                   txa
   167  08e5 18                   clc
   168  08e6 6960                 adc #>ADDR_QUEUE_HEADERS ; update code below to correct queue
   169  08e8 8df708               sta .ldaOffsetPop + 2
   170  08eb 8a                   txa   ; find the head, place in y
   171  08ec 0a                   asl
   172  08ed aa                   tax
   173  08ee bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   174  08f1 fe0060               inc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   175  08f4 fa                   plx
   176                          .ldaOffsetPop
   177  08f5 b900ee               lda SELF_MODIFY_MSB_ADDR, y
   178  08f8 60                   rts
   179                          
   180                          ; -----------------------------------------------------------------------------
   181                          ; qBack: get offset to front of queue
   182                          ; -----------------------------------------------------------------------------
   183                          ; inputs:
   184                          ;   X: queue index
   185                          ; returns
   186                          ;   Y: front offset
   187                          ; -----------------------------------------------------------------------------
   188                          qBack:
   189  08f9 bc0160               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, x
   190  08fc 88                   dey
   191  08fd 60                   rts
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; qFront: get offset to front of queue
   195                          ; -----------------------------------------------------------------------------
   196                          ; inputs:
   197                          ;   X: queue index
   198                          ; returns
   199                          ;   Y: front offset
   200                          ; -----------------------------------------------------------------------------
   201                          qFront:
   202  08fe bc0060               ldy ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, x
   203  0901 60                   rts
   204                          ; -----------------------------------------------------------------------------
   205                          ; qSize: return the queue size
   206                          ; -----------------------------------------------------------------------------
   207                          ; inputs:
   208                          ;   X: queue index
   209                          ; returns
   210                          ;   A: size
   211                          ; -----------------------------------------------------------------------------
   212                          qSize:
   213  0902 8a                   txa
   214  0903 0a                   asl ; get offset
   215  0904 a8                   tay
   216  0905 b90160               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_TAIL, y
   217  0908 38                   sec
   218  0909 f90060               sbc ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   219  090c 60                   rts
   220                          
   221                          ; -----------------------------------------------------------------------------
   222                          ; qIterate: set up to iterate a queue
   223                          ; -----------------------------------------------------------------------------
   224                          ; inputs:
   225                          ;   X: queue index
   226                          ; returns
   227                          ;   A: MSB byte of queue
   228                          ;   Y: starting offset (head index)
   229                          ; -----------------------------------------------------------------------------
   230                          qIterate:
   231  090d 8a                   txa
   232  090e 0a                   asl ; get offset
   233  090f a8                   tay
   234  0910 b90060               lda ADDR_QUEUE_HEADERS + QUEUE_OFFSET_HEAD, y
   235  0913 a8                   tay
   236  0914 8a                   txa
   237  0915 0a                   asl
   238  0916 18                   clc
   239  0917 6960                 adc #>ADDR_QUEUE_HEADERS
   240  0919 60                   rts

; ******** Source: src\snake.asm
    53                          

; ******** Source: src\common\string.asm
     1                          ; Commander X16
     2                          ;
     3                          ; String subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_STRING_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; strLen: Length of a null-terminated string
    19                          ; -----------------------------------------------------------------------------
    20                          ; Inputs:
    21                          ;  X: address LSB
    22                          ;  Y: address MSB
    23                          ; Outputs:
    24                          ;  A: length
    25                          ; -----------------------------------------------------------------------------
    26                          strLen:
    27                          !zone
    28  091a 5a                   phy
    29  091b 8e2409               stx .loop + 1        ; save string pointer LSB
    30  091e 8c2509               sty .loop + 2        ; save string pointer MSB
    31  0921 a000                 ldy #0               ; starting string index
    32                          
    33                          .loop:
    34  0923 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    35  0926 f003                 beq .end             ; end of string
    36  0928 c8                   iny                  ; next
    37  0929 80f8                 bra .loop
    38                          
    39                          .end:
    40  092b 98                   tya
    41  092c 7a                   ply
    42  092d 60                   rts
    43                          ; -----------------------------------------------------------------------------
    44                          
    45                          
    46                          ; -----------------------------------------------------------------------------
    47                          ; printStr: Print a null-terminated string
    48                          ; -----------------------------------------------------------------------------
    49                          ; Inputs:
    50                          ;  X: address LSB
    51                          ;  Y: address MSB
    52                          ; -----------------------------------------------------------------------------
    53                          printStr:
    54                          !zone 
    55  092e 8e3709               stx .loop + 1        ; save string pointer LSB
    56  0931 8c3809               sty .loop + 2        ; save string pointer MSB
    57  0934 a000                 ldy #0               ; starting string index
    58                          
    59                          .loop:
    60  0936 b9eeee               lda SELF_MODIFY_ADDR, y         ; get a character
    61  0939 f006                 beq .end             ; end of string
    62                          
    63  093b 20d2ff               jsr CHROUT           ; print character
    64  093e c8                   iny                  ; next
    65  093f 80f5                 bra .loop
    66                          
    67                          .end:
    68  0941 60                   rts
    69                          ; -----------------------------------------------------------------------------
    70                          
    71                          
    72                          !macro printStr stringAddr {
    73                            ldx #<stringAddr
    74                            ldy #>stringAddr
    75                            jsr printStr

; ******** Source: src\snake.asm
    54                          
    55                          

; ******** Source: src\common\vera\constants.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera constants
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          CMN_VERA_CONSTANTS_ = 1
    13                          
    14                          VERA_ADDRx_L      = $9F20
    15                          VERA_ADDRx_M      = $9F21
    16                          VERA_ADDRx_H      = $9F22
    17                          VERA_DATA0        = $9F23
    18                          VERA_DATA1        = $9F24
    19                          VERA_CTRL         = $9F25
    20                          VERA_IEN          = $9F26
    21                          VERA_ISR          = $9F27
    22                          VERA_IRQLINE_L    = $9F28
    23                          VERA_DC_VIDEO     = $9F29
    24                          VERA_DC_HSCALE    = $9F2A
    25                          VERA_DC_VSCALE    = $9F2B
    26                          VERA_DC_BORDER    = $9F2C
    27                          VERA_DC_HSTART    = $9F29
    28                          VERA_DC_HSTOP     = $9F2A
    29                          VERA_DC_VSTART    = $9F2B
    30                          VERA_DC_VSTOP     = $9F2C
    31                          VERA_L0_CONFIG    = $9F2D
    32                          VERA_L0_MAPBASE   = $9F2E
    33                          VERA_L0_TILEBASE  = $9F2F
    34                          VERA_L0_HSCROLL_L = $9F30
    35                          VERA_L0_HSCROLL_H = $9F31
    36                          VERA_L0_VSCROLL_L = $9F32
    37                          VERA_L0_VSCROLL_H = $9F33
    38                          VERA_L1_CONFIG    = $9F34
    39                          VERA_L1_MAPBASE   = $9F35
    40                          VERA_L1_TILEBASE  = $9F36
    41                          VERA_L1_HSCROLL_L = $9F37
    42                          VERA_L1_HSCROLL_H = $9F38
    43                          VERA_L1_VSCROLL_L = $9F39
    44                          VERA_L1_VSCROLL_H = $9F3A
    45                          VERA_AUDIO_CTRL   = $9F3B
    46                          VERA_AUDIO_RATE   = $9F3C
    47                          VERA_AUDIO_DATA   = $9F3D
    48                          VERA_SPI_DATA     = $9F3E
    49                          VERA_SPI_CTRL     = $9F3F
    50                          
    51                          ; ADDRx_H increments
    52                          ; -----------------------------------------------------------------------------
    53                          VERA_INCR_0   = $00
    54                          VERA_INCR_1   = $10
    55                          VERA_INCR_2   = $20
    56                          VERA_INCR_4   = $30
    57                          VERA_INCR_8   = $40
    58                          VERA_INCR_16  = $50
    59                          VERA_INCR_32  = $60
    60                          VERA_INCR_64  = $70
    61                          VERA_INCR_128 = $80
    62                          VERA_INCR_256 = $90
    63                          VERA_INCR_512 = $A0
    64                          VERA_INCR_40  = $B0
    65                          VERA_INCR_80  = $C0
    66                          VERA_INCR_160 = $D0
    67                          VERA_INCR_320 = $E0
    68                          VERA_INCR_640 = $F0
    69                          
    70                          VERA_DECR     = $08
    71                          
    72                          
    73                          ; Interrupts
    74                          ; -----------------------------------------------------------------------------
    75                          VERA_IEN_VSYNC  = $01
    76                          VERA_IEN_LINE   = $02
    77                          VERA_IEN_SPRCOL = $04
    78                          VERA_IEN_AFLOW  = $08
    79                          
    80                          
    81                          ; DC_VIDEO
    82                          ; -----------------------------------------------------------------------------
    83                          VERA_VIDEO_SPRITES_ENABLED  = $40
    84                          VERA_VIDEO_LAYER1_ENABLED   = $20
    85                          VERA_VIDEO_LAYER0_ENABLED   = $10
    86                          VERA_VIDEO_OUTPUT_DISABLED  = $00
    87                          VERA_VIDEO_OUTPUT_VGA       = $01
    88                          VERA_VIDEO_OUTPUT_NTSC      = $02
    89                          VERA_VIDEO_OUTPUT_RGB       = $03
    90                          
    91                          ; DC_SCALE
    92                          ; -----------------------------------------------------------------------------
    93                          VERA_SCALE_1x               = $80
    94                          VERA_SCALE_2x               = $40
    95                          VERA_SCALE_4x               = $20
    96                          
    97                          ; Lx_CONFIG
    98                          ; -----------------------------------------------------------------------------
    99                          VERA_CONFIG_1BPP          = $0
   100                          VERA_CONFIG_2BPP          = $1
   101                          VERA_CONFIG_4BPP          = $2
   102                          VERA_CONFIG_8BPP          = $3
   103                          
   104                          VERA_CONFIG_BITMAP_MODE   = $4
   105                          
   106                          VERA_CONFIG_MAP_WIDTH_32  = ($0 << 4)
   107                          VERA_CONFIG_MAP_WIDTH_64  = ($1 << 4)
   108                          VERA_CONFIG_MAP_WIDTH_128 = ($2 << 4)
   109                          VERA_CONFIG_MAP_WIDTH_256 = ($3 << 4)
   110                          
   111                          VERA_CONFIG_MAP_HEIGHT_32  = ($0 << 6)
   112                          VERA_CONFIG_MAP_HEIGHT_64  = ($1 << 6)
   113                          VERA_CONFIG_MAP_HEIGHT_128 = ($2 << 6)
   114                          VERA_CONFIG_MAP_HEIGHT_256 = ($3 << 6)
   115                          
   116                          ; Lx_TILEBASE
   117                          ; -----------------------------------------------------------------------------
   118                          VERA_TILE_WIDTH_8   = $00
   119                          VERA_TILE_WIDTH_16  = $01
   120                          VERA_TILE_HEIGHT_8  = $00
   121                          VERA_TILE_HEIGHT_16 = $02
   122                          
   123                          ; Other Vera addresses
   124                          ; -----------------------------------------------------------------------------
   125                          VERA_PALETTE = $1FA00
   126                          VERA_SPRITES = $1FC00
   127                          
   128                          ; Sprites
   129                          ; -----------------------------------------------------------------------------
   130                          VERA_SPRITE_DISABLED  = $00 << 2
   131                          VERA_SPRITE_BELOW_L0  = $01 << 2
   132                          VERA_SPRITE_BELOW_L1  = $02 << 2
   133                          VERA_SPRITE_ABOVE_L1  = $03 << 2
   134                          VERA_SPRITE_HFLIP     = $01
   135                          VERA_SPRITE_VFLIP     = $02
   136                          VERA_SPRITE_WIDTH_8   = $00 << 4
   137                          VERA_SPRITE_WIDTH_16  = $01 << 4
   138                          VERA_SPRITE_WIDTH_32  = $02 << 4
   139                          VERA_SPRITE_WIDTH_64  = $03 << 4
   140                          VERA_SPRITE_HEIGHT_8  = $00 << 6
   141                          VERA_SPRITE_HEIGHT_16 = $01 << 6
   142                          VERA_SPRITE_HEIGHT_32 = $02 << 6
   143                          VERA_SPRITE_HEIGHT_64 = $03 << 6

; ******** Source: src\snake.asm
    56                          

; ******** Source: src\common\vera\macros.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Vera macros
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_MACROS_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; vset: set the address and incrment
    17                          ; -----------------------------------------------------------------------------
    18                          !macro vset .addr, increment {
    19                          	lda #<(.addr >> 16) | increment
    20                          	sta VERA_ADDRx_H
    21                          	lda #<(.addr >> 8)
    22                          	sta VERA_ADDRx_M
    23                          	lda #<(.addr)
    24                          	sta VERA_ADDRx_L
    25                          }
    26                          
    27                          !macro vset .addr {
    28                            +vset .addr, VERA_INCR_1
    29                          }
    30                          
    31                          ; -----------------------------------------------------------------------------
    32                          ; vpush: push vera address from stack
    33                          ; -----------------------------------------------------------------------------
    34                          !macro vpush {
    35                            lda VERA_ADDRx_H
    36                            pha
    37                            lda VERA_ADDRx_M
    38                            pha
    39                            lda VERA_ADDRx_L
    40                            pha
    41                            lda VERA_CTRL
    42                            pha
    43                          }
    44                          
    45                          ; -----------------------------------------------------------------------------
    46                          ; vpop: pop vera address from stack
    47                          ; -----------------------------------------------------------------------------
    48                          !macro vpop {
    49                            pla
    50                            sta VERA_CTRL
    51                            pla
    52                            sta VERA_ADDRx_L
    53                            pla
    54                            sta VERA_ADDRx_M
    55                            pla
    56                            sta VERA_ADDRx_H
    57                          }
    58                          
    59                          
    60                          ; -----------------------------------------------------------------------------
    61                          ; vchannel: set the current vera channel
    62                          ; -----------------------------------------------------------------------------
    63                          !macro vchannel .channel {
    64                            +vreg VERA_CTRL, .channel 
    65                          }
    66                          
    67                          !macro vchannel0 {
    68                            +vchannel $00 
    69                          }
    70                          
    71                          !macro vchannel1 {
    72                            +vchannel $01 
    73                          }
    74                          
    75                          
    76                          ; -----------------------------------------------------------------------------
    77                          ; vReadByte: read a byte from vram
    78                          ; -----------------------------------------------------------------------------
    79                          !macro vReadByte0 .addr {
    80                          	+vset .addr
    81                          	lda VERA_DATA0
    82                          }
    83                          
    84                          !macro vReadByte1 .addr {
    85                          	+vset .addr
    86                          	lda VERA_DATA1
    87                          }
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; vreg16: write an 8-bit value to vram
    91                          ; -----------------------------------------------------------------------------
    92                          !macro vreg register, value {
    93                            lda #value
    94                            sta register
    95                          }
    96                          
    97                          !macro vWriteByte0 value {
    98                            +vreg VERA_DATA0, value
    99                          }
   100                          
   101                          !macro vWriteByte1 value {
   102                            +vreg VERA_DATA1, value
   103                          }
   104                          
   105                          ; -----------------------------------------------------------------------------
   106                          ; vreg16: write a 16-bit value to vram
   107                          ; -----------------------------------------------------------------------------
   108                          !macro vreg16 register, value {
   109                            lda #<value
   110                            sta register
   111                            lda #>value
   112                            sta register
   113                          }
   114                          
   115                          !macro vWriteWord0 value {
   116                            +vreg16 VERA_DATA0, value
   117                          }
   118                          
   119                          !macro vWriteWord1 value {
   120                            +vreg16 VERA_DATA1, value
   121                          }
   122                          
   123                          ; -----------------------------------------------------------------------------
   124                          ; vClear: clear a range of vram (set to zeros)
   125                          ; -----------------------------------------------------------------------------
   126                          ; start:  start address
   127                          ; length: length in bytes to clear
   128                          ; -----------------------------------------------------------------------------
   129                          !macro vClear start, length {
   130                            +vset start
   131                          
   132                            ldx #<length
   133                            ldy #>length
   134                            lda #0
   135                          
   136                          -
   137                            sta VERA_DATA0
   138                            dex
   139                            bne -
   140                            dey
   141                            bne -
   142                          }
   143                          
   144                          ; -----------------------------------------------------------------------------
   145                          ; vLoadRaw:   helper to load a file into vram
   146                          ; -----------------------------------------------------------------------------
   147                          ; filename:   zero-terminated string
   148                          ; vramArress: address to load the raw data
   149                          ; -----------------------------------------------------------------------------
   150                          !macro vLoadRaw filename, vramAddress {
   151                            +vset vramAddress
   152                          
   153                            ldx #<filename
   154                            ldy #>filename
   155                            jsr strLen
   156                          
   157                            jsr loadRaw
   158                          }
   159                          
   160                          ; -----------------------------------------------------------------------------
   161                          ; vLoadRaw:   helper to load an audio file into vram
   162                          ; -----------------------------------------------------------------------------
   163                          ; filename:   zero-terminated string
   164                          ; vramArress: address to load the raw data
   165                          ; -----------------------------------------------------------------------------
   166                          !macro vLoadAudio filename {
   167                          
   168                            ldx #<filename
   169                            ldy #>filename
   170                            jsr strLen
   171                          
   172                            jsr loadRawPCM
   173                          }
   174                          
   175                          
   176                          ; -----------------------------------------------------------------------------
   177                          ; filename:   zero-terminated string
   178                          ; vramArress: address to load the pixel data
   179                          ; palIndex:  0-15 - high nibble of palette address offset
   180                          ; -----------------------------------------------------------------------------
   181                          !macro vLoadPcx filename, vramAddress, palIndex {
   182                          
   183                            !if palIndex > 15 {
   184                              !error "Invalid palette index: ", palIndex, ". Must be between 0 and 15"
   185                            }
   186                            
   187                            +vchannel1
   188                            
   189                            +vset VERA_PALETTE + (palIndex << 5)
   190                            +vchannel0
   191                            +vset vramAddress
   192                          
   193                            ldx #<filename
   194                            ldy #>filename
   195                            jsr strLen
   196                            
   197                            jsr loadPcxFile
   198                          }
   199                          ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    57                          

; ******** Source: src\common\vera\vera.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA helper subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_ASM_ = 1
    15                          
    16                          
    17                          !zone vera {
    18                          
    19                          ; -----------------------------------------------------------------------------
    20                          ; loadRaw: load raw data file into VRAM
    21                          ; -----------------------------------------------------------------------------
    22                          ; xy contains address of filename
    23                          ; vera already configured:
    24                          ;   channel 0 for data
    25                          ; -----------------------------------------------------------------------------
    26                          loadRaw:
    27                          TMP_ADDR = $A000
    28  0942 20bdff               jsr SETNAM
    29                          
    30  0945 a901                 lda #$01
    31  0947 a208                 ldx #$08      ; default to device 8
    32  0949 a001                 ldy #$01      ; $00 means: load to new address
    33  094b 20baff               jsr SETLFS
    34                          
    35  094e a202                 ldx #<(TMP_ADDR + 2)
    36  0950 a0a0                 ldy #>(TMP_ADDR + 2)
    37  0952 a900                 lda #$00      ; $00 means: load to memory (not verify)
    38  0954 20d5ff               jsr LOAD
    39  0957 b026                 bcs .errorRaw    ; if carry set, a load error has happened
    40                          
    41  0959 8606                 stx R2L
    42  095b 8407                 sty R2H
    43                          
    44  095d a900                 lda #<TMP_ADDR
    45  095f 8504                 sta R1L
    46  0961 a9a0                 lda #>TMP_ADDR
    47  0963 8505                 sta R1H
    48                          
    49  0965 a000                 ldy #0
    50                          
    51                          .checkNextByteRaw:
    52  0967 a505                 lda R1H
    53  0969 c507                 cmp R2H
    54  096b d005                 bne +
    55  096d 98                   tya
    56  096e c506                 cmp R2L
    57  0970 f00c                 beq .doneRaw
    58                          +
    59  0972 b104                 lda (R1),y
    60  0974 8d239f               sta VERA_DATA0
    61  0977 c8                   iny
    62  0978 d002                 bne +
    63  097a e605                 inc R1H
    64                          +
    65  097c 80e9                 bra .checkNextByteRaw
    66                          .doneRaw
    67                          
    68  097e 60                   rts
    69                          .errorRaw
    70                          
    71  097f 60                   rts
    72                          
    73                          ; -----------------------------------------------------------------------------
    74                          ; loadRawPCM: load raw data file into VRAM
    75                          ; -----------------------------------------------------------------------------
    76                          ; xy contains address of filename
    77                          ; vera already configured:
    78                          ;   channel 0 for data
    79                          ; -----------------------------------------------------------------------------
    80                          loadRawPCM:
    81                          TMP_ADDR = $A000
    82  0980 20bdff               jsr SETNAM
    83                          
    84  0983 a901                 lda #$01
    85  0985 a208                 ldx #$08      ; default to device 8
    86  0987 a001                 ldy #$01      ; $00 means: load to new address
    87  0989 20baff               jsr SETLFS
    88                          
    89  098c a202                 ldx #<(TMP_ADDR + 2)
    90  098e a0a0                 ldy #>(TMP_ADDR + 2)
    91  0990 a900                 lda #$00      ; $00 means: load to memory (not verify)
    92  0992 20d5ff               jsr LOAD
    93  0995 b026                 bcs .errorPcm    ; if carry set, a load error has happened
    94                          
    95  0997 8606                 stx R2L
    96  0999 8407                 sty R2H
    97                          
    98  099b a900                 lda #<TMP_ADDR
    99  099d 8504                 sta R1L
   100  099f a9a0                 lda #>TMP_ADDR
   101  09a1 8505                 sta R1H
   102                          
   103  09a3 a000                 ldy #0
   104                          
   105                          .checkNextByte:
   106  09a5 a505                 lda R1H
   107  09a7 c507                 cmp R2H
   108  09a9 d005                 bne +
   109  09ab 98                   tya
   110  09ac c506                 cmp R2L
   111  09ae f00c                 beq .donePcm
   112                          +
   113  09b0 b104                 lda (R1),y
   114  09b2 8d3d9f               sta $9F3D
   115  09b5 c8                   iny
   116  09b6 d002                 bne +
   117  09b8 e605                 inc R1H
   118                          +
   119  09ba 80e9                 bra .checkNextByte
   120                          .donePcm
   121                          
   122  09bc 60                   rts
   123                          .errorPcm
   124                          
   125  09bd 60                   rts
   126                          

; ******** Source: src\snake.asm
    58                          

; ******** Source: src\common\vera\pcx.asm
     1                          ; Commander X16
     2                          ;
     3                          ; PCX file loader for Vera
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          
    13                          CMN_VERA_PCX_ = 1
    14                          
    15                          !zone pcxFile {
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; pcx constants
    19                          ; -----------------------------------------------------------------------------
    20                          
    21                          PCX_NUM_COLORS      = 16
    22                          PCX_PALETTE_OFFSET  = $10
    23                          PCX_PIXELS_OFFSET   = $80
    24                          PCX_REPEAT_FLAG     = $c0
    25                          PCX_REPEAT_CNT_MASK = $3f
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; loadPcxFile: load and decode a PCX file into VRAM
    29                          ; -----------------------------------------------------------------------------
    30                          ; xy contains address of filename
    31                          ; vera already configured:
    32                          ;   channel 0 for pixel data
    33                          ;   channel 1 for palette
    34                          ; -----------------------------------------------------------------------------
    35                          loadPcxFile:
    36                          TMP_ADDR = $A000
    37  09be 20bdff               jsr SETNAM
    38                          
    39  09c1 a901                 lda #$01
    40  09c3 a6ba                 ldx $BA       ; last used device number
    41  09c5 d002                 bne +
    42  09c7 a208                 ldx #$08      ; default to device 8
    43  09c9 a000               + ldy #$00      ; $00 means: load to new address
    44  09cb 20baff               jsr SETLFS
    45                          
    46  09ce a202                 ldx #<(TMP_ADDR + 2)
    47  09d0 a0a0                 ldy #>(TMP_ADDR + 2)
    48  09d2 a900                 lda #$00      ; $00 means: load to memory (not verify)
    49  09d4 20d5ff               jsr LOAD
    50  09d7 9002                 bcc .loadedOk ; if carry set, a load error has happened
    51                          
    52  09d9 00                   brk
    53                            ; load error?
    54  09da 60                   rts
    55                          
    56                          ; if we get this far, the file has loaded to TMP_ADDR
    57                          ; and x/y contains the address of the last byte read
    58                          .loadedOk:
    59                          
    60                            ; store pointer to the last byte
    61  09db 8606                 stx R2L
    62  09dd 8407                 sty R2H
    63                          
    64  09df a010                 ldy #PCX_PALETTE_OFFSET
    65  09e1 a210                 ldx #PCX_NUM_COLORS
    66                          
    67                          .nextColor:
    68  09e3 b900a0               lda TMP_ADDR, Y   ; load red, reduce to 4 bits and store in R0L
    69  09e6 4a                   lsr
    70  09e7 4a                   lsr
    71  09e8 4a                   lsr
    72  09e9 4a                   lsr
    73  09ea 8502                 sta R0L
    74  09ec c8                   iny
    75  09ed b900a0               lda TMP_ADDR, Y   ; load green, use high 4 bits and store in R0H
    76  09f0 29f0                 and #$f0
    77  09f2 8503                 sta R0H
    78  09f4 c8                   iny
    79  09f5 b900a0               lda TMP_ADDR, Y    ; load blue, reduce to 4 bits and combine with green
    80  09f8 4a                   lsr
    81  09f9 4a                   lsr
    82  09fa 4a                   lsr
    83  09fb 4a                   lsr
    84  09fc 0503                 ora R0H
    85  09fe 8d249f               sta VERA_DATA1   ; store GB byte in vram
    86  0a01 a502                 lda R0L
    87  0a03 8d249f               sta VERA_DATA1   ; store 0R byte in vram
    88  0a06 c8                   iny
    89  0a07 ca                   dex
    90  0a08 d0d9                 bne .nextColor
    91                            
    92  0a0a a900                 lda #<TMP_ADDR
    93  0a0c 8504                 sta R1L
    94  0a0e a9a0                 lda #>TMP_ADDR
    95  0a10 8505                 sta R1H
    96  0a12 a080                 ldy #PCX_PIXELS_OFFSET
    97                            
    98                          .checkNextPixel:
    99  0a14 a505                 lda R1H
   100  0a16 c507                 cmp R2H
   101  0a18 d005                 bne +
   102  0a1a 98                   tya
   103  0a1b c506                 cmp R2L
   104  0a1d f01f                 beq .done
   105                          
   106  0a1f a201               + ldx #1
   107  0a21 b104                 lda (R1),Y
   108  0a23 c9c0                 cmp #PCX_REPEAT_FLAG
   109  0a25 900a                 bcc .noSequence  ; if is >= c0 (high 2 bits are set), then we're a sequence
   110                          
   111                            ; is a sequence, so get the value and count
   112  0a27 293f                 and #PCX_REPEAT_CNT_MASK
   113  0a29 aa                   tax         ; store count in X
   114  0a2a c8                   iny
   115  0a2b d002                 bne +
   116  0a2d e605                 inc R1H
   117                          +
   118  0a2f b104                 lda (R1),Y
   119                           
   120                            ; not a sequence
   121                          .noSequence:
   122  0a31 8d239f               sta VERA_DATA0
   123  0a34 ca                   dex
   124  0a35 d0fa                 bne .noSequence
   125  0a37 c8                   iny
   126  0a38 d0da                 bne .checkNextPixel
   127  0a3a e605                 inc R1H
   128  0a3c 80d6                 bra .checkNextPixel
   129                          
   130                          .done
   131                          
   132  0a3e a901                 lda #$01
   133  0a40 20c3ff               jsr CLOSE
   134                          
   135  0a43 60                   rts
   136                          ; -----------------------------------------------------------------------------
   137                          

; ******** Source: src\snake.asm
    59                          

; ******** Source: src\common\vera\text.asm
     1                          ; Commander X16
     2                          ;
     3                          ; Raster text subroutines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          CMN_VERA_TEXT_ASM_ = 1
    14                          
    15                          ; -----------------------------------------------------------------------------
    16                          ; outputText: output a raster string to a vera bitmap
    17                          ; -----------------------------------------------------------------------------
    18                          ; vera:
    19                          ;   addr0 set to output location
    20                          ;   addr1 set to font location
    21                          ; inputs:
    22                          ;   X: string address LSB
    23                          ;   Y: string address MSB
    24                          ; -----------------------------------------------------------------------------
    25                          outputText:
    26  0a44 8e640a               stx .getChar + 1
    27  0a47 8c650a               sty .getChar + 2
    28                          
    29  0a4a a9008d259f           +vchannel0
    30  0a4f ad209f               lda VERA_ADDRx_L
    31  0a52 8502                 sta R0L
    32  0a54 ad219f               lda VERA_ADDRx_M
    33  0a57 8503                 sta R0H
    34                          
    35  0a59 a9018d259f           +vchannel1
    36  0a5e ad219f               lda VERA_ADDRx_M
    37  0a61 8505                 sta R1H
    38                          
    39                          .getChar
    40  0a63 adeeee               lda SELF_MODIFY_ADDR
    41  0a66 f04c                 beq .done
    42  0a68 38                   sec
    43  0a69 e920                 sbc #32
    44  0a6b 0a                   asl
    45  0a6c 0a                   asl
    46  0a6d 0a                   asl
    47  0a6e 2a                   rol
    48  0a6f 2a                   rol
    49  0a70 8504                 sta R1L
    50  0a72 2a                   rol
    51  0a73 291f                 and #$1f
    52  0a75 a8                   tay
    53  0a76 a9e0                 lda #$e0
    54  0a78 2504                 and R1L
    55  0a7a 8d209f               sta VERA_ADDRx_L
    56  0a7d 98                   tya
    57  0a7e 18                   clc
    58  0a7f 6505                 adc R1H
    59  0a81 8d219f               sta VERA_ADDRx_M
    60                          
    61  0a84 a9008d259f           +vchannel0
    62                          
    63  0a89 209e0b               jsr outputCharacter
    64                          
    65  0a8c a9008d259f           +vchannel0
    66                          
    67  0a91 a502                 lda R0L
    68  0a93 18                   clc
    69  0a94 6904                 adc #4
    70  0a96 8502                 sta R0L
    71  0a98 8d209f               sta VERA_ADDRx_L
    72  0a9b a503                 lda R0H
    73  0a9d 9001                 bcc +
    74  0a9f 1a                   inc 
    75                          +
    76  0aa0 8503                 sta R0H
    77  0aa2 8d219f               sta VERA_ADDRx_M
    78                          
    79  0aa5 ee640ad003ee650a     +inc16 .getChar + 1
    80                            
    81  0aad a9018d259f           +vchannel1
    82  0ab2 80af                 bra .getChar
    83                          
    84                          .done:
    85  0ab4 a9008d259f           +vchannel0
    86  0ab9 60                   rts
    87                          
    88                          
    89                          ; -----------------------------------------------------------------------------
    90                          ; output3BcdDigits: output 3 bcd digits in raster text
    91                          ; -----------------------------------------------------------------------------
    92                          ; vera:
    93                          ;   addr0 set to output location
    94                          ;   addr1 set to font location
    95                          ; inputs:
    96                          ;   x: first bcd digit
    97                          ;   a: 2x bcd digits
    98                          ; -----------------------------------------------------------------------------
    99                          output3BcdDigits:
   100  0aba 8502                 sta R0
   101  0abc a9008d259f           +vchannel0
   102  0ac1 ad229f48ad219f48...  +vpush
   103  0ad1 8a                   txa
   104  0ad2 20430b               jsr outputBcdChar
   105  0ad5 688d259f688d209f...  +vpop
   106  0ae5 ad239f               lda VERA_DATA0
   107  0ae8 ad239f               lda VERA_DATA0
   108  0aeb ad239f               lda VERA_DATA0
   109  0aee ad239f               lda VERA_DATA0
   110  0af1 ad229f48ad219f48...  +vpush
   111  0b01 a502                 lda R0
   112  0b03 8019                 bra .output2BcdDigitsLateEntry
   113                          
   114                          ; WARNING! FLOWS ON THROUGH HERE
   115                          
   116                          ; -----------------------------------------------------------------------------
   117                          ; output2BcdDigits: output 2 bcd digits in raster text
   118                          ; -----------------------------------------------------------------------------
   119                          ; vera:
   120                          ;   addr0 set to output location
   121                          ;   addr1 set to font location
   122                          ; inputs:
   123                          ;   a: 2x bcd digits
   124                          ; -----------------------------------------------------------------------------
   125                          output2BcdDigits:
   126  0b05 8502                 sta R0
   127  0b07 a9008d259f           +vchannel0 ; save output location
   128  0b0c ad229f48ad219f48...  +vpush
   129  0b1c a502                 lda R0
   130                          .output2BcdDigitsLateEntry:
   131  0b1e 4a                   lsr
   132  0b1f 4a                   lsr
   133  0b20 4a                   lsr
   134  0b21 4a                   lsr
   135  0b22 20430b               jsr outputBcdChar
   136  0b25 688d259f688d209f...  +vpop
   137  0b35 ad239f               lda VERA_DATA0
   138  0b38 ad239f               lda VERA_DATA0
   139  0b3b ad239f               lda VERA_DATA0
   140  0b3e ad239f               lda VERA_DATA0
   141  0b41 a502                 lda R0
   142                          
   143                          
   144                          ; WARNING! FLOWS ON THROUGH HERE
   145                          
   146                          ; -----------------------------------------------------------------------------
   147                          ; outputBcdChar: output a bcd digit in raster text
   148                          ; -----------------------------------------------------------------------------
   149                          ; vera:
   150                          ;   addr0 set to output location
   151                          ;   addr1 set to font location
   152                          ; inputs:
   153                          ;   a: 1x bcd digit in low nibble
   154                          ; -----------------------------------------------------------------------------
   155                          outputBcdChar:
   156  0b43 290f                 and #$0f
   157  0b45 8504                 sta R1L
   158  0b47 a9018d259f           +vchannel1
   159  0b4c ad229f48ad219f48...  +vpush
   160                            
   161  0b5c a504                 lda R1L
   162  0b5e 0910                 ora #$10 ; add 16
   163  0b60 0a                   asl
   164  0b61 0a                   asl
   165  0b62 0a                   asl
   166  0b63 0a                   asl
   167  0b64 2a                   rol
   168  0b65 8504                 sta R1L
   169  0b67 2a                   rol
   170  0b68 291f                 and #$1f
   171  0b6a a8                   tay
   172  0b6b a9e0                 lda #$e0
   173  0b6d 2504                 and R1L
   174  0b6f 8d209f               sta VERA_ADDRx_L
   175  0b72 98                   tya
   176  0b73 18                   clc
   177  0b74 6505                 adc R1H
   178  0b76 8d219f               sta VERA_ADDRx_M
   179                          
   180  0b79 a9008d259f           +vchannel0
   181                          
   182  0b7e 209e0b               jsr outputCharacter
   183                          
   184  0b81 688d259f688d209f...  +vpop
   185                          
   186  0b91 60                   rts
   187                          
   188                          ; -----------------------------------------------------------------------------
   189                          ; setPixelOperationNone: updates instruction in outputCharacter to nop
   190                          ; -----------------------------------------------------------------------------
   191                          setPixelOperationNone:
   192  0b92 a9ea                 lda #$ea ; nop
   193  0b94 8da80b               sta textPixelOperation
   194  0b97 60                   rts
   195                          
   196                          ; -----------------------------------------------------------------------------
   197                          ; setPixelOperationNone: updates instruction in outputCharacter to lsr
   198                          ; -----------------------------------------------------------------------------
   199                          setPixelOperationLSR:
   200  0b98 a90a                 lda #$0a ; lsr
   201  0b9a 8da80b               sta textPixelOperation
   202  0b9d 60                   rts
   203                          
   204                          
   205                          ; -----------------------------------------------------------------------------
   206                          ; outputCharacter: output a raster character
   207                          ; -----------------------------------------------------------------------------
   208                          ; vera:
   209                          ;   addr0 set to output location
   210                          ;   addr1 set to character tile location
   211                          ; -----------------------------------------------------------------------------
   212                          outputCharacter:
   213  0b9e 5a                   phy
   214  0b9f da                   phx
   215  0ba0 48                   pha
   216                          
   217  0ba1 a008                 ldy #8
   218                            
   219                          .nextRow: 
   220  0ba3 a204                 ldx #4 ; 4 bytes per row
   221                          
   222                          .nextCol:
   223  0ba5 ad249f               lda VERA_DATA1
   224                          textPixelOperation:
   225  0ba8 ea                   nop  ; operation which can be substituted
   226  0ba9 8d239f               sta VERA_DATA0
   227                          
   228  0bac ca                   dex
   229  0bad d0f6                 bne .nextCol
   230                          
   231  0baf 18                   clc
   232  0bb0 ad209f               lda VERA_ADDRx_L
   233  0bb3 699c                 adc #160 - 4 ; bytes per row, less our current offset
   234  0bb5 8d209f               sta VERA_ADDRx_L
   235  0bb8 9003                 bcc +
   236  0bba ee219f               inc VERA_ADDRx_M
   237                          +
   238  0bbd 88                   dey
   239  0bbe d0e3                 bne .nextRow
   240                          
   241  0bc0 68                   pla
   242  0bc1 fa                   plx
   243  0bc2 7a                   ply
   244                          

; ******** Source: src\snake.asm
    60  0bc3 60                 

; ******** Source: src\common\vera\vsync.asm
     1                          ; Commander X16
     2                          ;
     3                          ; VERA Vsync helpers
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          CMN_VERA_VSYNC_ASM_ = 1
    15                          
    16                          defaultIrqHandler:
    17  0bc4 0000               !word $0000
    18                          
    19                          VSYNC_FLAG = $30
    20                          
    21                          registerVsyncIrq:
    22  0bc6 ad1403                 lda $0314
    23  0bc9 8dc40b                 sta defaultIrqHandler
    24  0bcc ad1503                 lda $0315
    25  0bcf 8dc50b                 sta defaultIrqHandler + 1
    26                          
    27  0bd2 a9dd                   lda #<vSyncIrqhandler
    28  0bd4 8d1403                 sta $0314
    29  0bd7 a90b                   lda #>vSyncIrqhandler + 1
    30  0bd9 8d1503                 sta $0315
    31  0bdc 60                     rts
    32                          
    33                          vSyncIrqhandler:
    34  0bdd ad279f                 lda VERA_ISR
    35  0be0 2901                   and #VERA_IEN_VSYNC
    36  0be2 f002                   beq .irqDone
    37                          
    38                              ; Whatever code your program
    39                              ; wanted to execute...
    40  0be4 6430                   stz VSYNC_FLAG
    41                          
    42                              ; Return to whatever had been interrupted:
    43                          .irqDone:
    44  0be6 6cc40b                 jmp (defaultIrqHandler)

; ******** Source: src\snake.asm
    61                          
    62                          
    63                          

; ******** Source: src\rambank.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; RAM banks
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          
    12                          ; Central place to keep track of RAM banks used
    13                          
    14                          RAM_BANK_SCRATCH        = 0

; ******** Source: src\snake.asm
    64                          

; ******** Source: src\vram.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; VRAM addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          
    12                          
    13                          ; VERA memory map:
    14                          ; -----------------------------------------------------------------------------
    15                          ;  $0000      (0) -  $09FF   (4095) - (4,096 bytes) UNUSED
    16                          ;  $1A00   (4096) -  $19FF   (8191) - (64 x 32 x 2 = 4,096 bytes) map
    17                          ;  $2000   (8192) -  $3FFF  (16383) - (8,192 bytes) UNUSED
    18                          ;  $4000  (16384) -  $BFFF  (49151) - (16 x 16 x 128 = 32,768 bytes) L0 tiles
    19                          ;  $C000  (49152) - $155FF  (87551) - (320 x 240 / 2 = 38,400 bytes) L1 overlay
    20                          ; $15600  (87552) - $1F9BF (129471) - (41,920 bytes) UNUSED
    21                          ;
    22                          ; $1F9C0 - $1F9FF	PSG registers
    23                          ; $1FA00 - $1FBFF	Palette
    24                          ; $1FC00 - $1FFFF	Sprite attributes
    25                          ;
    26                          
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          ; VRAM addresses
    30                          ; -----------------------------------------------------------------------------
    31                          VRADDR_MAP_BASE       = $1000
    32                          VRADDR_TILE_BASE      = $4000
    33                          VRADDR_OVERLAY        = $C000

; ******** Source: src\snake.asm
    65                          

; ******** Source: src\zeropage.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Zero page addresses
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          ; Available locations
    15                          ; https://github.com/commanderx16/x16-docs/blob/master/Commander%20X16%20Programmer%27s%20Reference%20Guide.md#ram-contents
    16                          ;
    17                          ;   $00 - $7F (128 bytes) user zero page   
    18                          ;   $A9 - $FF (87 bytes)  if BASIC or FLOAT functions not used
    19                          ; 
    20                          ; Not available:
    21                          ;   $80 - $A8 (41 bytes)
    22                          
    23                          ; -----------------------------------------------------------------------------
    24                          
    25                          ; $00 - $01 ??
    26                          ; $02 - $21 Virtual registers (R0 -> R15)
    27                          
    28                          ; -----------------------------------------------------------------------------
    29                          
    30                          ;
    31                          ; $22 - $2f unused
    32                          ;
    33                          
    34                          ZP_CURRENT_CELL_X        = $30
    35                          ZP_CURRENT_CELL_Y        = $31
    36                          
    37                          ZP_CURRENT_PALETTE       = $32
    38                          
    39                          ZP_CURRENT_DIRECTION     = $33
    40                          
    41                          ZP_HEAD_CELL_X           = $34
    42                          ZP_HEAD_CELL_Y           = $35
    43                          
    44                          ZP_ANIM_INDEX            = $36
    45                          ZP_RANDOM                = $37
    46                          
    47                          ZP_APPLE_CELL_X          = $38
    48                          ZP_APPLE_CELL_Y          = $39
    49                          ZP_FRAME_INDEX           = $3A
    50                          
    51                          ZP_QUEUE_X_INDEX         = $40
    52                          ZP_QUEUE_X               = $41
    53                          ZP_QUEUE_X_LSB           = ZP_QUEUE_X
    54                          ZP_QUEUE_X_MSB           = ZP_QUEUE_X + 1
    55                          
    56                          ZP_QUEUE_Y_INDEX         = $43
    57                          ZP_QUEUE_Y               = $44
    58                          ZP_QUEUE_Y_LSB           = ZP_QUEUE_Y
    59                          ZP_QUEUE_Y_MSB           = ZP_QUEUE_Y + 1
    60                          
    61                          ZP_QUEUE_D_INDEX         = $46
    62                          ZP_QUEUE_D               = $47
    63                          ZP_QUEUE_D_LSB           = ZP_QUEUE_D
    64                          ZP_QUEUE_D_MSB           = ZP_QUEUE_D + 1
    65                          
    66                          
    67                          ;
    68                          ; $35 - $7f unused
    69                          ;
    70                          
    71                          ; -----------------------------------------------------------------------------
    72                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    73                          ;  \ \ \ \ \ \ \ \ \ \ \ \ $80 - $A8: not available  \ \ \ \ \ \ \ \ \ \ \ \ \
    74                          ; \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    75                          ; -----------------------------------------------------------------------------
    76                          
    77                          
    78                          ;
    79                          ; $a9 - $ff unused
    80                          ;

; ******** Source: src\snake.asm
    66                          

; ******** Source: src\display.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Display routines
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_DISPLAY_ASM_ = 1
    15                          
    16                          DISPLAY_SIZE_X  = 640
    17                          DISPLAY_SIZE_Y  = 480
    18                          
    19                          DISPLAY_BYTES_PER_ROW = DISPLAY_SIZE_X / 2
    20                          
    21                          BOTTOM_PANEL_SIZE_Y  = 24
    22                          VISIBLE_AREA_X       = DISPLAY_SIZE_X
    23                          VISIBLE_AREA_Y       = DISPLAY_SIZE_Y - BOTTOM_PANEL_SIZE_Y
    24                          VISIBLE_AREA_CX      = VISIBLE_AREA_X / 2
    25                          VISIBLE_AREA_CY      = VISIBLE_AREA_Y / 2
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; disable the display
    29                          ; -----------------------------------------------------------------------------
    30                          disableDisplay:
    31  0be9 a9018d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_OUTPUT_VGA
    32  0bee 60                   rts
    33                          
    34                          ; -----------------------------------------------------------------------------
    35                          ; configure the display
    36                          ; -----------------------------------------------------------------------------
    37                          configDisplay:
    38                          
    39                            ; set up layer 0 to hold our map tiles
    40  0bef a9088d2e9f           +vreg VERA_L0_MAPBASE, VRADDR_MAP_BASE >> 9
    41  0bf4 a9238d2f9f           +vreg VERA_L0_TILEBASE, (VRADDR_TILE_BASE >> 9) | VERA_TILE_WIDTH_16 | VERA_TILE_HEIGHT_16
    42  0bf9 a9128d2d9f           +vreg VERA_L0_CONFIG, VERA_CONFIG_MAP_WIDTH_64 | VERA_CONFIG_MAP_HEIGHT_32 | VERA_CONFIG_4BPP
    43                            ;+vreg VERA_L0_HSCROLL_H, 1
    44                          
    45                            ; layer 1 to hold our hud/ui
    46                            ;+vreg VERA_L1_TILEBASE, (VRADDR_OVERLAY >> 9)
    47                            ;+vreg VERA_L1_CONFIG, VERA_CONFIG_BITMAP_MODE | VERA_CONFIG_4BPP
    48                            ;+vreg VERA_L1_HSCROLL_H, OVERLAY_PAL
    49                          
    50                            ; other display settings
    51                          ;  +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_LAYER1_ENABLED | VERA_VIDEO_OUTPUT_VGA
    52  0bfe a9118d299f           +vreg VERA_DC_VIDEO, VERA_VIDEO_LAYER0_ENABLED | VERA_VIDEO_OUTPUT_VGA
    53  0c03 a9808d2a9f           +vreg VERA_DC_HSCALE, VERA_SCALE_1x
    54  0c08 a9808d2b9f           +vreg VERA_DC_VSCALE, VERA_SCALE_1x
    55  0c0d a9018d269f           +vreg VERA_IEN, VERA_IEN_VSYNC
    56  0c12 a9018d279f           +vreg VERA_ISR, VERA_IEN_VSYNC
    57                            
    58  0c17 60                   rts
    59                            
    60                            ; -----------------------------------------------------------------------------

; ******** Source: src\snake.asm
    67                          

; ******** Source: src\tiles.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Tile definitions
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/supaplex-x16
    10                          ;
    11                          ;
    12                          
    13                          
    14                          TILE_SIZE         = 16
    15                          HALF_TILE_SIZE    = TILE_SIZE / 2
    16                          TILE_SIZE_BYTES   = 16 * 16 / 2  ; 16 x 16 x 4bpp
    17                          
    18  0c18 736e616b652e7063...snakePcx:   !text "snake.pcx",0
    19  0c22 6170706c652e7063...applePcx:   !text "apple.pcx",0
    20                          
    21                          ; -----------------------------------------------------------------------------
    22                          ; tileset addresses
    23                          ; -----------------------------------------------------------------------------
    24                          SNAKE_ADDR = VRADDR_TILE_BASE
    25                          APPLE_ADDR = SNAKE_ADDR + (96 * 128)
    26                          
    27                          ; -----------------------------------------------------------------------------
    28                          ; palette indexes
    29                          ; -----------------------------------------------------------------------------
    30                          SNAKE_PAL_ODD    = 2
    31                          SNAKE_PAL_EVEN   = 3
    32                          APPLE_PAL_ODD    = 4
    33                          APPLE_PAL_EVEN   = 5
    34                          
    35                          SNAKE_PAL = SNAKE_PAL_ODD
    36                          APPLE_PAL = APPLE_PAL_ODD
    37                          
    38                          ; -----------------------------------------------------------------------------
    39                          ; tile flags
    40                          ; -----------------------------------------------------------------------------
    41                          TILE_FLIP_H = $04
    42                          TILE_FLIP_V = $08
    43                          
    44                          
    45                          !macro ldaTileId tileAddress { lda #(tileAddress - tileTable) >> 3 }
    46                          !macro cmpTileId tileAddress { cmp #(tileAddress - tileTable) >> 3 }
    47                          !macro byteTileId tileAddress { !byte (tileAddress - tileTable) >> 3 }
    48                          
    49                          ; -----------------------------------------------------------------------------
    50                          ; load the tiles from disk into vram
    51                          ; -----------------------------------------------------------------------------
    52                          loadTiles:
    53  0c2c a9008d619f           +setRamBank RAM_BANK_SCRATCH
    54  0c31 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_ODD
    55  0c63 a9018d259fa9118d...  +vLoadPcx snakePcx,  SNAKE_ADDR, SNAKE_PAL_EVEN
    56  0c95 a9018d259fa9118d...  +vLoadPcx applePcx,  APPLE_ADDR, APPLE_PAL_ODD
    57  0cc7 a9018d259fa9118d...  +vLoadPcx applePcx,  APPLE_ADDR, APPLE_PAL_EVEN
    58                            
    59  0cf9 a9118d229fa9fa8d...  +vset VERA_PALETTE + (SNAKE_PAL_EVEN << 5) + 30
    60  0d08 a9d3                 lda #$d3
    61  0d0a 8d239f               sta VERA_DATA0
    62  0d0d a908                 lda #$08
    63  0d0f 8d239f               sta VERA_DATA0
    64                          
    65  0d12 a9118d229fa9fa8d...  +vset VERA_PALETTE + (APPLE_PAL_EVEN << 5) + 30
    66  0d21 a9d3                 lda #$d3
    67  0d23 8d239f               sta VERA_DATA0
    68  0d26 a908                 lda #$08
    69  0d28 8d239f               sta VERA_DATA0
    70                          
    71  0d2b a9108d229fa9108d...  +vset VRADDR_MAP_BASE
    72                          
    73  0d3a a01f                 ldy #31
    74                          --
    75  0d3c a23f                 ldx #63
    76                          -
    77  0d3e 8630                 stx ZP_CURRENT_CELL_X
    78  0d40 8431                 sty ZP_CURRENT_CELL_Y
    79  0d42 20c70d               jsr setCellVram
    80  0d45 a960                 +ldaTileId tileBlank
    81  0d47 20e60d               jsr outputTile
    82  0d4a ca                   dex
    83  0d4b 10f1                 bpl -
    84  0d4d 88                   dey
    85  0d4e 10ec                 bpl --
    86                          
    87  0d50 6441                 stz ZP_QUEUE_X_LSB
    88  0d52 20b30886408542       +qCreate ZP_QUEUE_X_INDEX, ZP_QUEUE_X_MSB
    89  0d59 6444                 stz ZP_QUEUE_Y_LSB
    90  0d5b 20b30886438545       +qCreate ZP_QUEUE_Y_INDEX, ZP_QUEUE_Y_MSB
    91  0d62 6447                 stz ZP_QUEUE_D_LSB
    92  0d64 20b30886468548       +qCreate ZP_QUEUE_D_INDEX, ZP_QUEUE_D_MSB
    93                          
    94  0d6b a900                 lda #0
    95  0d6d a64020ca08           +qPush ZP_QUEUE_X_INDEX
    96  0d72 1a                   inc
    97  0d73 a64020ca08           +qPush ZP_QUEUE_X_INDEX
    98  0d78 1a                   inc
    99  0d79 a64020ca08           +qPush ZP_QUEUE_X_INDEX
   100  0d7e 1a                   inc
   101  0d7f a64020ca08           +qPush ZP_QUEUE_X_INDEX
   102  0d84 8534                 sta ZP_HEAD_CELL_X
   103                          
   104  0d86 a907                 lda #7
   105  0d88 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   106  0d8d a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   107  0d92 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   108  0d97 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   109  0d9c 8535                 sta ZP_HEAD_CELL_Y
   110                          
   111  0d9e a90f                 lda #DIR_RIGHT << 2 | DIR_RIGHT
   112  0da0 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   113  0da5 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   114  0daa a64620ca08           +qPush ZP_QUEUE_D_INDEX
   115  0daf a64620ca08           +qPush ZP_QUEUE_D_INDEX
   116                          
   117  0db4 a90d                 lda #13
   118  0db6 8538                 sta ZP_APPLE_CELL_X
   119  0db8 a904                 lda #4
   120  0dba 8539                 sta ZP_APPLE_CELL_Y
   121                          
   122                          
   123  0dbc a903                 lda #DIR_RIGHT
   124  0dbe 8533                 sta ZP_CURRENT_DIRECTION
   125                          
   126  0dc0 a901                 lda #1
   127  0dc2 8536                 sta ZP_ANIM_INDEX
   128                          
   129  0dc4 643a                 stz ZP_FRAME_INDEX
   130                          
   131  0dc6 60                   rts
   132                          
   133                          
   134                          setCellVram:
   135  0dc7 a530                 lda ZP_CURRENT_CELL_X
   136  0dc9 0a                   asl
   137  0dca 0a                   asl
   138  0dcb 8d209f             	sta VERA_ADDRx_L
   139                          
   140  0dce a910               	lda #<(VRADDR_MAP_BASE >> 8)
   141  0dd0 18                   clc
   142  0dd1 6531                 adc ZP_CURRENT_CELL_Y
   143  0dd3 8d219f             	sta VERA_ADDRx_M
   144                          
   145  0dd6 18                   clc
   146  0dd7 6432                 stz ZP_CURRENT_PALETTE
   147  0dd9 a530                 lda ZP_CURRENT_CELL_X
   148  0ddb 6531                 adc ZP_CURRENT_CELL_Y
   149  0ddd 8901                 bit #1
   150  0ddf f004                 beq +
   151  0de1 a910                 lda #16
   152  0de3 8532                 sta ZP_CURRENT_PALETTE
   153                          +
   154                          
   155  0de5 60                   rts
   156                          
   157                          
   158                          
   159                          !macro outputTile startOffset {
   160                            lda startOffset, y
   161                            sta VERA_DATA0  
   162                            lda startOffset + 1, y  
   163                            ora ZP_CURRENT_PALETTE
   164                            sta VERA_DATA0
   165                            lda startOffset + 2, y
   166                            sta VERA_DATA0  
   167                            lda startOffset + 3, y
   168                            ora ZP_CURRENT_PALETTE
   169                            sta VERA_DATA0
   170                            clc
   171                            lda VERA_ADDRx_L
   172                            adc #124
   173                            sta VERA_ADDRx_L
   174                            lda startOffset + 4, y
   175                            sta VERA_DATA0  
   176                            lda startOffset + 5, y
   177                            ora ZP_CURRENT_PALETTE
   178                            sta VERA_DATA0
   179                            lda startOffset + 6, y
   180                            sta VERA_DATA0  
   181                            lda startOffset + 7, y
   182                            ora ZP_CURRENT_PALETTE
   183                            sta VERA_DATA0
   184                          }
   185                          
   186                          
   187                          DIR_UP    = $0
   188                          DIR_LEFT  = $1
   189                          DIR_DOWN  = $2
   190                          DIR_RIGHT = $3
   191                          
   192                          
   193                          ; -----------------------------------------------------------------------------
   194                          ; outputTile
   195                          ; -----------------------------------------------------------------------------
   196                          ; Inputs:
   197                          ;  a: tileId
   198                          ;
   199                          ; Prerequisites:
   200                          ;  VERA address already set
   201                          ; -----------------------------------------------------------------------------
   202                          outputTile:
   203  0de6 5a                   phy
   204  0de7 0a                   asl ; 2x
   205  0de8 0a                   asl ; 4x
   206  0de9 9047                 bcc .doFirstHalf
   207  0deb 0a                   asl ; 8x
   208  0dec a8                   tay
   209  0ded 9045                 bcc .thirdQuarter
   210  0def b900138d239fb901...  +outputTile tileTable + $300
   211  0e30 7a                   ply
   212  0e31 60                   rts
   213                          
   214                          .doFirstHalf:
   215  0e32 8043                 bra .firstHalf
   216                          
   217                          .thirdQuarter
   218  0e34 b900128d239fb901...  +outputTile tileTable + $200
   219  0e75 7a                   ply
   220  0e76 60                   rts
   221                          
   222                          .firstHalf:
   223  0e77 0a                   asl ; 8x
   224  0e78 a8                   tay
   225  0e79 9043                 bcc .firstQuarter
   226  0e7b b900118d239fb901...  +outputTile tileTable + $100
   227  0ebc 7a                   ply
   228  0ebd 60                   rts
   229                          
   230                          .firstQuarter
   231  0ebe b900108d239fb901...  +outputTile tileTable
   232  0eff 7a                   ply
   233  0f00 60                   rts
   234                          ; -----------------------------------------------------------------------------
   235                          
   236                          
   237                          ; -----------------------------------------------------------------------------
   238                          ; tile definitions (32 x 32 tiles built from 16 x 16 bitmaps)
   239                          ; -----------------------------------------------------------------------------
   240                          ; 8 bytes per tile in the VERA tile format:
   241                          ;
   242                          ; Offset	Bit 7	Bit 6	Bit 5	Bit 4	Bit 3	Bit 2	Bit 1	Bit 0
   243                          ; 0	        [ Tile index (7:0)                                            ]
   244                          ; 1	        [ Palette offset              ][V-flip][H-flip][Tile index 9:8]
   245                          ;
   246                          ; -----------------------------------------------------------------------------
   247                          !macro tileDef index, tilesetAddr, tileOffsetUL, tileOffsetUR, tileOffsetBL, tileOffsetBR, tilePalette, tileFlags {
   248                              
   249                              .tilesetOffset = (tilesetAddr - VRADDR_TILE_BASE) / TILE_SIZE_BYTES
   250                          
   251                              ; tile offset
   252                              .tileOffsetUL    = .tilesetOffset + tileOffsetUL
   253                              .tileOffsetUR    = .tilesetOffset + tileOffsetUR
   254                              .tileOffsetBL    = .tilesetOffset + tileOffsetBL
   255                              .tileOffsetBR    = .tilesetOffset + tileOffsetBR
   256                          
   257                              ; tile index (7:0)
   258                              !byte .tileOffsetUL & $ff
   259                              ; palette offset (7:4), flags, tile offset (9:8)
   260                              !byte (tilePalette << 4) | tileFlags | (.tileOffsetUL >> 8)
   261                          
   262                              !byte .tileOffsetUR & $ff
   263                              !byte (tilePalette << 4) | tileFlags | (.tileOffsetUR >> 8)
   264                              !byte .tileOffsetBL & $ff
   265                              !byte (tilePalette << 4) | tileFlags | (.tileOffsetBL >> 8)
   266                              !byte .tileOffsetBR & $ff
   267                              !byte (tilePalette << 4) | tileFlags | (.tileOffsetBR >> 8)
   268                          }
   269                          
   270  0f01 eaeaeaeaeaeaeaea...!align 255,0
   271                          tileTable:
   272  1000 6040614062406340   tileApple0:  +tileDef  0, APPLE_ADDR,  0,  1,  2,  3,  APPLE_PAL, 0              
   273  1008 6440654066406740   tileApple1:  +tileDef  1, APPLE_ADDR,  4,  5,  6,  7,  APPLE_PAL, 0              
   274  1010 684069406a406b40   tileApple2:  +tileDef  2, APPLE_ADDR,  8,  9, 10, 11,  APPLE_PAL, 0              
   275  1018 6c406d406e406f40   tileApple3:  +tileDef  3, APPLE_ADDR, 12, 13, 14, 15,  APPLE_PAL, 0              
   276  1020 6c406d406e406f40   tileApple4:  +tileDef  4, APPLE_ADDR, 12, 13, 14, 15,  APPLE_PAL, 0              
   277  1028 684069406a406b40   tileApple5:  +tileDef  5, APPLE_ADDR,  8,  9, 10, 11,  APPLE_PAL, 0              
   278  1030 6440654066406740   tileApple6:  +tileDef  6, APPLE_ADDR,  4,  5,  6,  7,  APPLE_PAL, 0              
   279  1038 6040614062406340   tileApple7:  +tileDef  7, APPLE_ADDR,  0,  1,  2,  3,  APPLE_PAL, 0              
   280                          
   281  1040 3420352036203720   +tileDef  8, SNAKE_ADDR, 52, 53, 54, 55, SNAKE_PAL, 0
   282  1048 3620372034203520   +tileDef  9, SNAKE_ADDR, 54, 55, 52, 53, SNAKE_PAL, 0
   283  1050 4e284f284c284d28   +tileDef  10, SNAKE_ADDR, 78, 79, 76, 77, SNAKE_PAL, TILE_FLIP_V
   284  1058 1c201d201e201f20   +tileDef  11, SNAKE_ADDR, 28, 29, 30, 31, SNAKE_PAL, 0
   285  1060 4f2c4e2c4d2c4c2c   +tileDef  12, SNAKE_ADDR, 79, 78, 77, 76, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   286  1068 1d241c241f241e24   +tileDef  13, SNAKE_ADDR, 29, 28, 31, 30, SNAKE_PAL, TILE_FLIP_H
   287  1070 0420052006200720   +tileDef  14, SNAKE_ADDR, 4, 5, 6, 7, SNAKE_PAL, 0
   288  1078 0520042007200620   +tileDef  15, SNAKE_ADDR, 5, 4, 7, 6, SNAKE_PAL, 0
   289  1080 1f2c1e2c1d2c1c2c   +tileDef  16, SNAKE_ADDR, 31, 30, 29, 28, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   290  1088 4d244c244f244e24   +tileDef  17, SNAKE_ADDR, 77, 76, 79, 78, SNAKE_PAL, TILE_FLIP_H
   291  1090 1d241c241f241e24   +tileDef  18, SNAKE_ADDR, 29, 28, 31, 30, SNAKE_PAL, TILE_FLIP_H
   292  1098 4f2c4e2c4d2c4c2c   +tileDef  19, SNAKE_ADDR, 79, 78, 77, 76, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   293  10a0 072c062c052c042c   +tileDef  20, SNAKE_ADDR, 7, 6, 5, 4, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   294  10a8 062c072c042c052c   +tileDef  21, SNAKE_ADDR, 6, 7, 4, 5, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   295  10b0 1e281f281c281d28   +tileDef  22, SNAKE_ADDR, 30, 31, 28, 29, SNAKE_PAL, TILE_FLIP_V
   296  10b8 4c204d204e204f20   +tileDef  23, SNAKE_ADDR, 76, 77, 78, 79, SNAKE_PAL, 0
   297  10c0 1c201d201e201f20   +tileDef  24, SNAKE_ADDR, 28, 29, 30, 31, SNAKE_PAL, 0
   298  10c8 4e284f284c284d28   +tileDef  25, SNAKE_ADDR, 78, 79, 76, 77, SNAKE_PAL, TILE_FLIP_V
   299  10d0 372c362c352c342c   +tileDef  26, SNAKE_ADDR, 55, 54, 53, 52, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   300  10d8 352c342c372c362c   +tileDef  27, SNAKE_ADDR, 53, 52, 55, 54, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   301  10e0 4c204d204e204f20   +tileDef  28, SNAKE_ADDR, 76, 77, 78, 79, SNAKE_PAL, 0
   302  10e8 1e281f281c281d28   +tileDef  29, SNAKE_ADDR, 30, 31, 28, 29, SNAKE_PAL, TILE_FLIP_V
   303  10f0 4d244c244f244e24   +tileDef  30, SNAKE_ADDR, 77, 76, 79, 78, SNAKE_PAL, TILE_FLIP_H
   304  10f8 1f2c1e2c1d2c1c2c   +tileDef  31, SNAKE_ADDR, 31, 30, 29, 28, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   305  1100 3620372030203120   +tileDef  32, SNAKE_ADDR, 54, 55, 48, 49, SNAKE_PAL, 0
   306  1108 3020312032203320   +tileDef  33, SNAKE_ADDR, 48, 49, 50, 51, SNAKE_PAL, 0
   307  1110 1628172814281528   +tileDef  34, SNAKE_ADDR, 22, 23, 20, 21, SNAKE_PAL, TILE_FLIP_V
   308  1118 0e280f280c280d28   +tileDef  35, SNAKE_ADDR, 14, 15, 12, 13, SNAKE_PAL, TILE_FLIP_V
   309  1120 172c162c152c142c   +tileDef  36, SNAKE_ADDR, 23, 22, 21, 20, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   310  1128 0f2c0e2c0d2c0c2c   +tileDef  37, SNAKE_ADDR, 15, 14, 13, 12, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   311  1130 0120042003200620   +tileDef  38, SNAKE_ADDR, 1, 4, 3, 6, SNAKE_PAL, 0
   312  1138 0020012002200320   +tileDef  39, SNAKE_ADDR, 0, 1, 2, 3, SNAKE_PAL, 0
   313  1140 4420452046204720   +tileDef  40, SNAKE_ADDR, 68, 69, 70, 71, SNAKE_PAL, 0
   314  1148 3c203d203e203f20   +tileDef  41, SNAKE_ADDR, 60, 61, 62, 63, SNAKE_PAL, 0
   315  1150 4628472844284528   +tileDef  42, SNAKE_ADDR, 70, 71, 68, 69, SNAKE_PAL, TILE_FLIP_V
   316  1158 3e283f283c283d28   +tileDef  43, SNAKE_ADDR, 62, 63, 60, 61, SNAKE_PAL, TILE_FLIP_V
   317  1160 072c032c052c012c   +tileDef  44, SNAKE_ADDR, 7, 3, 5, 1, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   318  1168 032c022c012c002c   +tileDef  45, SNAKE_ADDR, 3, 2, 1, 0, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   319  1170 4524442447244624   +tileDef  46, SNAKE_ADDR, 69, 68, 71, 70, SNAKE_PAL, TILE_FLIP_H
   320  1178 3d243c243f243e24   +tileDef  47, SNAKE_ADDR, 61, 60, 63, 62, SNAKE_PAL, TILE_FLIP_H
   321  1180 472c462c452c442c   +tileDef  48, SNAKE_ADDR, 71, 70, 69, 68, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   322  1188 3f2c3e2c3d2c3c2c   +tileDef  49, SNAKE_ADDR, 63, 62, 61, 60, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   323  1190 312c302c352c342c   +tileDef  50, SNAKE_ADDR, 49, 48, 53, 52, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   324  1198 332c322c312c302c   +tileDef  51, SNAKE_ADDR, 51, 50, 49, 48, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   325  11a0 1420152016201720   +tileDef  52, SNAKE_ADDR, 20, 21, 22, 23, SNAKE_PAL, 0
   326  11a8 0c200d200e200f20   +tileDef  53, SNAKE_ADDR, 12, 13, 14, 15, SNAKE_PAL, 0
   327  11b0 1524142417241624   +tileDef  54, SNAKE_ADDR, 21, 20, 23, 22, SNAKE_PAL, TILE_FLIP_H
   328  11b8 0d240c240f240e24   +tileDef  55, SNAKE_ADDR, 13, 12, 15, 14, SNAKE_PAL, TILE_FLIP_H
   329  11c0 3220332010201020   +tileDef  56, SNAKE_ADDR, 50, 51, 16, 16, SNAKE_PAL, 0
   330  11c8 1020002010200220   +tileDef  57, SNAKE_ADDR, 16, 0, 16, 2, SNAKE_PAL, 0
   331  11d0 022c102c002c102c   +tileDef  58, SNAKE_ADDR, 2, 16, 0, 16, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   332  11d8 102c102c332c322c   +tileDef  59, SNAKE_ADDR, 16, 16, 51, 50, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   333  11e0 382039203a203b20   +tileDef  60, SNAKE_ADDR, 56, 57, 58, 59, SNAKE_PAL, 0
   334  11e8 3a203b2036203720   +tileDef  61, SNAKE_ADDR, 58, 59, 54, 55, SNAKE_PAL, 0
   335  11f0 192418241b241a24   +tileDef  62, SNAKE_ADDR, 25, 24, 27, 26, SNAKE_PAL, TILE_FLIP_H
   336  11f8 5628572854285528   +tileDef  63, SNAKE_ADDR, 86, 87, 84, 85, SNAKE_PAL, TILE_FLIP_V
   337  1200 182019201a201b20   +tileDef  64, SNAKE_ADDR, 24, 25, 26, 27, SNAKE_PAL, 0
   338  1208 572c562c552c542c   +tileDef  65, SNAKE_ADDR, 87, 86, 85, 84, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   339  1210 082009200a200b20   +tileDef  66, SNAKE_ADDR, 8, 9, 10, 11, SNAKE_PAL, 0
   340  1218 0520082007200a20   +tileDef  67, SNAKE_ADDR, 5, 8, 7, 10, SNAKE_PAL, 0
   341  1220 4b2c4a2c492c482c   +tileDef  68, SNAKE_ADDR, 75, 74, 73, 72, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   342  1228 272c262c252c242c   +tileDef  69, SNAKE_ADDR, 39, 38, 37, 36, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   343  1230 492448244b244a24   +tileDef  70, SNAKE_ADDR, 73, 72, 75, 74, SNAKE_PAL, TILE_FLIP_H
   344  1238 2524242427242624   +tileDef  71, SNAKE_ADDR, 37, 36, 39, 38, SNAKE_PAL, TILE_FLIP_H
   345  1240 0b2c0a2c092c082c   +tileDef  72, SNAKE_ADDR, 11, 10, 9, 8, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   346  1248 0a2c072c082c052c   +tileDef  73, SNAKE_ADDR, 10, 7, 8, 5, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   347  1250 4a284b2848284928   +tileDef  74, SNAKE_ADDR, 74, 75, 72, 73, SNAKE_PAL, TILE_FLIP_V
   348  1258 2628272824282528   +tileDef  75, SNAKE_ADDR, 38, 39, 36, 37, SNAKE_PAL, TILE_FLIP_V
   349  1260 482049204a204b20   +tileDef  76, SNAKE_ADDR, 72, 73, 74, 75, SNAKE_PAL, 0
   350  1268 2420252026202720   +tileDef  77, SNAKE_ADDR, 36, 37, 38, 39, SNAKE_PAL, 0
   351  1270 3b2c3a2c392c382c   +tileDef  78, SNAKE_ADDR, 59, 58, 57, 56, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   352  1278 372c362c3b2c3a2c   +tileDef  79, SNAKE_ADDR, 55, 54, 59, 58, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   353  1280 1b2c1a2c192c182c   +tileDef  80, SNAKE_ADDR, 27, 26, 25, 24, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   354  1288 5420552056205720   +tileDef  81, SNAKE_ADDR, 84, 85, 86, 87, SNAKE_PAL, 0
   355  1290 1a281b2818281928   +tileDef  82, SNAKE_ADDR, 26, 27, 24, 25, SNAKE_PAL, TILE_FLIP_V
   356  1298 5524542457245624   +tileDef  83, SNAKE_ADDR, 85, 84, 87, 86, SNAKE_PAL, TILE_FLIP_H
   357  12a0 1020102038203920   +tileDef  84, SNAKE_ADDR, 16, 16, 56, 57, SNAKE_PAL, 0
   358  12a8 2124202423242224   +tileDef  85, SNAKE_ADDR, 33, 32, 35, 34, SNAKE_PAL, TILE_FLIP_H
   359  12b0 2020212022202320   +tileDef  86, SNAKE_ADDR, 32, 33, 34, 35, SNAKE_PAL, 0
   360  12b8 092010200b201020   +tileDef  87, SNAKE_ADDR, 9, 16, 11, 16, SNAKE_PAL, 0
   361  12c0 532c522c512c502c   +tileDef  88, SNAKE_ADDR, 83, 82, 81, 80, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   362  12c8 5124502453245224   +tileDef  89, SNAKE_ADDR, 81, 80, 83, 82, SNAKE_PAL, TILE_FLIP_H
   363  12d0 102c0b2c102c092c   +tileDef  90, SNAKE_ADDR, 16, 11, 16, 9, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   364  12d8 5228532850285128   +tileDef  91, SNAKE_ADDR, 82, 83, 80, 81, SNAKE_PAL, TILE_FLIP_V
   365  12e0 5020512052205320   +tileDef  92, SNAKE_ADDR, 80, 81, 82, 83, SNAKE_PAL, 0
   366  12e8 392c382c102c102c   +tileDef  93, SNAKE_ADDR, 57, 56, 16, 16, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   367  12f0 232c222c212c202c   +tileDef  94, SNAKE_ADDR, 35, 34, 33, 32, SNAKE_PAL, TILE_FLIP_H | TILE_FLIP_V
   368  12f8 2228232820282128   +tileDef  95, SNAKE_ADDR, 34, 35, 32, 33, SNAKE_PAL, TILE_FLIP_V
   369  1300 1020102010201020   tileBlank:   +tileDef  96, SNAKE_ADDR, 16, 16, 16, 16, SNAKE_PAL, 0
   370                          tileBlank2:
   371                          
   372                          
   373                          ; Map snake segments to tile ids
   374                          ;
   375                          ; Snake segment ids consist of the segment type, from direction and to direction
   376                          ; 
   377                          ;
   378                          ; [ segment ][  from  ][  to   ]
   379                          ; [ 6  -  4 ][ 3 - 2  ][ 1 - 0 ];
   380                          ;
   381                          ; segments:
   382                          ;  0: Step 0 - Nose
   383                          ;  1: Step 0 - Head
   384                          ;  2: Step 0 - Body
   385                          ;  3: Step 0 - Tail
   386                          ;  4: Step 1 - Head
   387                          ;  5: Step 1 - Body
   388                          ;  6: Step 1 - Tail
   389                          ;  7: Step 1 - Tip
   390                          ;
   391                          ; from and to:
   392                          ;  0: Up
   393                          ;  1: Left
   394                          ;  2: Down
   395                          ;  3: Right
   396                          ;
   397                          
   398  1308 eaeaeaeaeaeaeaea...!align 255,0
   399                          snakeTileMap:
   400  1400 3b                 !byte 59; Nose_Up_0
   401  1401 00                 !byte 0
   402  1402 00                 !byte 0
   403  1403 00                 !byte 0
   404  1404 00                 !byte 0
   405  1405 39                 !byte 57; Nose_Left_0
   406  1406 00                 !byte 0
   407  1407 00                 !byte 0
   408  1408 00                 !byte 0
   409  1409 00                 !byte 0
   410  140a 38                 !byte 56; Nose_Down_0
   411  140b 00                 !byte 0
   412  140c 00                 !byte 0
   413  140d 00                 !byte 0
   414  140e 00                 !byte 0
   415  140f 3a                 !byte 58; Nose_Right_0
   416  1410 32                 !byte 50; Head_Up_0
   417  1411 34                 !byte 52; Head_UpLeft_0
   418  1412 00                 !byte 0
   419  1413 36                 !byte 54; Head_UpRight_0
   420  1414 2a                 !byte 42; Head_LeftUp_0
   421  1415 26                 !byte 38; Head_Left_0
   422  1416 28                 !byte 40; Head_LeftDown_0
   423  1417 00                 !byte 0
   424  1418 00                 !byte 0
   425  1419 22                 !byte 34; Head_DownLeft_0
   426  141a 20                 !byte 32; Head_Down_0
   427  141b 24                 !byte 36; Head_DownRight_0
   428  141c 30                 !byte 48; Head_RightUp_0
   429  141d 00                 !byte 0
   430  141e 2e                 !byte 46; Head_RightDown_0
   431  141f 2c                 !byte 44; Head_Right_0
   432  1420 1a                 !byte 26; Body_Up_0
   433  1421 1c                 !byte 28; Body_UpLeft_0
   434  1422 00                 !byte 0
   435  1423 1e                 !byte 30; Body_UpRight_0
   436  1424 12                 !byte 18; Body_LeftUp_0
   437  1425 0e                 !byte 14; Body_Left_0
   438  1426 10                 !byte 16; Body_LeftDown_0
   439  1427 00                 !byte 0
   440  1428 00                 !byte 0
   441  1429 0a                 !byte 10; Body_DownLeft_0
   442  142a 08                 !byte 8; Body_Down_0
   443  142b 0c                 !byte 12; Body_DownRight_0
   444  142c 18                 !byte 24; Body_RightUp_0
   445  142d 00                 !byte 0
   446  142e 16                 !byte 22; Body_RightDown_0
   447  142f 14                 !byte 20; Body_Right_0
   448  1430 4e                 !byte 78; Tail_Up_0
   449  1431 50                 !byte 80; Tail_UpLeft_0
   450  1432 00                 !byte 0
   451  1433 52                 !byte 82; Tail_UpRight_0
   452  1434 46                 !byte 70; Tail_LeftUp_0
   453  1435 42                 !byte 66; Tail_Left_0
   454  1436 44                 !byte 68; Tail_LeftDown_0
   455  1437 00                 !byte 0
   456  1438 00                 !byte 0
   457  1439 3e                 !byte 62; Tail_DownLeft_0
   458  143a 3c                 !byte 60; Tail_Down_0
   459  143b 40                 !byte 64; Tail_DownRight_0
   460  143c 4c                 !byte 76; Tail_RightUp_0
   461  143d 00                 !byte 0
   462  143e 4a                 !byte 74; Tail_RightDown_0
   463  143f 48                 !byte 72; Tail_Right_0
   464  1440 33                 !byte 51; Head_Up_1
   465  1441 35                 !byte 53; Head_UpLeft_1
   466  1442 00                 !byte 0
   467  1443 37                 !byte 55; Head_UpRight_1
   468  1444 2b                 !byte 43; Head_LeftUp_1
   469  1445 27                 !byte 39; Head_Left_1
   470  1446 29                 !byte 41; Head_LeftDown_1
   471  1447 00                 !byte 0
   472  1448 00                 !byte 0
   473  1449 23                 !byte 35; Head_DownLeft_1
   474  144a 21                 !byte 33; Head_Down_1
   475  144b 25                 !byte 37; Head_DownRight_1
   476  144c 31                 !byte 49; Head_RightUp_1
   477  144d 00                 !byte 0
   478  144e 2f                 !byte 47; Head_RightDown_1
   479  144f 2d                 !byte 45; Head_Right_1
   480  1450 1b                 !byte 27; Body_Up_1
   481  1451 1d                 !byte 29; Body_UpLeft_1
   482  1452 00                 !byte 0
   483  1453 1f                 !byte 31; Body_UpRight_1
   484  1454 13                 !byte 19; Body_LeftUp_1
   485  1455 0f                 !byte 15; Body_Left_1
   486  1456 11                 !byte 17; Body_LeftDown_1
   487  1457 00                 !byte 0
   488  1458 00                 !byte 0
   489  1459 0b                 !byte 11; Body_DownLeft_1
   490  145a 09                 !byte 9; Body_Down_1
   491  145b 0d                 !byte 13; Body_DownRight_1
   492  145c 19                 !byte 25; Body_RightUp_1
   493  145d 00                 !byte 0
   494  145e 17                 !byte 23; Body_RightDown_1
   495  145f 15                 !byte 21; Body_Right_1
   496  1460 4f                 !byte 79; Tail_Up_1
   497  1461 51                 !byte 81; Tail_UpLeft_1
   498  1462 00                 !byte 0
   499  1463 53                 !byte 83; Tail_UpRight_1
   500  1464 47                 !byte 71; Tail_LeftUp_1
   501  1465 43                 !byte 67; Tail_Left_1
   502  1466 45                 !byte 69; Tail_LeftDown_1
   503  1467 00                 !byte 0
   504  1468 00                 !byte 0
   505  1469 3f                 !byte 63; Tail_DownLeft_1
   506  146a 3d                 !byte 61; Tail_Down_1
   507  146b 41                 !byte 65; Tail_DownRight_1
   508  146c 4d                 !byte 77; Tail_RightUp_1
   509  146d 00                 !byte 0
   510  146e 4b                 !byte 75; Tail_RightDown_1
   511  146f 49                 !byte 73; Tail_Right_1
   512  1470 5d                 !byte 93; Tip_Up_1
   513  1471 5e                 !byte 94; Tip_UpLeft_1
   514  1472 00                 !byte 0
   515  1473 5f                 !byte 95; Tip_UpRight_1
   516  1474 59                 !byte 89; Tip_LeftUp_1
   517  1475 57                 !byte 87; Tip_Left_1
   518  1476 58                 !byte 88; Tip_LeftDown_1
   519  1477 00                 !byte 0
   520  1478 00                 !byte 0
   521  1479 55                 !byte 85; Tip_DownLeft_1
   522  147a 54                 !byte 84; Tip_Down_1
   523  147b 56                 !byte 86; Tip_DownRight_1
   524  147c 5c                 !byte 92; Tip_RightUp_1
   525  147d 00                 !byte 0
   526  147e 5b                 !byte 91; Tip_RightDown_1
   527  147f 5a                 !byte 90; Tip_Right_1

; ******** Source: src\snake.asm
    68                          

; ******** Source: src\gameloop.asm
     1                          ; Snake - Commander X16
     2                          ;
     3                          ; Game loop
     4                          ;
     5                          ; Copyright (c) 2020 Troy Schrapel
     6                          ;
     7                          ; This code is licensed under the MIT license
     8                          ;
     9                          ; https://github.com/visrealm/cx16-snake
    10                          ;
    11                          ;
    12                          
    13                          
    14                          SNAKE_GAMELOOP_ASM_ = 1
    15                          
    16                          
    17                          ; -----------------------------------------------------------------------------
    18                          ; loop to wait for vsync
    19                          ; -----------------------------------------------------------------------------
    20                          waitForVsync:
    21  1480 cb                   !byte $CB  ; WAI instruction
    22  1481 a530                 lda VSYNC_FLAG
    23  1483 d0fb                 bne waitForVsync
    24                          
    25                            ; flow on through to the.... 
    26                          
    27                          !macro testInputDir joyDir, snakeDir {
    28                            bit #joyDir
    29                            bne .nextDirection
    30                            lda ZP_CURRENT_DIRECTION
    31                            and #3
    32                            cmp #(snakeDir + 2) % 4
    33                            beq .nextDirection
    34                            asl
    35                            asl
    36                            ora #snakeDir
    37                            +qBack ZP_QUEUE_D_INDEX
    38                            sta (ZP_QUEUE_D), y
    39                            lda #snakeDir << 2 | snakeDir
    40                            sta ZP_CURRENT_DIRECTION
    41                            +qPush ZP_QUEUE_D_INDEX
    42                          
    43                            !if snakeDir = DIR_LEFT { dec ZP_HEAD_CELL_X }
    44                            !if snakeDir = DIR_RIGHT { inc ZP_HEAD_CELL_X }
    45                            lda ZP_HEAD_CELL_X
    46                            +qPush ZP_QUEUE_X_INDEX
    47                          
    48                            !if snakeDir = DIR_UP { dec ZP_HEAD_CELL_Y }
    49                            !if snakeDir = DIR_DOWN { inc ZP_HEAD_CELL_Y }
    50                            lda ZP_HEAD_CELL_Y
    51                            +qPush ZP_QUEUE_Y_INDEX
    52                          
    53                            rts
    54                          .nextDirection
    55                          }
    56                          
    57                          ; -----------------------------------------------------------------------------
    58                          ; main game loop
    59                          ; -----------------------------------------------------------------------------
    60                          gameLoop:
    61                          
    62  1485 c636                 dec ZP_ANIM_INDEX
    63  1487 d003                 bne +
    64  1489 20b815               jsr updateFrame
    65                          +
    66  148c 2056ff               jsr JOYSTICK_GET
    67  148f 6537                 adc ZP_RANDOM
    68  1491 8537                 sta ZP_RANDOM
    69                          
    70  1493 a901                 lda #1
    71  1495 8530                 sta VSYNC_FLAG
    72                          
    73  1497 80e7               	bra waitForVsync
    74                          
    75                          doInput:
    76                           
    77  1499 2056ff               jsr JOYSTICK_GET
    78  149c 8908d032a5332903...  +testInputDir JOY_UP, DIR_UP
    79  14d2 8904d032a5332903...  +testInputDir JOY_DOWN, DIR_DOWN
    80  1508 8902d032a5332903...  +testInputDir JOY_LEFT, DIR_LEFT
    81  153e 8901d032a5332903...  +testInputDir JOY_RIGHT, DIR_RIGHT
    82                          
    83  1574 a533                 lda ZP_CURRENT_DIRECTION
    84  1576 2903                 and #3
    85  1578 c900                 cmp #DIR_UP
    86  157a d004                 bne +
    87  157c c635                 dec ZP_HEAD_CELL_Y
    88  157e 8018                 bra .doneMove
    89                          +
    90  1580 c902                 cmp #DIR_DOWN
    91  1582 d004                 bne +
    92  1584 e635                 inc ZP_HEAD_CELL_Y
    93  1586 8010                 bra .doneMove
    94                          +
    95  1588 c901                 cmp #DIR_LEFT
    96  158a d004                 bne +
    97  158c c634                 dec ZP_HEAD_CELL_X
    98  158e 8008                 bra .doneMove
    99                          +
   100  1590 c903                 cmp #DIR_RIGHT
   101  1592 d004                 bne +
   102  1594 e634                 inc ZP_HEAD_CELL_X
   103  1596 8000                 bra .doneMove
   104                          +
   105                          
   106                          .doneMove:
   107  1598 a534                 lda ZP_HEAD_CELL_X
   108  159a a64020ca08           +qPush ZP_QUEUE_X_INDEX
   109                          
   110  159f a535                 lda ZP_HEAD_CELL_Y
   111  15a1 a64320ca08           +qPush ZP_QUEUE_Y_INDEX
   112                          
   113                            ; Here, we can test for collision
   114                          
   115  15a6 a533                 lda ZP_CURRENT_DIRECTION
   116  15a8 2903                 and #3
   117  15aa 8533                 sta ZP_CURRENT_DIRECTION
   118  15ac 0a                   asl
   119  15ad 0a                   asl
   120  15ae 0533                 ora ZP_CURRENT_DIRECTION
   121  15b0 8533                 sta ZP_CURRENT_DIRECTION
   122  15b2 a64620ca08           +qPush ZP_QUEUE_D_INDEX
   123  15b7 60                   rts
   124                          
   125                          
   126                          updateFrame:
   127  15b8 a53a                 lda ZP_FRAME_INDEX
   128  15ba 2901                 and #1
   129  15bc d027                 bne +
   130                          
   131  15be 209914               jsr doInput
   132                            
   133  15c1 a538                 lda ZP_APPLE_CELL_X
   134  15c3 8530                 sta ZP_CURRENT_CELL_X
   135  15c5 a539                 lda ZP_APPLE_CELL_Y
   136  15c7 8531                 sta ZP_CURRENT_CELL_Y
   137  15c9 20c70d               jsr setCellVram
   138  15cc a53a                 lda ZP_FRAME_INDEX
   139  15ce 2907                 and #7
   140  15d0 18                   clc
   141  15d1 6901                 adc #1
   142  15d3 20e60d               jsr outputTile
   143                          
   144  15d6 a640                 ldx ZP_QUEUE_X_INDEX
   145  15d8 200209               jsr qSize
   146  15db 48                   pha
   147  15dc 200d09               jsr qIterate
   148  15df fa                   plx  ; here, x i size, y is starting offset, a is queue msb
   149                          
   150  15e0 20f915               jsr doStep0
   151                          
   152  15e3 800d                 bra doneStep
   153                          +
   154  15e5 a640                 ldx ZP_QUEUE_X_INDEX
   155  15e7 200209               jsr qSize
   156  15ea 48                   pha
   157  15eb 200d09               jsr qIterate
   158  15ee fa                   plx  ; here, x i size, y is starting offset, a is queue msb
   159                          
   160  15ef 205016               jsr doStep1
   161                          
   162                          doneStep:  
   163                          
   164                            +dbgBreak
   165                          
   166  15f2 e63a                 inc ZP_FRAME_INDEX
   167                          
   168  15f4 a904                 lda #4
   169  15f6 8536                 sta ZP_ANIM_INDEX
   170                          
   171  15f8 60                   rts
   172                          
   173                          
   174                          doStep0:
   175  15f9 b141                 lda (ZP_QUEUE_X), y
   176  15fb 8530                 sta ZP_CURRENT_CELL_X
   177  15fd b144                 lda (ZP_QUEUE_Y), y
   178  15ff 8531                 sta ZP_CURRENT_CELL_Y
   179  1601 20c70d               jsr setCellVram
   180  1604 a960                 +ldaTileId tileBlank
   181  1606 20e60d               jsr outputTile
   182  1609 c8                   iny
   183  160a ca                   dex
   184                          
   185                          
   186  160b b141                 lda (ZP_QUEUE_X), y
   187  160d 8530                 sta ZP_CURRENT_CELL_X
   188  160f b144                 lda (ZP_QUEUE_Y), y
   189  1611 8531                 sta ZP_CURRENT_CELL_Y
   190  1613 20c70d               jsr setCellVram
   191  1616 b147                 lda (ZP_QUEUE_D), y
   192  1618 0930                 ora #$30  ; tail
   193  161a 5a                   phy
   194  161b a8                   tay
   195  161c b90014               lda snakeTileMap, y
   196  161f 7a                   ply
   197  1620 20e60d               jsr outputTile
   198  1623 c8                   iny
   199  1624 ca                   dex
   200                          
   201                          
   202                          --
   203  1625 b141                 lda (ZP_QUEUE_X), y
   204  1627 8530                 sta ZP_CURRENT_CELL_X
   205  1629 b144                 lda (ZP_QUEUE_Y), y
   206  162b 8531                 sta ZP_CURRENT_CELL_Y
   207  162d 20c70d               jsr setCellVram
   208  1630 b147                 lda (ZP_QUEUE_D), y
   209  1632 e002                 cpx #2
   210  1634 d004                 bne +
   211  1636 0910                 ora #$10 ; head
   212  1638 8008                 bra .doOutput0
   213                          +
   214  163a e001                 cpx #1
   215  163c f004                 beq +
   216  163e 0920                 ora #$20  ; body
   217  1640 8000                 bra .doOutput0
   218                          +
   219                          
   220                          .doOutput0:
   221  1642 5a                   phy
   222  1643 a8                   tay
   223  1644 b90014               lda snakeTileMap, y
   224  1647 7a                   ply
   225  1648 20e60d               jsr outputTile
   226                          
   227  164b c8                   iny
   228  164c ca                   dex
   229  164d d0d6                 bne --
   230                          
   231  164f 60                   rts
   232                          
   233                          doStep1:
   234  1650 b141                 lda (ZP_QUEUE_X), y
   235  1652 8530                 sta ZP_CURRENT_CELL_X
   236  1654 b144                 lda (ZP_QUEUE_Y), y
   237  1656 8531                 sta ZP_CURRENT_CELL_Y
   238  1658 20c70d               jsr setCellVram
   239  165b a960                 +ldaTileId tileBlank
   240  165d 20e60d               jsr outputTile
   241  1660 c8                   iny
   242  1661 ca                   dex
   243                          
   244                          
   245  1662 b141                 lda (ZP_QUEUE_X), y
   246  1664 8530                 sta ZP_CURRENT_CELL_X
   247  1666 b144                 lda (ZP_QUEUE_Y), y
   248  1668 8531                 sta ZP_CURRENT_CELL_Y
   249  166a 20c70d               jsr setCellVram
   250  166d b147                 lda (ZP_QUEUE_D), y
   251  166f 0970                 ora #$70  ; tip
   252  1671 5a                   phy
   253  1672 a8                   tay
   254  1673 b90014               lda snakeTileMap, y
   255  1676 7a                   ply
   256  1677 20e60d               jsr outputTile
   257  167a c8                   iny
   258  167b ca                   dex
   259                          
   260  167c b141                 lda (ZP_QUEUE_X), y
   261  167e 8530                 sta ZP_CURRENT_CELL_X
   262  1680 b144                 lda (ZP_QUEUE_Y), y
   263  1682 8531                 sta ZP_CURRENT_CELL_Y
   264  1684 20c70d               jsr setCellVram
   265  1687 b147                 lda (ZP_QUEUE_D), y
   266  1689 0960                 ora #$60  ; tail
   267  168b 5a                   phy
   268  168c a8                   tay
   269  168d b90014               lda snakeTileMap, y
   270  1690 7a                   ply
   271  1691 20e60d               jsr outputTile
   272  1694 c8                   iny
   273  1695 ca                   dex
   274                          
   275                          
   276                          --
   277  1696 b141                 lda (ZP_QUEUE_X), y
   278  1698 8530                 sta ZP_CURRENT_CELL_X
   279  169a b144                 lda (ZP_QUEUE_Y), y
   280  169c 8531                 sta ZP_CURRENT_CELL_Y
   281  169e 20c70d               jsr setCellVram
   282  16a1 b147                 lda (ZP_QUEUE_D), y
   283                            
   284  16a3 0940                 ora #$40 ; tip or body
   285  16a5 e001                 cpx #1   
   286  16a7 f002                 beq +
   287  16a9 0910                 ora #$10 ; body
   288                          +
   289  16ab 5a                   phy
   290  16ac a8                   tay
   291  16ad b90014               lda snakeTileMap, y
   292  16b0 7a                   ply
   293  16b1 20e60d               jsr outputTile
   294                          
   295  16b4 c8                   iny
   296  16b5 ca                   dex
   297  16b6 d0de                 bne --
   298                          
   299                          
   300  16b8 a534                 lda ZP_HEAD_CELL_X 
   301  16ba c538                 cmp ZP_APPLE_CELL_X
   302  16bc d018                 bne .doPop
   303  16be a535                 lda ZP_HEAD_CELL_Y 
   304  16c0 c539                 cmp ZP_APPLE_CELL_Y
   305  16c2 d012                 bne .doPop
   306                          
   307  16c4 a538                 lda ZP_APPLE_CELL_X
   308  16c6 6537                 adc ZP_RANDOM
   309  16c8 290f                 and #15
   310  16ca 8538                 sta ZP_APPLE_CELL_X
   311                          
   312  16cc a539                 lda ZP_APPLE_CELL_Y
   313  16ce 6537                 adc ZP_RANDOM
   314  16d0 290e                 and #14
   315  16d2 8539                 sta ZP_APPLE_CELL_Y
   316                          
   317                          
   318  16d4 800f                 bra .noPop
   319                          
   320                          .doPop:
   321  16d6 a64020e308           +qPop ZP_QUEUE_X_INDEX
   322  16db a64320e308           +qPop ZP_QUEUE_Y_INDEX
   323  16e0 a64620e308           +qPop ZP_QUEUE_D_INDEX
   324                          
   325                          .noPop:
   326                          

; ******** Source: src\snake.asm
    69  16e5 60                 
